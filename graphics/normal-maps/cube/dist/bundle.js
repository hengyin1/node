!function(g){var t=window.webpackHotUpdate;window.webpackHotUpdate=function(g,n){!function(g,t){if(!X[g]||!m[g])return;for(var n in m[g]=!1,t)Object.prototype.hasOwnProperty.call(t,n)&&(u[n]=t[n]);0==--F&&0===o&&U()}(g,n),t&&t(g,n)};var n,I=!0,B="6af8c67b280ea9862d84",e=1e4,c={},i=[],a=[];function Q(g){var t=V[g];if(!t)return p;var I=function(I){return t.hot.active?(V[I]?-1===V[I].parents.indexOf(g)&&V[I].parents.push(g):(i=[g],n=I),-1===t.children.indexOf(I)&&t.children.push(I)):(console.warn("[HMR] unexpected require("+I+") from disposed module "+g),i=[]),p(I)},B=function(g){return{configurable:!0,enumerable:!0,get:function(){return p[g]},set:function(t){p[g]=t}}};for(var e in p)Object.prototype.hasOwnProperty.call(p,e)&&"e"!==e&&"t"!==e&&Object.defineProperty(I,e,B(e));return I.e=function(g){return"ready"===G&&d("prepare"),o++,p.e(g).then(t,(function(g){throw t(),g}));function t(){o--,"prepare"===G&&(s[g]||Z(g),0===o&&0===F&&U())}},I.t=function(g,t){return 1&t&&(g=I(g)),p.t(g,-2&t)},I}function b(g){var t={_acceptedDependencies:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_disposeHandlers:[],_main:n!==g,active:!0,accept:function(g,n){if(void 0===g)t._selfAccepted=!0;else if("function"==typeof g)t._selfAccepted=g;else if("object"==typeof g)for(var I=0;I<g.length;I++)t._acceptedDependencies[g[I]]=n||function(){};else t._acceptedDependencies[g]=n||function(){}},decline:function(g){if(void 0===g)t._selfDeclined=!0;else if("object"==typeof g)for(var n=0;n<g.length;n++)t._declinedDependencies[g[n]]=!0;else t._declinedDependencies[g]=!0},dispose:function(g){t._disposeHandlers.push(g)},addDisposeHandler:function(g){t._disposeHandlers.push(g)},removeDisposeHandler:function(g){var n=t._disposeHandlers.indexOf(g);n>=0&&t._disposeHandlers.splice(n,1)},check:r,apply:y,status:function(g){if(!g)return G;l.push(g)},addStatusHandler:function(g){l.push(g)},removeStatusHandler:function(g){var t=l.indexOf(g);t>=0&&l.splice(t,1)},data:c[g]};return n=void 0,t}var l=[],G="idle";function d(g){G=g;for(var t=0;t<l.length;t++)l[t].call(null,g)}var C,u,A,F=0,o=0,s={},m={},X={};function h(g){return+g+""===g?+g:g}function r(g){if("idle"!==G)throw new Error("check() is only allowed in idle status");return I=g,d("check"),(t=e,t=t||1e4,new Promise((function(g,n){if("undefined"==typeof XMLHttpRequest)return n(new Error("No browser support"));try{var I=new XMLHttpRequest,e=p.p+""+B+".hot-update.json";I.open("GET",e,!0),I.timeout=t,I.send(null)}catch(g){return n(g)}I.onreadystatechange=function(){if(4===I.readyState)if(0===I.status)n(new Error("Manifest request to "+e+" timed out."));else if(404===I.status)g();else if(200!==I.status&&304!==I.status)n(new Error("Manifest request to "+e+" failed."));else{try{var t=JSON.parse(I.responseText)}catch(g){return void n(g)}g(t)}}}))).then((function(g){if(!g)return d("idle"),null;m={},s={},X=g.c,A=g.h,d("prepare");var t=new Promise((function(g,t){C={resolve:g,reject:t}}));u={};return Z(0),"prepare"===G&&0===o&&0===F&&U(),t}));var t}function Z(g){X[g]?(m[g]=!0,F++,function(g){var t=document.createElement("script");t.charset="utf-8",t.src=p.p+""+g+"."+B+".hot-update.js",document.head.appendChild(t)}(g)):s[g]=!0}function U(){d("ready");var g=C;if(C=null,g)if(I)Promise.resolve().then((function(){return y(I)})).then((function(t){g.resolve(t)}),(function(t){g.reject(t)}));else{var t=[];for(var n in u)Object.prototype.hasOwnProperty.call(u,n)&&t.push(h(n));g.resolve(t)}}function y(t){if("ready"!==G)throw new Error("apply() is only allowed in ready status");var n,I,e,a,Q;function b(g){for(var t=[g],n={},I=t.map((function(g){return{chain:[g],id:g}}));I.length>0;){var B=I.pop(),e=B.id,c=B.chain;if((a=V[e])&&!a.hot._selfAccepted){if(a.hot._selfDeclined)return{type:"self-declined",chain:c,moduleId:e};if(a.hot._main)return{type:"unaccepted",chain:c,moduleId:e};for(var i=0;i<a.parents.length;i++){var Q=a.parents[i],b=V[Q];if(b){if(b.hot._declinedDependencies[e])return{type:"declined",chain:c.concat([Q]),moduleId:e,parentId:Q};-1===t.indexOf(Q)&&(b.hot._acceptedDependencies[e]?(n[Q]||(n[Q]=[]),l(n[Q],[e])):(delete n[Q],t.push(Q),I.push({chain:c.concat([Q]),id:Q})))}}}}return{type:"accepted",moduleId:g,outdatedModules:t,outdatedDependencies:n}}function l(g,t){for(var n=0;n<t.length;n++){var I=t[n];-1===g.indexOf(I)&&g.push(I)}}t=t||{};var C={},F=[],o={},s=function(){console.warn("[HMR] unexpected require("+r.moduleId+") to disposed module")};for(var m in u)if(Object.prototype.hasOwnProperty.call(u,m)){var r;Q=h(m);var Z=!1,U=!1,y=!1,x="";switch((r=u[m]?b(Q):{type:"disposed",moduleId:m}).chain&&(x="\nUpdate propagation: "+r.chain.join(" -> ")),r.type){case"self-declined":t.onDeclined&&t.onDeclined(r),t.ignoreDeclined||(Z=new Error("Aborted because of self decline: "+r.moduleId+x));break;case"declined":t.onDeclined&&t.onDeclined(r),t.ignoreDeclined||(Z=new Error("Aborted because of declined dependency: "+r.moduleId+" in "+r.parentId+x));break;case"unaccepted":t.onUnaccepted&&t.onUnaccepted(r),t.ignoreUnaccepted||(Z=new Error("Aborted because "+Q+" is not accepted"+x));break;case"accepted":t.onAccepted&&t.onAccepted(r),U=!0;break;case"disposed":t.onDisposed&&t.onDisposed(r),y=!0;break;default:throw new Error("Unexception type "+r.type)}if(Z)return d("abort"),Promise.reject(Z);if(U)for(Q in o[Q]=u[Q],l(F,r.outdatedModules),r.outdatedDependencies)Object.prototype.hasOwnProperty.call(r.outdatedDependencies,Q)&&(C[Q]||(C[Q]=[]),l(C[Q],r.outdatedDependencies[Q]));y&&(l(F,[r.moduleId]),o[Q]=s)}var N,W=[];for(I=0;I<F.length;I++)Q=F[I],V[Q]&&V[Q].hot._selfAccepted&&o[Q]!==s&&W.push({module:Q,errorHandler:V[Q].hot._selfAccepted});d("dispose"),Object.keys(X).forEach((function(g){!1===X[g]&&function(g){delete installedChunks[g]}(g)}));for(var T,Y,H=F.slice();H.length>0;)if(Q=H.pop(),a=V[Q]){var R={},D=a.hot._disposeHandlers;for(e=0;e<D.length;e++)(n=D[e])(R);for(c[Q]=R,a.hot.active=!1,delete V[Q],delete C[Q],e=0;e<a.children.length;e++){var E=V[a.children[e]];E&&((N=E.parents.indexOf(Q))>=0&&E.parents.splice(N,1))}}for(Q in C)if(Object.prototype.hasOwnProperty.call(C,Q)&&(a=V[Q]))for(Y=C[Q],e=0;e<Y.length;e++)T=Y[e],(N=a.children.indexOf(T))>=0&&a.children.splice(N,1);for(Q in d("apply"),B=A,o)Object.prototype.hasOwnProperty.call(o,Q)&&(g[Q]=o[Q]);var S=null;for(Q in C)if(Object.prototype.hasOwnProperty.call(C,Q)&&(a=V[Q])){Y=C[Q];var v=[];for(I=0;I<Y.length;I++)if(T=Y[I],n=a.hot._acceptedDependencies[T]){if(-1!==v.indexOf(n))continue;v.push(n)}for(I=0;I<v.length;I++){n=v[I];try{n(Y)}catch(g){t.onErrored&&t.onErrored({type:"accept-errored",moduleId:Q,dependencyId:Y[I],error:g}),t.ignoreErrored||S||(S=g)}}}for(I=0;I<W.length;I++){var O=W[I];Q=O.module,i=[Q];try{p(Q)}catch(g){if("function"==typeof O.errorHandler)try{O.errorHandler(g)}catch(n){t.onErrored&&t.onErrored({type:"self-accept-error-handler-errored",moduleId:Q,error:n,originalError:g}),t.ignoreErrored||S||(S=n),S||(S=g)}else t.onErrored&&t.onErrored({type:"self-accept-errored",moduleId:Q,error:g}),t.ignoreErrored||S||(S=g)}}return S?(d("fail"),Promise.reject(S)):(d("idle"),new Promise((function(g){g(F)})))}var V={};function p(t){if(V[t])return V[t].exports;var n=V[t]={i:t,l:!1,exports:{},hot:b(t),parents:(a=i,i=[],a),children:[]};return g[t].call(n.exports,n,n.exports,Q(t)),n.l=!0,n.exports}p.m=g,p.c=V,p.d=function(g,t,n){p.o(g,t)||Object.defineProperty(g,t,{enumerable:!0,get:n})},p.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},p.t=function(g,t){if(1&t&&(g=p(g)),8&t)return g;if(4&t&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(p.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&t&&"string"!=typeof g)for(var I in g)p.d(n,I,function(t){return g[t]}.bind(null,I));return n},p.n=function(g){var t=g&&g.__esModule?function(){return g.default}:function(){return g};return p.d(t,"a",t),t},p.o=function(g,t){return Object.prototype.hasOwnProperty.call(g,t)},p.p="",p.h=function(){return B},Q("./graphics/normal-maps/cube/cube.js")(p.s="./graphics/normal-maps/cube/cube.js")}({"./graphics/normal-maps/cube/cube.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/Vec3Func.js\nconst EPSILON = 0.000001;\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction Vec3Func_length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction Vec3Func_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  let ax = a[0],\n      ay = a[1],\n      az = a[2];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\n\nfunction lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  let x = a[0],\n      y = a[1],\n      z = a[2];\n  let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat3(out, a, m) {\n  let x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  let x = a[0],\n      y = a[1],\n      z = a[2];\n  let qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  let uvx = qy * z - qz * y;\n  let uvy = qz * x - qx * z;\n  let uvz = qx * y - qy * x;\n  let uuvx = qy * uvz - qz * uvy;\n  let uuvy = qz * uvx - qx * uvz;\n  let uuvz = qx * uvy - qy * uvx;\n  let w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2;\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2;\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nconst angle = function () {\n  const tempA = [0, 0, 0];\n  const tempB = [0, 0, 0];\n  return function (a, b) {\n    copy(tempA, a);\n    copy(tempB, b);\n    normalize(tempA, tempA);\n    normalize(tempB, tempB);\n    let cosine = dot(tempA, tempB);\n\n    if (cosine > 1.0) {\n      return 0;\n    } else if (cosine < -1.0) {\n      return Math.PI;\n    } else {\n      return Math.acos(cosine);\n    }\n  };\n}();\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Vec3.js\n\nclass Vec3_Vec3 extends Array {\n  constructor(x = 0, y = x, z = x) {\n    super(x, y, z);\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set x(v) {\n    this[0] = v;\n  }\n\n  set y(v) {\n    this[1] = v;\n  }\n\n  set z(v) {\n    this[2] = v;\n  }\n\n  set(x, y = x, z = x) {\n    if (x.length) return this.copy(x);\n    set(this, x, y, z);\n    return this;\n  }\n\n  copy(v) {\n    copy(this, v);\n    return this;\n  }\n\n  add(va, vb) {\n    if (vb) add(this, va, vb);else add(this, this, va);\n    return this;\n  }\n\n  sub(va, vb) {\n    if (vb) subtract(this, va, vb);else subtract(this, this, va);\n    return this;\n  }\n\n  multiply(v) {\n    if (v.length) multiply(this, this, v);else Vec3Func_scale(this, this, v);\n    return this;\n  }\n\n  divide(v) {\n    if (v.length) divide(this, this, v);else Vec3Func_scale(this, this, 1 / v);\n    return this;\n  }\n\n  inverse(v = this) {\n    inverse(this, v);\n    return this;\n  } // Can't use 'length' as Array.prototype uses it\n\n\n  len() {\n    return Vec3Func_length(this);\n  }\n\n  distance(v) {\n    if (v) return distance(this, v);else return Vec3Func_length(this);\n  }\n\n  squaredLen() {\n    return squaredLength(this);\n  }\n\n  squaredDistance(v) {\n    if (v) return squaredDistance(this, v);else return squaredLength(this);\n  }\n\n  negate(v = this) {\n    negate(this, v);\n    return this;\n  }\n\n  cross(va, vb) {\n    if (vb) cross(this, va, vb);else cross(this, this, va);\n    return this;\n  }\n\n  scale(v) {\n    Vec3Func_scale(this, this, v);\n    return this;\n  }\n\n  normalize() {\n    normalize(this, this);\n    return this;\n  }\n\n  dot(v) {\n    return dot(this, v);\n  }\n\n  equals(v) {\n    return exactEquals(this, v);\n  }\n\n  applyMatrix4(mat4) {\n    transformMat4(this, this, mat4);\n    return this;\n  }\n\n  applyQuaternion(q) {\n    transformQuat(this, this, q);\n    return this;\n  }\n\n  angle(v) {\n    return angle(this, v);\n  }\n\n  lerp(v, t) {\n    lerp(this, this, v, t);\n    return this;\n  }\n\n  clone() {\n    return new Vec3_Vec3(this[0], this[1], this[2]);\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    this[2] = a[o + 2];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    a[o + 2] = this[2];\n    return a;\n  }\n\n  transformDirection(mat4) {\n    const x = this[0];\n    const y = this[1];\n    const z = this[2];\n    this[0] = mat4[0] * x + mat4[4] * y + mat4[8] * z;\n    this[1] = mat4[1] * x + mat4[5] * y + mat4[9] * z;\n    this[2] = mat4[2] * x + mat4[6] * y + mat4[10] * z;\n    return this.normalize();\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/Geometry.js\n// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n//     buffer - gl buffer, if buffer exists, don't need to provide data\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n// TODO: fit in transform feedback\n// TODO: when would I disableVertexAttribArray ?\n// TODO: add fallback for non vao support (ie)\n// TODO: use offset/stride if exists\n// TODO: check size of position (eg triangle with Vec2)\n\nconst tempVec3 = new Vec3_Vec3();\nlet ID = 1;\nlet ATTR_ID = 1; // To stop inifinite warnings\n\nlet isBoundsWarned = false;\nclass Geometry_Geometry {\n  constructor(gl, attributes = {}) {\n    if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n    this.gl = gl;\n    this.attributes = attributes;\n    this.id = ID++; // Store one VAO per program attribute locations order\n\n    this.VAOs = {};\n    this.drawRange = {\n      start: 0,\n      count: 0\n    };\n    this.instancedCount = 0; // Unbind current VAO so that new buffers don't get added to active mesh\n\n    this.gl.renderer.bindVertexArray(null);\n    this.gl.renderer.currentGeometry = null; // Alias for state store to avoid redundant calls for global state\n\n    this.glState = this.gl.renderer.state; // create the buffers\n\n    for (let key in attributes) {\n      this.addAttribute(key, attributes[key]);\n    }\n  }\n\n  addAttribute(key, attr) {\n    this.attributes[key] = attr; // Set options\n\n    attr.id = ATTR_ID++; // TODO: currently unused, remove?\n\n    attr.size = attr.size || 1;\n    attr.type = attr.type || (attr.data.constructor === Float32Array ? this.gl.FLOAT : attr.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT); // Uint32Array\n\n    attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n    attr.normalized = attr.normalized || false;\n    attr.stride = attr.stride || 0;\n    attr.offset = attr.offset || 0;\n    attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n    attr.divisor = attr.instanced || 0;\n    attr.needsUpdate = false;\n\n    if (!attr.buffer) {\n      attr.buffer = this.gl.createBuffer(); // Push data to buffer\n\n      this.updateAttribute(attr);\n    } // Update geometry counts. If indexed, ignore regular attributes\n\n\n    if (attr.divisor) {\n      this.isInstanced = true;\n\n      if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n        console.warn('geometry has multiple instanced buffers of different length');\n        return this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor);\n      }\n\n      this.instancedCount = attr.count * attr.divisor;\n    } else if (key === 'index') {\n      this.drawRange.count = attr.count;\n    } else if (!this.attributes.index) {\n      this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n    }\n  }\n\n  updateAttribute(attr) {\n    if (this.glState.boundBuffer !== attr.buffer) {\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n    }\n\n    this.gl.bufferData(attr.target, attr.data, this.gl.STATIC_DRAW);\n    attr.needsUpdate = false;\n  }\n\n  setIndex(value) {\n    this.addAttribute('index', value);\n  }\n\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n\n  setInstancedCount(value) {\n    this.instancedCount = value;\n  }\n\n  createVAO(program) {\n    this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n    this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n    this.bindAttributes(program);\n  }\n\n  bindAttributes(program) {\n    // Link all attributes to program using gl.vertexAttribPointer\n    program.attributeLocations.forEach((location, name) => {\n      // If geometry missing a required shader attribute\n      if (!this.attributes[name]) {\n        console.warn(`active attribute ${name} not being supplied`);\n        return;\n      }\n\n      const attr = this.attributes[name];\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n      this.gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);\n      this.gl.enableVertexAttribArray(location); // For instanced attributes, divisor needs to be set.\n      // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n\n      this.gl.renderer.vertexAttribDivisor(location, attr.divisor);\n    }); // Bind indices if geometry indexed\n\n    if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n  }\n\n  draw({\n    program,\n    mode = this.gl.TRIANGLES\n  }) {\n    if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n      if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n      this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n      this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n    } // Check if any attributes need updating\n\n\n    program.attributeLocations.forEach((location, name) => {\n      const attr = this.attributes[name];\n      if (attr.needsUpdate) this.updateAttribute(attr);\n    });\n\n    if (this.isInstanced) {\n      if (this.attributes.index) {\n        this.gl.renderer.drawElementsInstanced(mode, this.drawRange.count, this.attributes.index.type, this.drawRange.start, this.instancedCount);\n      } else {\n        this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n      }\n    } else {\n      if (this.attributes.index) {\n        this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2);\n      } else {\n        this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n      }\n    }\n  }\n\n  getPositionArray() {\n    // Use position buffer, or min/max if available\n    const attr = this.attributes.position;\n    if (attr.min) return [...attr.min, ...attr.max];\n    if (attr.data) return attr.data;\n    if (isBoundsWarned) return;\n    console.warn('No position buffer data found to compute bounds');\n    return isBoundsWarned = true;\n  }\n\n  computeBoundingBox(array) {\n    if (!array) array = this.getPositionArray();\n\n    if (!this.bounds) {\n      this.bounds = {\n        min: new Vec3_Vec3(),\n        max: new Vec3_Vec3(),\n        center: new Vec3_Vec3(),\n        scale: new Vec3_Vec3(),\n        radius: Infinity\n      };\n    }\n\n    const min = this.bounds.min;\n    const max = this.bounds.max;\n    const center = this.bounds.center;\n    const scale = this.bounds.scale;\n    min.set(+Infinity);\n    max.set(-Infinity); // TODO: use offset/stride if exists\n    // TODO: check size of position (eg triangle with Vec2)\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      min.x = Math.min(x, min.x);\n      min.y = Math.min(y, min.y);\n      min.z = Math.min(z, min.z);\n      max.x = Math.max(x, max.x);\n      max.y = Math.max(y, max.y);\n      max.z = Math.max(z, max.z);\n    }\n\n    scale.sub(max, min);\n    center.add(min, max).divide(2);\n  }\n\n  computeBoundingSphere(array) {\n    if (!array) array = this.getPositionArray();\n    if (!this.bounds) this.computeBoundingBox(array);\n    let maxRadiusSq = 0;\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      tempVec3.fromArray(array, i);\n      maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n    }\n\n    this.bounds.radius = Math.sqrt(maxRadiusSq);\n  }\n\n  remove() {\n    if (this.vao) this.gl.renderer.deleteVertexArray(this.vao);\n\n    for (let key in this.attributes) {\n      this.gl.deleteBuffer(this.attributes[key].buffer);\n      delete this.attributes[key];\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/Program.js\n// TODO: upload empty texture if null ? maybe not\n// TODO: upload identity matrix if null ?\n// TODO: sampler Cube\nlet Program_ID = 1; // cache of typed arrays used to flatten uniform arrays\n\nconst arrayCacheF32 = {};\nclass Program {\n  constructor(gl, {\n    vertex,\n    fragment,\n    uniforms = {},\n    transparent = false,\n    cullFace = gl.BACK,\n    frontFace = gl.CCW,\n    depthTest = true,\n    depthWrite = true,\n    depthFunc = gl.LESS\n  } = {}) {\n    if (!gl.canvas) console.error('gl not passed as fist argument to Program');\n    this.gl = gl;\n    this.uniforms = uniforms;\n    this.id = Program_ID++;\n    if (!vertex) console.warn('vertex shader not supplied');\n    if (!fragment) console.warn('fragment shader not supplied'); // Store program state\n\n    this.transparent = transparent;\n    this.cullFace = cullFace;\n    this.frontFace = frontFace;\n    this.depthTest = depthTest;\n    this.depthWrite = depthWrite;\n    this.depthFunc = depthFunc;\n    this.blendFunc = {};\n    this.blendEquation = {}; // set default blendFunc if transparent flagged\n\n    if (this.transparent && !this.blendFunc.src) {\n      if (this.gl.renderer.premultipliedAlpha) this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);else this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n    } // compile vertex shader and log errors\n\n\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, vertex);\n    gl.compileShader(vertexShader);\n\n    if (gl.getShaderInfoLog(vertexShader) !== '') {\n      console.warn(`${gl.getShaderInfoLog(vertexShader)}\\nVertex Shader\\n${addLineNumbers(vertex)}`);\n    } // compile fragment shader and log errors\n\n\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, fragment);\n    gl.compileShader(fragmentShader);\n\n    if (gl.getShaderInfoLog(fragmentShader) !== '') {\n      console.warn(`${gl.getShaderInfoLog(fragmentShader)}\\nFragment Shader\\n${addLineNumbers(fragment)}`);\n    } // compile program and log errors\n\n\n    this.program = gl.createProgram();\n    gl.attachShader(this.program, vertexShader);\n    gl.attachShader(this.program, fragmentShader);\n    gl.linkProgram(this.program);\n\n    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n      return console.warn(gl.getProgramInfoLog(this.program));\n    } // Remove shader once linked\n\n\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader); // Get active uniform locations\n\n    this.uniformLocations = new Map();\n    let numUniforms = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n\n    for (let uIndex = 0; uIndex < numUniforms; uIndex++) {\n      let uniform = gl.getActiveUniform(this.program, uIndex);\n      this.uniformLocations.set(uniform, gl.getUniformLocation(this.program, uniform.name)); // split uniforms' names to separate array and struct declarations\n\n      const split = uniform.name.match(/(\\w+)/g);\n      uniform.uniformName = split[0];\n\n      if (split.length === 3) {\n        uniform.isStructArray = true;\n        uniform.structIndex = Number(split[1]);\n        uniform.structProperty = split[2];\n      } else if (split.length === 2 && isNaN(Number(split[1]))) {\n        uniform.isStruct = true;\n        uniform.structProperty = split[1];\n      }\n    } // Get active attribute locations\n\n\n    this.attributeLocations = new Map();\n    const locations = [];\n    const numAttribs = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\n\n    for (let aIndex = 0; aIndex < numAttribs; aIndex++) {\n      const attribute = gl.getActiveAttrib(this.program, aIndex);\n      const location = gl.getAttribLocation(this.program, attribute.name);\n      locations[location] = attribute.name;\n      this.attributeLocations.set(attribute.name, location);\n    }\n\n    this.attributeOrder = locations.join('');\n  }\n\n  setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n    this.blendFunc.src = src;\n    this.blendFunc.dst = dst;\n    this.blendFunc.srcAlpha = srcAlpha;\n    this.blendFunc.dstAlpha = dstAlpha;\n    if (src) this.transparent = true;\n  }\n\n  setBlendEquation(modeRGB, modeAlpha) {\n    this.blendEquation.modeRGB = modeRGB;\n    this.blendEquation.modeAlpha = modeAlpha;\n  }\n\n  applyState() {\n    if (this.depthTest) this.gl.renderer.enable(this.gl.DEPTH_TEST);else this.gl.renderer.disable(this.gl.DEPTH_TEST);\n    if (this.cullFace) this.gl.renderer.enable(this.gl.CULL_FACE);else this.gl.renderer.disable(this.gl.CULL_FACE);\n    if (this.blendFunc.src) this.gl.renderer.enable(this.gl.BLEND);else this.gl.renderer.disable(this.gl.BLEND);\n    if (this.cullFace) this.gl.renderer.setCullFace(this.cullFace);\n    this.gl.renderer.setFrontFace(this.frontFace);\n    this.gl.renderer.setDepthMask(this.depthWrite);\n    this.gl.renderer.setDepthFunc(this.depthFunc);\n    if (this.blendFunc.src) this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha);\n    if (this.blendEquation.modeRGB) this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);\n  }\n\n  use({\n    flipFaces = false\n  } = {}) {\n    let textureUnit = -1;\n    const programActive = this.gl.renderer.currentProgram === this.id; // Avoid gl call if program already in use\n\n    if (!programActive) {\n      this.gl.useProgram(this.program);\n      this.gl.renderer.currentProgram = this.id;\n    } // Set only the active uniforms found in the shader\n\n\n    this.uniformLocations.forEach((location, activeUniform) => {\n      let name = activeUniform.uniformName; // get supplied uniform\n\n      let uniform = this.uniforms[name]; // For structs, get the specific property instead of the entire object\n\n      if (activeUniform.isStruct) {\n        uniform = uniform[activeUniform.structProperty];\n        name += `.${activeUniform.structProperty}`;\n      }\n\n      if (activeUniform.isStructArray) {\n        uniform = uniform[activeUniform.structIndex][activeUniform.structProperty];\n        name += `[${activeUniform.structIndex}].${activeUniform.structProperty}`;\n      }\n\n      if (!uniform) {\n        return warn(`Active uniform ${name} has not been supplied`);\n      }\n\n      if (uniform && uniform.value === undefined) {\n        return warn(`${name} uniform is missing a value parameter`);\n      }\n\n      if (uniform.value.texture) {\n        textureUnit = textureUnit + 1; // Check if texture needs to be updated\n\n        uniform.value.update(textureUnit);\n        return setUniform(this.gl, activeUniform.type, location, textureUnit);\n      } // For texture arrays, set uniform as an array of texture units instead of just one\n\n\n      if (uniform.value.length && uniform.value[0].texture) {\n        const textureUnits = [];\n        uniform.value.forEach(value => {\n          textureUnit = textureUnit + 1;\n          value.update(textureUnit);\n          textureUnits.push(textureUnit);\n        });\n        return setUniform(this.gl, activeUniform.type, location, textureUnits);\n      }\n\n      setUniform(this.gl, activeUniform.type, location, uniform.value);\n    });\n    this.applyState();\n    if (flipFaces) this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);\n  }\n\n  remove() {\n    this.gl.deleteProgram(this.program);\n  }\n\n}\n\nfunction setUniform(gl, type, location, value) {\n  value = value.length ? flatten(value) : value;\n  const setValue = gl.renderer.state.uniformLocations.get(location); // Avoid redundant uniform commands\n\n  if (value.length) {\n    if (setValue === undefined) {\n      // clone array to store as cache\n      gl.renderer.state.uniformLocations.set(location, value.slice(0));\n    } else {\n      if (arraysEqual(setValue, value)) return; // Update cached array values\n\n      setValue.set ? setValue.set(value) : setArray(setValue, value);\n      gl.renderer.state.uniformLocations.set(location, setValue);\n    }\n  } else {\n    if (setValue === value) return;\n    gl.renderer.state.uniformLocations.set(location, value);\n  }\n\n  switch (type) {\n    case 5126:\n      return value.length ? gl.uniform1fv(location, value) : gl.uniform1f(location, value);\n    // FLOAT\n\n    case 35664:\n      return gl.uniform2fv(location, value);\n    // FLOAT_VEC2\n\n    case 35665:\n      return gl.uniform3fv(location, value);\n    // FLOAT_VEC3\n\n    case 35666:\n      return gl.uniform4fv(location, value);\n    // FLOAT_VEC4\n\n    case 35670: // BOOL\n\n    case 5124: // INT\n\n    case 35678: // SAMPLER_2D\n\n    case 35680:\n      return value.length ? gl.uniform1iv(location, value) : gl.uniform1i(location, value);\n    // SAMPLER_CUBE\n\n    case 35671: // BOOL_VEC2\n\n    case 35667:\n      return gl.uniform2iv(location, value);\n    // INT_VEC2\n\n    case 35672: // BOOL_VEC3\n\n    case 35668:\n      return gl.uniform3iv(location, value);\n    // INT_VEC3\n\n    case 35673: // BOOL_VEC4\n\n    case 35669:\n      return gl.uniform4iv(location, value);\n    // INT_VEC4\n\n    case 35674:\n      return gl.uniformMatrix2fv(location, false, value);\n    // FLOAT_MAT2\n\n    case 35675:\n      return gl.uniformMatrix3fv(location, false, value);\n    // FLOAT_MAT3\n\n    case 35676:\n      return gl.uniformMatrix4fv(location, false, value);\n    // FLOAT_MAT4\n  }\n}\n\nfunction addLineNumbers(string) {\n  let lines = string.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = i + 1 + ': ' + lines[i];\n  }\n\n  return lines.join('\\n');\n}\n\nfunction flatten(a) {\n  const arrayLen = a.length;\n  const valueLen = a[0].length;\n  if (valueLen === undefined) return a;\n  const length = arrayLen * valueLen;\n  let value = arrayCacheF32[length];\n  if (!value) arrayCacheF32[length] = value = new Float32Array(length);\n\n  for (let i = 0; i < arrayLen; i++) value.set(a[i], i * valueLen);\n\n  return value;\n}\n\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nfunction setArray(a, b) {\n  for (let i = 0, l = a.length; i < l; i++) {\n    a[i] = b[i];\n  }\n}\n\nlet warnCount = 0;\n\nfunction warn(message) {\n  if (warnCount > 100) return;\n  console.warn(message);\n  warnCount++;\n  if (warnCount > 100) console.warn('More than 100 program warnings - stopping logs.');\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/Renderer.js\n // TODO: Handle context loss https://www.khronos.org/webgl/wiki/HandlingContextLost\n// Not automatic - devs to use these methods manually\n// gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n// gl.clearColor( r, g, b, a );\n// gl.stencilMask( stencilMask );\n// gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n// gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n// gl.clearStencil( stencil );\n\nconst Renderer_tempVec3 = new Vec3_Vec3();\nlet Renderer_ID = 1;\nclass Renderer {\n  constructor({\n    canvas = document.createElement('canvas'),\n    width = 300,\n    height = 150,\n    dpr = 1,\n    alpha = false,\n    depth = true,\n    stencil = false,\n    antialias = false,\n    premultipliedAlpha = false,\n    preserveDrawingBuffer = false,\n    powerPreference = 'default',\n    autoClear = true,\n    webgl = 2\n  } = {}) {\n    const attributes = {\n      alpha,\n      depth,\n      stencil,\n      antialias,\n      premultipliedAlpha,\n      preserveDrawingBuffer,\n      powerPreference\n    };\n    this.dpr = dpr;\n    this.alpha = alpha;\n    this.color = true;\n    this.depth = depth;\n    this.stencil = stencil;\n    this.premultipliedAlpha = premultipliedAlpha;\n    this.autoClear = autoClear;\n    this.id = Renderer_ID++; // Attempt WebGL2 unless forced to 1, if not supported fallback to WebGL1\n\n    if (webgl === 2) this.gl = canvas.getContext('webgl2', attributes);\n    this.isWebgl2 = !!this.gl;\n\n    if (!this.gl) {\n      this.gl = canvas.getContext('webgl', attributes) || canvas.getContext('experimental-webgl', attributes);\n    } // Attach renderer to gl so that all classes have access to internal state functions\n\n\n    this.gl.renderer = this; // initialise size values\n\n    this.setSize(width, height); // gl state stores to avoid redundant calls on methods used internally\n\n    this.state = {};\n    this.state.blendFunc = {\n      src: this.gl.ONE,\n      dst: this.gl.ZERO\n    };\n    this.state.blendEquation = {\n      modeRGB: this.gl.FUNC_ADD\n    };\n    this.state.cullFace = null;\n    this.state.frontFace = this.gl.CCW;\n    this.state.depthMask = true;\n    this.state.depthFunc = this.gl.LESS;\n    this.state.premultiplyAlpha = false;\n    this.state.flipY = false;\n    this.state.unpackAlignment = 4;\n    this.state.framebuffer = null;\n    this.state.viewport = {\n      width: null,\n      height: null\n    };\n    this.state.textureUnits = [];\n    this.state.activeTextureUnit = 0;\n    this.state.boundBuffer = null;\n    this.state.uniformLocations = new Map(); // store requested extensions\n\n    this.extensions = {}; // Initialise extra format types\n\n    if (this.isWebgl2) {\n      this.getExtension('EXT_color_buffer_float');\n      this.getExtension('OES_texture_float_linear');\n    } else {\n      this.getExtension('OES_texture_float');\n      this.getExtension('OES_texture_float_linear');\n      this.getExtension('OES_texture_half_float');\n      this.getExtension('OES_texture_half_float_linear');\n      this.getExtension('OES_element_index_uint');\n      this.getExtension('OES_standard_derivatives');\n      this.getExtension('EXT_sRGB');\n      this.getExtension('WEBGL_depth_texture');\n      this.getExtension('WEBGL_draw_buffers');\n    } // Create method aliases using extension (WebGL1) or native if available (WebGL2)\n\n\n    this.vertexAttribDivisor = this.getExtension('ANGLE_instanced_arrays', 'vertexAttribDivisor', 'vertexAttribDivisorANGLE');\n    this.drawArraysInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawArraysInstanced', 'drawArraysInstancedANGLE');\n    this.drawElementsInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawElementsInstanced', 'drawElementsInstancedANGLE');\n    this.createVertexArray = this.getExtension('OES_vertex_array_object', 'createVertexArray', 'createVertexArrayOES');\n    this.bindVertexArray = this.getExtension('OES_vertex_array_object', 'bindVertexArray', 'bindVertexArrayOES');\n    this.deleteVertexArray = this.getExtension('OES_vertex_array_object', 'deleteVertexArray', 'deleteVertexArrayOES');\n    this.drawBuffers = this.getExtension('WEBGL_draw_buffers', 'drawBuffers', 'drawBuffersWEBGL'); // Store device parameters\n\n    this.parameters = {};\n    this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this.parameters.maxAnisotropy = this.getExtension('EXT_texture_filter_anisotropic') ? this.gl.getParameter(this.getExtension('EXT_texture_filter_anisotropic').MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n  }\n\n  setSize(width, height) {\n    this.width = width;\n    this.height = height;\n    this.gl.canvas.width = width * this.dpr;\n    this.gl.canvas.height = height * this.dpr;\n    Object.assign(this.gl.canvas.style, {\n      width: width + 'px',\n      height: height + 'px'\n    });\n  }\n\n  setViewport(width, height) {\n    if (this.state.viewport.width === width && this.state.viewport.height === height) return;\n    this.state.viewport.width = width;\n    this.state.viewport.height = height;\n    this.gl.viewport(0, 0, width, height);\n  }\n\n  enable(id) {\n    if (this.state[id] === true) return;\n    this.gl.enable(id);\n    this.state[id] = true;\n  }\n\n  disable(id) {\n    if (this.state[id] === false) return;\n    this.gl.disable(id);\n    this.state[id] = false;\n  }\n\n  setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n    if (this.state.blendFunc.src === src && this.state.blendFunc.dst === dst && this.state.blendFunc.srcAlpha === srcAlpha && this.state.blendFunc.dstAlpha === dstAlpha) return;\n    this.state.blendFunc.src = src;\n    this.state.blendFunc.dst = dst;\n    this.state.blendFunc.srcAlpha = srcAlpha;\n    this.state.blendFunc.dstAlpha = dstAlpha;\n    if (srcAlpha !== undefined) this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);else this.gl.blendFunc(src, dst);\n  }\n\n  setBlendEquation(modeRGB, modeAlpha) {\n    if (this.state.blendEquation.modeRGB === modeRGB && this.state.blendEquation.modeAlpha === modeAlpha) return;\n    this.state.blendEquation.modeRGB = modeRGB;\n    this.state.blendEquation.modeAlpha = modeAlpha;\n    if (modeAlpha !== undefined) this.gl.blendEquationSeparate(modeRGB, modeAlpha);else this.gl.blendEquation(modeRGB);\n  }\n\n  setCullFace(value) {\n    if (this.state.cullFace === value) return;\n    this.state.cullFace = value;\n    this.gl.cullFace(value);\n  }\n\n  setFrontFace(value) {\n    if (this.state.frontFace === value) return;\n    this.state.frontFace = value;\n    this.gl.frontFace(value);\n  }\n\n  setDepthMask(value) {\n    if (this.state.depthMask === value) return;\n    this.state.depthMask = value;\n    this.gl.depthMask(value);\n  }\n\n  setDepthFunc(value) {\n    if (this.state.depthFunc === value) return;\n    this.state.depthFunc = value;\n    this.gl.depthFunc(value);\n  }\n\n  activeTexture(value) {\n    if (this.state.activeTextureUnit === value) return;\n    this.state.activeTextureUnit = value;\n    this.gl.activeTexture(this.gl.TEXTURE0 + value);\n  }\n\n  bindFramebuffer({\n    target = this.gl.FRAMEBUFFER,\n    buffer = null\n  } = {}) {\n    if (this.state.framebuffer === buffer) return;\n    this.state.framebuffer = buffer;\n    this.gl.bindFramebuffer(target, buffer);\n  }\n\n  getExtension(extension, webgl2Func, extFunc) {\n    // if webgl2 function supported, return func bound to gl context\n    if (webgl2Func && this.gl[webgl2Func]) return this.gl[webgl2Func].bind(this.gl); // fetch extension once only\n\n    if (!this.extensions[extension]) {\n      this.extensions[extension] = this.gl.getExtension(extension);\n    } // return extension if no function requested\n\n\n    if (!webgl2Func) return this.extensions[extension]; // Return null if extension not supported\n\n    if (!this.extensions[extension]) return null; // return extension function, bound to extension\n\n    return this.extensions[extension][extFunc].bind(this.extensions[extension]);\n  }\n\n  sortOpaque(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    } else if (a.program.id !== b.program.id) {\n      return a.program.id - b.program.id;\n    } else if (a.zDepth !== b.zDepth) {\n      return a.zDepth - b.zDepth;\n    } else {\n      return b.id - a.id;\n    }\n  }\n\n  sortTransparent(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    }\n\n    if (a.zDepth !== b.zDepth) {\n      return b.zDepth - a.zDepth;\n    } else {\n      return b.id - a.id;\n    }\n  }\n\n  sortUI(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    } else if (a.program.id !== b.program.id) {\n      return a.program.id - b.program.id;\n    } else {\n      return b.id - a.id;\n    }\n  }\n\n  getRenderList({\n    scene,\n    camera,\n    frustumCull,\n    sort\n  }) {\n    let renderList = [];\n    if (camera && frustumCull) camera.updateFrustum(); // Get visible\n\n    scene.traverse(node => {\n      if (!node.visible) return true;\n      if (!node.draw) return;\n\n      if (frustumCull && node.frustumCulled && camera) {\n        if (!camera.frustumIntersectsMesh(node)) return;\n      }\n\n      renderList.push(node);\n    });\n\n    if (sort) {\n      const opaque = [];\n      const transparent = []; // depthTest true\n\n      const ui = []; // depthTest false\n\n      renderList.forEach(node => {\n        // Split into the 3 render groups\n        if (!node.program.transparent) {\n          opaque.push(node);\n        } else if (node.program.depthTest) {\n          transparent.push(node);\n        } else {\n          ui.push(node);\n        }\n\n        node.zDepth = 0; // Only calculate z-depth if renderOrder unset and depthTest is true\n\n        if (node.renderOrder !== 0 || !node.program.depthTest || !camera) return; // update z-depth\n\n        node.worldMatrix.getTranslation(Renderer_tempVec3);\n        Renderer_tempVec3.applyMatrix4(camera.projectionViewMatrix);\n        node.zDepth = Renderer_tempVec3.z;\n      });\n      opaque.sort(this.sortOpaque);\n      transparent.sort(this.sortTransparent);\n      ui.sort(this.sortUI);\n      renderList = opaque.concat(transparent, ui);\n    }\n\n    return renderList;\n  }\n\n  render({\n    scene,\n    camera,\n    target = null,\n    update = true,\n    sort = true,\n    frustumCull = true,\n    clear\n  }) {\n    if (target === null) {\n      // make sure no render target bound so draws to canvas\n      this.bindFramebuffer();\n      this.setViewport(this.width * this.dpr, this.height * this.dpr);\n    } else {\n      // bind supplied render target and update viewport\n      this.bindFramebuffer(target);\n      this.setViewport(target.width, target.height);\n    }\n\n    if (clear || this.autoClear && clear !== false) {\n      // Ensure depth buffer writing is enabled so it can be cleared\n      if (this.depth && (!target || target.depth)) {\n        this.enable(this.gl.DEPTH_TEST);\n        this.setDepthMask(true);\n      }\n\n      this.gl.clear((this.color ? this.gl.COLOR_BUFFER_BIT : 0) | (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0));\n    } // updates all scene graph matrices\n\n\n    if (update) scene.updateMatrixWorld(); // Update camera separately, in case not in scene graph\n\n    if (camera) camera.updateMatrixWorld(); // Get render list - entails culling and sorting\n\n    const renderList = this.getRenderList({\n      scene,\n      camera,\n      frustumCull,\n      sort\n    });\n    renderList.forEach(node => {\n      node.draw({\n        camera\n      });\n    });\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/Vec4Func.js\nconst Vec4Func_EPSILON = 0.000001;\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\n\nfunction Vec4Func_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\n\nfunction Vec4Func_set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\n\nfunction Vec4Func_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\n\nfunction Vec4Func_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction Vec4Func_length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\n\nfunction Vec4Func_normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  let len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction Vec4Func_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\n\nfunction Vec4Func_lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  let aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/QuatFunc.js\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\n\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  let s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\n * Multiplies two quats\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\n\nfunction QuatFunc_multiply(out, a, b) {\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\n\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  let bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  let omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > 0.000001) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\n\nfunction invert(out, a) {\n  let a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  let invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\n\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  let fTrace = m[0] + m[4] + m[8];\n  let fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    let i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    let j = (i + 1) % 3;\n    let k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} euler Angles to rotate around each axis in degrees.\n * @param {String} order detailing order of operations. Default 'XYZ'.\n * @returns {quat} out\n * @function\n */\n\nfunction fromEuler(out, euler, order = 'YXZ') {\n  let sx = Math.sin(euler[0] * 0.5);\n  let cx = Math.cos(euler[0] * 0.5);\n  let sy = Math.sin(euler[1] * 0.5);\n  let cy = Math.cos(euler[1] * 0.5);\n  let sz = Math.sin(euler[2] * 0.5);\n  let cz = Math.cos(euler[2] * 0.5);\n\n  if (order === 'XYZ') {\n    out[0] = sx * cy * cz + cx * sy * sz;\n    out[1] = cx * sy * cz - sx * cy * sz;\n    out[2] = cx * cy * sz + sx * sy * cz;\n    out[3] = cx * cy * cz - sx * sy * sz;\n  } else if (order === 'YXZ') {\n    out[0] = sx * cy * cz + cx * sy * sz;\n    out[1] = cx * sy * cz - sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n  } else if (order === 'ZXY') {\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz + sx * sy * cz;\n    out[3] = cx * cy * cz - sx * sy * sz;\n  } else if (order === 'ZYX') {\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n  } else if (order === 'YZX') {\n    out[0] = sx * cy * cz + cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz - sx * sy * sz;\n  } else if (order === 'XZY') {\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz - sx * cy * sz;\n    out[2] = cx * cy * sz + sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n  }\n\n  return out;\n}\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\n\nconst QuatFunc_copy = Vec4Func_copy;\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\n\nconst QuatFunc_set = Vec4Func_set;\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\n\nconst QuatFunc_add = Vec4Func_add;\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\n\nconst QuatFunc_scale = Vec4Func_scale;\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\n\nconst QuatFunc_dot = Vec4Func_dot;\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\n\nconst QuatFunc_lerp = Vec4Func_lerp;\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nconst QuatFunc_length = Vec4Func_length;\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\n\nconst QuatFunc_normalize = Vec4Func_normalize;\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Quat.js\n\nclass Quat_Quat extends Array {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    super(x, y, z, w);\n\n    this.onChange = () => {};\n\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set x(v) {\n    this[0] = v;\n    this.onChange();\n  }\n\n  set y(v) {\n    this[1] = v;\n    this.onChange();\n  }\n\n  set z(v) {\n    this[2] = v;\n    this.onChange();\n  }\n\n  set w(v) {\n    this[3] = v;\n    this.onChange();\n  }\n\n  identity() {\n    identity(this);\n    this.onChange();\n    return this;\n  }\n\n  set(x, y, z, w) {\n    if (x.length) return this.copy(x);\n    QuatFunc_set(this, x, y, z, w);\n    this.onChange();\n    return this;\n  }\n\n  rotateX(a) {\n    rotateX(this, this, a);\n    this.onChange();\n    return this;\n  }\n\n  rotateY(a) {\n    rotateY(this, this, a);\n    this.onChange();\n    return this;\n  }\n\n  rotateZ(a) {\n    rotateZ(this, this, a);\n    this.onChange();\n    return this;\n  }\n\n  inverse(q = this) {\n    invert(this, q);\n    this.onChange();\n    return this;\n  }\n\n  conjugate(q = this) {\n    conjugate(this, q);\n    this.onChange();\n    return this;\n  }\n\n  copy(q) {\n    QuatFunc_copy(this, q);\n    this.onChange();\n    return this;\n  }\n\n  normalize(q = this) {\n    QuatFunc_normalize(this, q);\n    this.onChange();\n    return this;\n  }\n\n  multiply(qA, qB) {\n    if (qB) {\n      QuatFunc_multiply(this, qA, qB);\n    } else {\n      QuatFunc_multiply(this, this, qA);\n    }\n\n    this.onChange();\n    return this;\n  }\n\n  dot(v) {\n    return QuatFunc_dot(this, v);\n  }\n\n  fromMatrix3(matrix3) {\n    fromMat3(this, matrix3);\n    this.onChange();\n    return this;\n  }\n\n  fromEuler(euler) {\n    fromEuler(this, euler, euler.order);\n    return this;\n  }\n\n  fromAxisAngle(axis, a) {\n    setAxisAngle(this, axis, a);\n    return this;\n  }\n\n  slerp(q, t) {\n    slerp(this, this, q, t);\n    return this;\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    this[2] = a[o + 2];\n    this[3] = a[o + 3];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    a[o + 2] = this[2];\n    a[o + 3] = this[3];\n    return a;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/Mat4Func.js\nconst Mat4Func_EPSILON = 0.000001;\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction Mat4Func_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction Mat4Func_set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction Mat4Func_identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a12 = a[6],\n        a13 = a[7];\n    let a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction Mat4Func_invert(out, a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction Mat4Func_multiply(out, a, b) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  let b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  let x = v[0],\n      y = v[1],\n      z = v[2];\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction Mat4Func_scale(out, a, v) {\n  let x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  let x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  let len = Math.hypot(x, y, z);\n  let s, c, t;\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n  let b00, b01, b02;\n  let b10, b11, b12;\n  let b20, b21, b22;\n\n  if (Math.abs(len) < Mat4Func_EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\nfunction getMaxScaleOnAxis(mat) {\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n  const x = m11 * m11 + m12 * m12 + m13 * m13;\n  const y = m21 * m21 + m22 * m22 + m23 * m23;\n  const z = m31 * m31 + m32 * m32 + m33 * m33;\n  return Math.sqrt(Math.max(x, y, z));\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nconst getRotation = function () {\n  const temp = [0, 0, 0];\n  return function (out, mat) {\n    let scaling = temp;\n    getScaling(scaling, mat);\n    let is1 = 1 / scaling[0];\n    let is2 = 1 / scaling[1];\n    let is3 = 1 / scaling[2];\n    let sm11 = mat[0] * is1;\n    let sm12 = mat[1] * is2;\n    let sm13 = mat[2] * is3;\n    let sm21 = mat[4] * is1;\n    let sm22 = mat[5] * is2;\n    let sm23 = mat[6] * is3;\n    let sm31 = mat[8] * is1;\n    let sm32 = mat[9] * is2;\n    let sm33 = mat[10] * is3;\n    let trace = sm11 + sm22 + sm33;\n    let S = 0;\n\n    if (trace > 0) {\n      S = Math.sqrt(trace + 1.0) * 2;\n      out[3] = 0.25 * S;\n      out[0] = (sm23 - sm32) / S;\n      out[1] = (sm31 - sm13) / S;\n      out[2] = (sm12 - sm21) / S;\n    } else if (sm11 > sm22 && sm11 > sm33) {\n      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n      out[3] = (sm23 - sm32) / S;\n      out[0] = 0.25 * S;\n      out[1] = (sm12 + sm21) / S;\n      out[2] = (sm31 + sm13) / S;\n    } else if (sm22 > sm33) {\n      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n      out[3] = (sm31 - sm13) / S;\n      out[0] = (sm12 + sm21) / S;\n      out[1] = 0.25 * S;\n      out[2] = (sm23 + sm32) / S;\n    } else {\n      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n      out[3] = (sm12 - sm21) / S;\n      out[0] = (sm31 + sm13) / S;\n      out[1] = (sm23 + sm32) / S;\n      out[2] = 0.25 * S;\n    }\n\n    return out;\n  };\n}();\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  let x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  let x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspective(out, fovy, aspect, near, far) {\n  let f = 1.0 / Math.tan(fovy / 2);\n  let nf = 1 / (near - far);\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 2 * far * near * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n  let lr = 1 / (left - right);\n  let bt = 1 / (bottom - top);\n  let nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} target Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  let eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  let z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  let len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len === 0) {\n    // eye and target are in the same position\n    z2 = 1;\n  } else {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  let x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len === 0) {\n    // up and z are parallel\n    if (upz) {\n      upx += 1e-6;\n    } else if (upy) {\n      upz += 1e-6;\n    } else {\n      upy += 1e-6;\n    }\n\n    x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;\n    len = x0 * x0 + x1 * x1 + x2 * x2;\n  }\n\n  len = 1 / Math.sqrt(len);\n  x0 *= len;\n  x1 *= len;\n  x2 *= len;\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction Mat4Func_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction Mat4Func_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Mat4.js\n\nclass Mat4_Mat4 extends Array {\n  constructor(m00 = 1, m01 = 0, m02 = 0, m03 = 0, m10 = 0, m11 = 1, m12 = 0, m13 = 0, m20 = 0, m21 = 0, m22 = 1, m23 = 0, m30 = 0, m31 = 0, m32 = 0, m33 = 1) {\n    super(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n    return this;\n  }\n\n  get x() {\n    return this[12];\n  }\n\n  get y() {\n    return this[13];\n  }\n\n  get z() {\n    return this[14];\n  }\n\n  get w() {\n    return this[15];\n  }\n\n  set x(v) {\n    this[12] = v;\n  }\n\n  set y(v) {\n    this[13] = v;\n  }\n\n  set z(v) {\n    this[14] = v;\n  }\n\n  set w(v) {\n    this[15] = v;\n  }\n\n  set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    if (m00.length) return this.copy(m00);\n    Mat4Func_set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n    return this;\n  }\n\n  translate(v, m = this) {\n    translate(this, m, v);\n    return this;\n  }\n\n  rotate(v, axis, m = this) {\n    rotate(this, m, v, axis);\n    return this;\n  }\n\n  scale(v, m = this) {\n    Mat4Func_scale(this, m, typeof v === 'number' ? [v, v, v] : v);\n    return this;\n  }\n\n  multiply(ma, mb) {\n    if (mb) {\n      Mat4Func_multiply(this, ma, mb);\n    } else {\n      Mat4Func_multiply(this, this, ma);\n    }\n\n    return this;\n  }\n\n  identity() {\n    Mat4Func_identity(this);\n    return this;\n  }\n\n  copy(m) {\n    Mat4Func_copy(this, m);\n    return this;\n  }\n\n  fromPerspective({\n    fov,\n    aspect,\n    near,\n    far\n  } = {}) {\n    perspective(this, fov, aspect, near, far);\n    return this;\n  }\n\n  fromOrthogonal({\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far\n  }) {\n    ortho(this, left, right, bottom, top, near, far);\n    return this;\n  }\n\n  fromQuaternion(q) {\n    fromQuat(this, q);\n    return this;\n  }\n\n  setPosition(v) {\n    this.x = v[0];\n    this.y = v[1];\n    this.z = v[2];\n    return this;\n  }\n\n  inverse(m = this) {\n    Mat4Func_invert(this, m);\n    return this;\n  }\n\n  compose(q, pos, scale) {\n    fromRotationTranslationScale(this, q, pos, scale);\n    return this;\n  }\n\n  getRotation(q) {\n    getRotation(q, this);\n    return this;\n  }\n\n  getTranslation(pos) {\n    getTranslation(pos, this);\n    return this;\n  }\n\n  getScaling(scale) {\n    getScaling(scale, this);\n    return this;\n  }\n\n  getMaxScaleOnAxis() {\n    return getMaxScaleOnAxis(this);\n  }\n\n  lookAt(eye, target, up) {\n    targetTo(this, eye, target, up);\n    return this;\n  }\n\n  determinant() {\n    return determinant(this);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/EulerFunc.js\n// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\nfunction fromRotationMatrix(out, m, order = 'YXZ') {\n  if (order === 'XYZ') {\n    out[1] = Math.asin(Math.min(Math.max(m[8], -1), 1));\n\n    if (Math.abs(m[8]) < 0.99999) {\n      out[0] = Math.atan2(-m[9], m[10]);\n      out[2] = Math.atan2(-m[4], m[0]);\n    } else {\n      out[0] = Math.atan2(m[6], m[5]);\n      out[2] = 0;\n    }\n  } else if (order === 'YXZ') {\n    out[0] = Math.asin(-Math.min(Math.max(m[9], -1), 1));\n\n    if (Math.abs(m[9]) < 0.99999) {\n      out[1] = Math.atan2(m[8], m[10]);\n      out[2] = Math.atan2(m[1], m[5]);\n    } else {\n      out[1] = Math.atan2(-m[2], m[0]);\n      out[2] = 0;\n    }\n  } else if (order === 'ZXY') {\n    out[0] = Math.asin(Math.min(Math.max(m[6], -1), 1));\n\n    if (Math.abs(m[6]) < 0.99999) {\n      out[1] = Math.atan2(-m[2], m[10]);\n      out[2] = Math.atan2(-m[4], m[5]);\n    } else {\n      out[1] = 0;\n      out[2] = Math.atan2(m[1], m[0]);\n    }\n  } else if (order === 'ZYX') {\n    out[1] = Math.asin(-Math.min(Math.max(m[2], -1), 1));\n\n    if (Math.abs(m[2]) < 0.99999) {\n      out[0] = Math.atan2(m[6], m[10]);\n      out[2] = Math.atan2(m[1], m[0]);\n    } else {\n      out[0] = 0;\n      out[2] = Math.atan2(-m[4], m[5]);\n    }\n  } else if (order === 'YZX') {\n    out[2] = Math.asin(Math.min(Math.max(m[1], -1), 1));\n\n    if (Math.abs(m[1]) < 0.99999) {\n      out[0] = Math.atan2(-m[9], m[5]);\n      out[1] = Math.atan2(-m[2], m[0]);\n    } else {\n      out[0] = 0;\n      out[1] = Math.atan2(m[8], m[10]);\n    }\n  } else if (order === 'XZY') {\n    out[2] = Math.asin(-Math.min(Math.max(m[4], -1), 1));\n\n    if (Math.abs(m[4]) < 0.99999) {\n      out[0] = Math.atan2(m[6], m[5]);\n      out[1] = Math.atan2(m[8], m[0]);\n    } else {\n      out[0] = Math.atan2(-m[9], m[10]);\n      out[1] = 0;\n    }\n  }\n\n  return out;\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Euler.js\n\n\nconst tmpMat4 = new Mat4_Mat4();\nclass Euler_Euler extends Array {\n  constructor(x = 0, y = x, z = x, order = 'YXZ') {\n    super(x, y, z);\n    this.order = order;\n\n    this.onChange = () => {};\n\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set x(v) {\n    this[0] = v;\n    this.onChange();\n  }\n\n  set y(v) {\n    this[1] = v;\n    this.onChange();\n  }\n\n  set z(v) {\n    this[2] = v;\n    this.onChange();\n  }\n\n  set(x, y = x, z = x) {\n    if (x.length) return this.copy(x);\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this.onChange();\n    return this;\n  }\n\n  copy(v) {\n    this[0] = v[0];\n    this[1] = v[1];\n    this[2] = v[2];\n    this.onChange();\n    return this;\n  }\n\n  reorder(order) {\n    this.order = order;\n    this.onChange();\n    return this;\n  }\n\n  fromRotationMatrix(m, order = this.order) {\n    fromRotationMatrix(this, m, order);\n    return this;\n  }\n\n  fromQuaternion(q, order = this.order) {\n    tmpMat4.fromQuaternion(q);\n    return this.fromRotationMatrix(tmpMat4, order);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/Transform.js\n\n\n\n\nclass Transform_Transform {\n  constructor() {\n    this.parent = null;\n    this.children = [];\n    this.visible = true;\n    this.matrix = new Mat4_Mat4();\n    this.worldMatrix = new Mat4_Mat4();\n    this.matrixAutoUpdate = true;\n    this.position = new Vec3_Vec3();\n    this.quaternion = new Quat_Quat();\n    this.scale = new Vec3_Vec3(1);\n    this.rotation = new Euler_Euler();\n    this.up = new Vec3_Vec3(0, 1, 0);\n\n    this.rotation.onChange = () => this.quaternion.fromEuler(this.rotation);\n\n    this.quaternion.onChange = () => this.rotation.fromQuaternion(this.quaternion);\n  }\n\n  setParent(parent, notifyParent = true) {\n    if (notifyParent && this.parent && parent !== this.parent) this.parent.removeChild(this, false);\n    this.parent = parent;\n    if (notifyParent && parent) parent.addChild(this, false);\n  }\n\n  addChild(child, notifyChild = true) {\n    if (!~this.children.indexOf(child)) this.children.push(child);\n    if (notifyChild) child.setParent(this, false);\n  }\n\n  removeChild(child, notifyChild = true) {\n    if (!!~this.children.indexOf(child)) this.children.splice(this.children.indexOf(child), 1);\n    if (notifyChild) child.setParent(null, false);\n  }\n\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.worldMatrixNeedsUpdate || force) {\n      if (this.parent === null) this.worldMatrix.copy(this.matrix);else this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix);\n      this.worldMatrixNeedsUpdate = false;\n      force = true;\n    }\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].updateMatrixWorld(force);\n    }\n  }\n\n  updateMatrix() {\n    this.matrix.compose(this.quaternion, this.position, this.scale);\n    this.worldMatrixNeedsUpdate = true;\n  }\n\n  traverse(callback) {\n    // Return true in callback to stop traversing children\n    if (callback(this)) return;\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].traverse(callback);\n    }\n  }\n\n  decompose() {\n    this.matrix.getTranslation(this.position);\n    this.matrix.getRotation(this.quaternion);\n    this.matrix.getScaling(this.scale);\n    this.rotation.fromQuaternion(this.quaternion);\n  }\n\n  lookAt(target, invert = false) {\n    if (invert) this.matrix.lookAt(this.position, target, this.up);else this.matrix.lookAt(target, this.position, this.up);\n    this.matrix.getRotation(this.quaternion);\n    this.rotation.fromQuaternion(this.quaternion);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/Camera.js\n\n\n\nconst tempMat4 = new Mat4_Mat4();\nconst tempVec3a = new Vec3_Vec3();\nconst tempVec3b = new Vec3_Vec3();\nclass Camera_Camera extends Transform_Transform {\n  constructor(gl, {\n    near = 0.1,\n    far = 100,\n    fov = 45,\n    aspect = 1,\n    left,\n    right,\n    bottom,\n    top,\n    zoom = 1\n  } = {}) {\n    super();\n    Object.assign(this, {\n      near,\n      far,\n      fov,\n      aspect,\n      left,\n      right,\n      bottom,\n      top,\n      zoom\n    });\n    this.projectionMatrix = new Mat4_Mat4();\n    this.viewMatrix = new Mat4_Mat4();\n    this.projectionViewMatrix = new Mat4_Mat4();\n    this.worldPosition = new Vec3_Vec3(); // Use orthographic if left/right set, else default to perspective camera\n\n    this.type = left || right ? 'orthographic' : 'perspective';\n    if (this.type === 'orthographic') this.orthographic();else this.perspective();\n  }\n\n  perspective({\n    near = this.near,\n    far = this.far,\n    fov = this.fov,\n    aspect = this.aspect\n  } = {}) {\n    Object.assign(this, {\n      near,\n      far,\n      fov,\n      aspect\n    });\n    this.projectionMatrix.fromPerspective({\n      fov: fov * (Math.PI / 180),\n      aspect,\n      near,\n      far\n    });\n    this.type = 'perspective';\n    return this;\n  }\n\n  orthographic({\n    near = this.near,\n    far = this.far,\n    left = this.left,\n    right = this.right,\n    bottom = this.bottom,\n    top = this.top,\n    zoom = this.zoom\n  } = {}) {\n    Object.assign(this, {\n      near,\n      far,\n      left,\n      right,\n      bottom,\n      top,\n      zoom\n    });\n    left /= zoom;\n    right /= zoom;\n    bottom /= zoom;\n    top /= zoom;\n    this.projectionMatrix.fromOrthogonal({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far\n    });\n    this.type = 'orthographic';\n    return this;\n  }\n\n  updateMatrixWorld() {\n    super.updateMatrixWorld();\n    this.viewMatrix.inverse(this.worldMatrix);\n    this.worldMatrix.getTranslation(this.worldPosition); // used for sorting\n\n    this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);\n    return this;\n  }\n\n  lookAt(target) {\n    super.lookAt(target, true);\n    return this;\n  } // Project 3D coordinate to 2D point\n\n\n  project(v) {\n    v.applyMatrix4(this.viewMatrix);\n    v.applyMatrix4(this.projectionMatrix);\n    return this;\n  } // Unproject 2D point to 3D coordinate\n\n\n  unproject(v) {\n    v.applyMatrix4(tempMat4.inverse(this.projectionMatrix));\n    v.applyMatrix4(this.worldMatrix);\n    return this;\n  }\n\n  updateFrustum() {\n    if (!this.frustum) {\n      this.frustum = [new Vec3_Vec3(), new Vec3_Vec3(), new Vec3_Vec3(), new Vec3_Vec3(), new Vec3_Vec3(), new Vec3_Vec3()];\n    }\n\n    const m = this.projectionViewMatrix;\n    this.frustum[0].set(m[3] - m[0], m[7] - m[4], m[11] - m[8]).constant = m[15] - m[12]; // -x\n\n    this.frustum[1].set(m[3] + m[0], m[7] + m[4], m[11] + m[8]).constant = m[15] + m[12]; // +x\n\n    this.frustum[2].set(m[3] + m[1], m[7] + m[5], m[11] + m[9]).constant = m[15] + m[13]; // +y\n\n    this.frustum[3].set(m[3] - m[1], m[7] - m[5], m[11] - m[9]).constant = m[15] - m[13]; // -y\n\n    this.frustum[4].set(m[3] - m[2], m[7] - m[6], m[11] - m[10]).constant = m[15] - m[14]; // +z (far)\n\n    this.frustum[5].set(m[3] + m[2], m[7] + m[6], m[11] + m[10]).constant = m[15] + m[14]; // -z (near)\n\n    for (let i = 0; i < 6; i++) {\n      const invLen = 1.0 / this.frustum[i].distance();\n      this.frustum[i].multiply(invLen);\n      this.frustum[i].constant *= invLen;\n    }\n  }\n\n  frustumIntersectsMesh(node) {\n    // If no position attribute, treat as frustumCulled false\n    if (!node.geometry.attributes.position) return true;\n    if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity) node.geometry.computeBoundingSphere();\n    if (!node.geometry.bounds) return true;\n    const center = tempVec3a;\n    center.copy(node.geometry.bounds.center);\n    center.applyMatrix4(node.worldMatrix);\n    const radius = node.geometry.bounds.radius * node.worldMatrix.getMaxScaleOnAxis();\n    return this.frustumIntersectsSphere(center, radius);\n  }\n\n  frustumIntersectsSphere(center, radius) {\n    const normal = tempVec3b;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = this.frustum[i];\n      const distance = normal.copy(plane).dot(center) + plane.constant;\n      if (distance < -radius) return false;\n    }\n\n    return true;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/Mat3Func.js\nconst Mat3Func_EPSILON = 0.000001;\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\n\nfunction Mat3Func_fromQuat(out, q) {\n  let x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction Mat3Func_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nfunction Mat3Func_set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\n\nfunction Mat3Func_identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction Mat3Func_transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\n\nfunction Mat3Func_invert(out, a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  let a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  let a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  let b01 = a22 * a11 - a12 * a21;\n  let b11 = -a22 * a10 + a12 * a20;\n  let b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction Mat3Func_determinant(a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  let a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  let a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction Mat3Func_multiply(out, a, b) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  let a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  let a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  let b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  let b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  let b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\n\nfunction Mat3Func_translate(out, a, v) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\n\nfunction Mat3Func_rotate(out, a, rad) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\n\nfunction Mat3Func_scale(out, a, v) {\n  let x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\n\nfunction normalFromMat4(out, a) {\n  let a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  let a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  let a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  let a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\n\nfunction projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction Mat3Func_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\n\nfunction Mat3Func_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\n\nfunction Mat3Func_multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Mat3.js\n\nclass Mat3_Mat3 extends Array {\n  constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {\n    super(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n    return this;\n  }\n\n  set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    if (m00.length) return this.copy(m00);\n    Mat3Func_set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);\n    return this;\n  }\n\n  translate(v, m = this) {\n    Mat3Func_translate(this, m, v);\n    return this;\n  }\n\n  rotate(v, m = this) {\n    Mat3Func_rotate(this, m, v);\n    return this;\n  }\n\n  scale(v, m = this) {\n    Mat3Func_scale(this, m, v);\n    return this;\n  }\n\n  multiply(ma, mb) {\n    if (mb) {\n      Mat3Func_multiply(this, ma, mb);\n    } else {\n      Mat3Func_multiply(this, this, ma);\n    }\n\n    return this;\n  }\n\n  identity() {\n    Mat3Func_identity(this);\n    return this;\n  }\n\n  copy(m) {\n    Mat3Func_copy(this, m);\n    return this;\n  }\n\n  fromMatrix4(m) {\n    fromMat4(this, m);\n    return this;\n  }\n\n  fromQuaternion(q) {\n    Mat3Func_fromQuat(this, q);\n    return this;\n  }\n\n  fromBasis(vec3a, vec3b, vec3c) {\n    this.set(vec3a[0], vec3a[1], vec3a[2], vec3b[0], vec3b[1], vec3b[2], vec3c[0], vec3c[1], vec3c[2]);\n    return this;\n  }\n\n  inverse(m = this) {\n    Mat3Func_invert(this, m);\n    return this;\n  }\n\n  getNormalMatrix(m) {\n    normalFromMat4(this, m);\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/Mesh.js\n\n\n\nlet Mesh_ID = 0;\nclass Mesh_Mesh extends Transform_Transform {\n  constructor(gl, {\n    geometry,\n    program,\n    mode = gl.TRIANGLES,\n    frustumCulled = true,\n    renderOrder = 0\n  } = {}) {\n    super();\n    if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n    this.gl = gl;\n    this.id = Mesh_ID++;\n    this.geometry = geometry;\n    this.program = program;\n    this.mode = mode; // Used to skip frustum culling\n\n    this.frustumCulled = frustumCulled; // Override sorting to force an order\n\n    this.renderOrder = renderOrder;\n    this.modelViewMatrix = new Mat4_Mat4();\n    this.normalMatrix = new Mat3_Mat3();\n    this.beforeRenderCallbacks = [];\n    this.afterRenderCallbacks = [];\n  }\n\n  onBeforeRender(f) {\n    this.beforeRenderCallbacks.push(f);\n    return this;\n  }\n\n  onAfterRender(f) {\n    this.afterRenderCallbacks.push(f);\n    return this;\n  }\n\n  draw({\n    camera\n  } = {}) {\n    this.beforeRenderCallbacks.forEach(f => f && f({\n      mesh: this,\n      camera\n    }));\n\n    if (camera) {\n      // Add empty matrix uniforms to program if unset\n      if (!this.program.uniforms.modelMatrix) {\n        Object.assign(this.program.uniforms, {\n          modelMatrix: {\n            value: null\n          },\n          viewMatrix: {\n            value: null\n          },\n          modelViewMatrix: {\n            value: null\n          },\n          normalMatrix: {\n            value: null\n          },\n          projectionMatrix: {\n            value: null\n          },\n          cameraPosition: {\n            value: null\n          }\n        });\n      } // Set the matrix uniforms\n\n\n      this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n      this.program.uniforms.cameraPosition.value = camera.worldPosition;\n      this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n      this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n      this.program.uniforms.modelMatrix.value = this.worldMatrix;\n      this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n      this.program.uniforms.normalMatrix.value = this.normalMatrix;\n    } // determine if faces need to be flipped - when mesh scaled negatively\n\n\n    let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n    this.program.use({\n      flipFaces\n    });\n    this.geometry.draw({\n      mode: this.mode,\n      program: this.program\n    });\n    this.afterRenderCallbacks.forEach(f => f && f({\n      mesh: this,\n      camera\n    }));\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/Texture.js\n// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n  return (value & value - 1) === 0;\n}\n\nlet Texture_ID = 1;\nclass Texture {\n  constructor(gl, {\n    image,\n    target = gl.TEXTURE_2D,\n    type = gl.UNSIGNED_BYTE,\n    format = gl.RGBA,\n    internalFormat = format,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    generateMipmaps = true,\n    minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n    magFilter = gl.LINEAR,\n    premultiplyAlpha = false,\n    unpackAlignment = 4,\n    flipY = target == gl.TEXTURE_2D ? true : false,\n    anisotropy = 0,\n    level = 0,\n    width,\n    // used for RenderTargets or Data Textures\n    height = width\n  } = {}) {\n    this.gl = gl;\n    this.id = Texture_ID++;\n    this.image = image;\n    this.target = target;\n    this.type = type;\n    this.format = format;\n    this.internalFormat = internalFormat;\n    this.minFilter = minFilter;\n    this.magFilter = magFilter;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.generateMipmaps = generateMipmaps;\n    this.premultiplyAlpha = premultiplyAlpha;\n    this.unpackAlignment = unpackAlignment;\n    this.flipY = flipY;\n    this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n    this.level = level;\n    this.width = width;\n    this.height = height;\n    this.texture = this.gl.createTexture();\n    this.store = {\n      image: null\n    }; // Alias for state store to avoid redundant calls for global state\n\n    this.glState = this.gl.renderer.state; // State store to avoid redundant calls for per-texture state\n\n    this.state = {};\n    this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n    this.state.magFilter = this.gl.LINEAR;\n    this.state.wrapS = this.gl.REPEAT;\n    this.state.wrapT = this.gl.REPEAT;\n    this.state.anisotropy = 0;\n  }\n\n  bind() {\n    // Already bound to active texture unit\n    if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n    this.gl.bindTexture(this.target, this.texture);\n    this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n  }\n\n  update(textureUnit = 0) {\n    const needsUpdate = !(this.image === this.store.image && !this.needsUpdate); // Make sure that texture is bound to its texture unit\n\n    if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n      // set active texture unit to perform texture functions\n      this.gl.renderer.activeTexture(textureUnit);\n      this.bind();\n    }\n\n    if (!needsUpdate) return;\n    this.needsUpdate = false;\n\n    if (this.flipY !== this.glState.flipY) {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n      this.glState.flipY = this.flipY;\n    }\n\n    if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n      this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n      this.glState.premultiplyAlpha = this.premultiplyAlpha;\n    }\n\n    if (this.unpackAlignment !== this.glState.unpackAlignment) {\n      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n      this.glState.unpackAlignment = this.unpackAlignment;\n    }\n\n    if (this.minFilter !== this.state.minFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n      this.state.minFilter = this.minFilter;\n    }\n\n    if (this.magFilter !== this.state.magFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n      this.state.magFilter = this.magFilter;\n    }\n\n    if (this.wrapS !== this.state.wrapS) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n      this.state.wrapS = this.wrapS;\n    }\n\n    if (this.wrapT !== this.state.wrapT) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n      this.state.wrapT = this.wrapT;\n    }\n\n    if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n      this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n      this.state.anisotropy = this.anisotropy;\n    }\n\n    if (this.image) {\n      if (this.image.width) {\n        this.width = this.image.width;\n        this.height = this.image.height;\n      }\n\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // For cube maps\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n        }\n      } else if (ArrayBuffer.isView(this.image)) {\n        // Data texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n      } else if (this.image.isCompressedTexture) {\n        // Compressed texture\n        for (let level = 0; level < this.image.length; level++) {\n          this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n        }\n      } else {\n        // Regular texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n      }\n\n      if (this.generateMipmaps) {\n        // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n        if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n          this.generateMipmaps = false;\n          this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n          this.minFilter = this.gl.LINEAR;\n        } else {\n          this.gl.generateMipmap(this.target);\n        }\n      } // Callback for when data is pushed to GPU\n\n\n      this.onUpdate && this.onUpdate();\n    } else {\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // Upload empty pixel for each side while no image to avoid errors while image or video loading\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n        }\n      } else if (this.width) {\n        // image intentionally left null for RenderTarget\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n      } else {\n        // Upload empty pixel if no image to avoid errors while image or video loading\n        this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n      }\n    }\n\n    this.store.image = this.image;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/core/RenderTarget.js\n// TODO: multi target rendering\n// TODO: test stencil and depth\n// TODO: destroy\n// TODO: blit on resize?\n\nclass RenderTarget_RenderTarget {\n  constructor(gl, {\n    width = gl.canvas.width,\n    height = gl.canvas.height,\n    target = gl.FRAMEBUFFER,\n    color = 1,\n    // number of color attachments\n    depth = true,\n    stencil = false,\n    depthTexture = false,\n    // note - stencil breaks\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    minFilter = gl.LINEAR,\n    magFilter = minFilter,\n    type = gl.UNSIGNED_BYTE,\n    format = gl.RGBA,\n    internalFormat = format,\n    unpackAlignment,\n    premultiplyAlpha\n  } = {}) {\n    this.gl = gl;\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.buffer = this.gl.createFramebuffer();\n    this.target = target;\n    this.gl.bindFramebuffer(this.target, this.buffer);\n    this.textures = [];\n    const drawBuffers = []; // create and attach required num of color textures\n\n    for (let i = 0; i < color; i++) {\n      this.textures.push(new Texture(gl, {\n        width,\n        height,\n        wrapS,\n        wrapT,\n        minFilter,\n        magFilter,\n        type,\n        format,\n        internalFormat,\n        unpackAlignment,\n        premultiplyAlpha,\n        flipY: false,\n        generateMipmaps: false\n      }));\n      this.textures[i].update();\n      this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.textures[i].texture, 0\n      /* level */\n      );\n      drawBuffers.push(this.gl.COLOR_ATTACHMENT0 + i);\n    } // For multi-render targets shader access\n\n\n    if (drawBuffers.length > 1) this.gl.renderer.drawBuffers(drawBuffers); // alias for majority of use cases\n\n    this.texture = this.textures[0]; // note depth textures break stencil - so can't use together\n\n    if (depthTexture && (this.gl.renderer.isWebgl2 || this.gl.renderer.getExtension('WEBGL_depth_texture'))) {\n      this.depthTexture = new Texture(gl, {\n        width,\n        height,\n        minFilter: this.gl.NEAREST,\n        magFilter: this.gl.NEAREST,\n        format: this.gl.DEPTH_COMPONENT,\n        internalFormat: gl.renderer.isWebgl2 ? this.gl.DEPTH_COMPONENT16 : this.gl.DEPTH_COMPONENT,\n        type: this.gl.UNSIGNED_INT\n      });\n      this.depthTexture.update();\n      this.gl.framebufferTexture2D(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0\n      /* level */\n      );\n    } else {\n      // Render buffers\n      if (depth && !stencil) {\n        this.depthBuffer = this.gl.createRenderbuffer();\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer);\n        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);\n        this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthBuffer);\n      }\n\n      if (stencil && !depth) {\n        this.stencilBuffer = this.gl.createRenderbuffer();\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer);\n        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, width, height);\n        this.gl.framebufferRenderbuffer(this.target, this.gl.STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.stencilBuffer);\n      }\n\n      if (depth && stencil) {\n        this.depthStencilBuffer = this.gl.createRenderbuffer();\n        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer);\n        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, width, height);\n        this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.depthStencilBuffer);\n      }\n    }\n\n    this.gl.bindFramebuffer(this.target, null);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/ColorFunc.js\nconst NAMES = {\n  black: '#000000',\n  white: '#ffffff',\n  red: '#ff0000',\n  green: '#00ff00',\n  blue: '#0000ff',\n  fuchsia: '#ff00ff',\n  cyan: '#00ffff',\n  yellow: '#ffff00',\n  orange: '#ff8000'\n};\nfunction hexToRGB(hex) {\n  if (hex.length === 4) hex = hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n  const rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  if (!rgb) console.warn(`Unable to convert hex string ${hex} to rgb values`);\n  return [parseInt(rgb[1], 16) / 255, parseInt(rgb[2], 16) / 255, parseInt(rgb[3], 16) / 255];\n}\nfunction numberToRGB(num) {\n  num = parseInt(num);\n  return [(num >> 16 & 255) / 255, (num >> 8 & 255) / 255, (num & 255) / 255];\n}\nfunction parseColor(color) {\n  // Empty\n  if (color === undefined) return [0, 0, 0]; // Decimal\n\n  if (arguments.length === 3) return arguments; // Number\n\n  if (!isNaN(color)) return numberToRGB(color); // Hex\n\n  if (color[0] === '#') return hexToRGB(color); // Names\n\n  if (NAMES[color.toLowerCase()]) return hexToRGB(NAMES[color.toLowerCase()]);\n  console.warn('Color format not recognised');\n  return [0, 0, 0];\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Color.js\n // Color stored as an array of RGB decimal values (between 0 > 1)\n// Constructor and set method accept following formats:\n// new Color() - Empty (defaults to black)\n// new Color([0.2, 0.4, 1.0]) - Decimal Array (or another Color instance)\n// new Color(0.7, 0.0, 0.1) - Decimal RGB values\n// new Color('#ff0000') - Hex string\n// new Color('#ccc') - Short-hand Hex string\n// new Color(0x4f27e8) - Number\n// new Color('red') - Color name string (short list in ColorFunc.js)\n\nclass Color_Color extends Array {\n  constructor(color) {\n    if (Array.isArray(color)) return super(...color);\n    return super(...parseColor(...arguments));\n  }\n\n  get r() {\n    return this[0];\n  }\n\n  get g() {\n    return this[1];\n  }\n\n  get b() {\n    return this[2];\n  }\n\n  set r(v) {\n    this[0] = v;\n  }\n\n  set g(v) {\n    this[1] = v;\n  }\n\n  set b(v) {\n    this[2] = v;\n  }\n\n  set(color) {\n    if (Array.isArray(color)) return this.copy(color);\n    return this.copy(parseColor(...arguments));\n  }\n\n  copy(v) {\n    this[0] = v[0];\n    this[1] = v[1];\n    this[2] = v[2];\n    return this;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/functions/Vec2Func.js\nconst Vec2Func_EPSILON = 0.000001;\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\n\nfunction Vec2Func_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nfunction Vec2Func_set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction Vec2Func_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction Vec2Func_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction Vec2Func_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\n\nfunction Vec2Func_divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nfunction Vec2Func_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction Vec2Func_distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction Vec2Func_squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction Vec2Func_length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction Vec2Func_squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\n\nfunction Vec2Func_negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\n\nfunction Vec2Func_inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\n\nfunction Vec2Func_normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction Vec2Func_dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product returns a scalar\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} cross product of a and b\n */\n\nfunction Vec2Func_cross(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\n\nfunction Vec2Func_lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction Vec2Func_transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nfunction Vec2Func_transformMat4(out, a, m) {\n  let x = a[0];\n  let y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction Vec2Func_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Vec2.js\n\nclass Vec2_Vec2 extends Array {\n  constructor(x = 0, y = x) {\n    super(x, y);\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set x(v) {\n    this[0] = v;\n  }\n\n  set y(v) {\n    this[1] = v;\n  }\n\n  set(x, y = x) {\n    if (x.length) return this.copy(x);\n    Vec2Func_set(this, x, y);\n    return this;\n  }\n\n  copy(v) {\n    Vec2Func_copy(this, v);\n    return this;\n  }\n\n  add(va, vb) {\n    if (vb) Vec2Func_add(this, va, vb);else Vec2Func_add(this, this, va);\n    return this;\n  }\n\n  sub(va, vb) {\n    if (vb) Vec2Func_subtract(this, va, vb);else Vec2Func_subtract(this, this, va);\n    return this;\n  }\n\n  multiply(v) {\n    if (v.length) Vec2Func_multiply(this, this, v);else Vec2Func_scale(this, this, v);\n    return this;\n  }\n\n  divide(v) {\n    if (v.length) Vec2Func_divide(this, this, v);else Vec2Func_scale(this, this, 1 / v);\n    return this;\n  }\n\n  inverse(v = this) {\n    Vec2Func_inverse(this, v);\n    return this;\n  } // Can't use 'length' as Array.prototype uses it\n\n\n  len() {\n    return Vec2Func_length(this);\n  }\n\n  distance(v) {\n    if (v) return Vec2Func_distance(this, v);else return Vec2Func_length(this);\n  }\n\n  squaredLen() {\n    return this.squaredDistance();\n  }\n\n  squaredDistance(v) {\n    if (v) return Vec2Func_squaredDistance(this, v);else return Vec2Func_squaredLength(this);\n  }\n\n  negate(v = this) {\n    Vec2Func_negate(this, v);\n    return this;\n  }\n\n  cross(va, vb) {\n    if (vb) return Vec2Func_cross(va, vb);\n    return Vec2Func_cross(this, va);\n  }\n\n  scale(v) {\n    Vec2Func_scale(this, this, v);\n    return this;\n  }\n\n  normalize() {\n    Vec2Func_normalize(this, this);\n    return this;\n  }\n\n  dot(v) {\n    return Vec2Func_dot(this, v);\n  }\n\n  equals(v) {\n    return Vec2Func_exactEquals(this, v);\n  }\n\n  applyMatrix3(mat3) {\n    Vec2Func_transformMat3(this, this, mat3);\n    return this;\n  }\n\n  applyMatrix4(mat4) {\n    Vec2Func_transformMat4(this, this, mat4);\n    return this;\n  }\n\n  lerp(v, a) {\n    Vec2Func_lerp(this, this, v, a);\n  }\n\n  clone() {\n    return new Vec2_Vec2(this[0], this[1]);\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    return a;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/math/Vec4.js\n\nclass Vec4_Vec4 extends Array {\n  constructor(x = 0, y = x, z = x, w = x) {\n    super(x, y, z, w);\n    return this;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set x(v) {\n    this[0] = v;\n  }\n\n  set y(v) {\n    this[1] = v;\n  }\n\n  set z(v) {\n    this[2] = v;\n  }\n\n  set w(v) {\n    this[3] = v;\n  }\n\n  set(x, y, z, w) {\n    if (x.length) return this.copy(x);\n    Vec4Func_set(this, x, y, z, w);\n    return this;\n  }\n\n  copy(v) {\n    Vec4Func_copy(this, v);\n    return this;\n  }\n\n  normalize() {\n    Vec4Func_normalize(this, this);\n    return this;\n  }\n\n  fromArray(a, o = 0) {\n    this[0] = a[o];\n    this[1] = a[o + 1];\n    this[2] = a[o + 2];\n    this[3] = a[o + 3];\n    return this;\n  }\n\n  toArray(a = [], o = 0) {\n    a[o] = this[0];\n    a[o + 1] = this[1];\n    a[o + 2] = this[2];\n    a[o + 3] = this[3];\n    return a;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Plane.js\n\nclass Plane_Plane extends Geometry_Geometry {\n  constructor(gl, {\n    width = 1,\n    height = 1,\n    widthSegments = 1,\n    heightSegments = 1,\n    attributes = {}\n  } = {}) {\n    const wSegs = widthSegments;\n    const hSegs = heightSegments; // Determine length of arrays\n\n    const num = (wSegs + 1) * (hSegs + 1);\n    const numIndices = wSegs * hSegs * 6; // Generate empty arrays once\n\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    Plane_Plane.buildPlane(position, normal, uv, index, width, height, 0, wSegs, hSegs);\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n  static buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, u = 0, v = 1, w = 2, uDir = 1, vDir = -1, i = 0, ii = 0) {\n    const io = i;\n    const segW = width / wSegs;\n    const segH = height / hSegs;\n\n    for (let iy = 0; iy <= hSegs; iy++) {\n      let y = iy * segH - height / 2;\n\n      for (let ix = 0; ix <= wSegs; ix++, i++) {\n        let x = ix * segW - width / 2;\n        position[i * 3 + u] = x * uDir;\n        position[i * 3 + v] = y * vDir;\n        position[i * 3 + w] = depth / 2;\n        normal[i * 3 + u] = 0;\n        normal[i * 3 + v] = 0;\n        normal[i * 3 + w] = depth >= 0 ? 1 : -1;\n        uv[i * 2] = ix / wSegs;\n        uv[i * 2 + 1] = 1 - iy / hSegs;\n        if (iy === hSegs || ix === wSegs) continue;\n        let a = io + ix + iy * (wSegs + 1);\n        let b = io + ix + (iy + 1) * (wSegs + 1);\n        let c = io + ix + (iy + 1) * (wSegs + 1) + 1;\n        let d = io + ix + iy * (wSegs + 1) + 1;\n        index[ii * 6] = a;\n        index[ii * 6 + 1] = b;\n        index[ii * 6 + 2] = d;\n        index[ii * 6 + 3] = b;\n        index[ii * 6 + 4] = c;\n        index[ii * 6 + 5] = d;\n        ii++;\n      }\n    }\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Box.js\n\n\nclass Box_Box extends Geometry_Geometry {\n  constructor(gl, {\n    width = 1,\n    height = 1,\n    depth = 1,\n    widthSegments = 1,\n    heightSegments = 1,\n    depthSegments = 1,\n    attributes = {}\n  } = {}) {\n    const wSegs = widthSegments;\n    const hSegs = heightSegments;\n    const dSegs = depthSegments;\n    const num = (wSegs + 1) * (hSegs + 1) * 2 + (wSegs + 1) * (dSegs + 1) * 2 + (hSegs + 1) * (dSegs + 1) * 2;\n    const numIndices = (wSegs * hSegs * 2 + wSegs * dSegs * 2 + hSegs * dSegs * 2) * 6;\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    let i = 0;\n    let ii = 0; // left, right\n\n    Plane_Plane.buildPlane(position, normal, uv, index, depth, height, width, dSegs, hSegs, 2, 1, 0, -1, -1, i, ii);\n    Plane_Plane.buildPlane(position, normal, uv, index, depth, height, -width, dSegs, hSegs, 2, 1, 0, 1, -1, i += (dSegs + 1) * (hSegs + 1), ii += dSegs * hSegs); // top, bottom\n\n    Plane_Plane.buildPlane(position, normal, uv, index, width, depth, height, dSegs, hSegs, 0, 2, 1, 1, 1, i += (dSegs + 1) * (hSegs + 1), ii += dSegs * hSegs);\n    Plane_Plane.buildPlane(position, normal, uv, index, width, depth, -height, dSegs, hSegs, 0, 2, 1, 1, -1, i += (wSegs + 1) * (dSegs + 1), ii += wSegs * dSegs); // front, back\n\n    Plane_Plane.buildPlane(position, normal, uv, index, width, height, -depth, wSegs, hSegs, 0, 1, 2, -1, -1, i += (wSegs + 1) * (dSegs + 1), ii += wSegs * dSegs);\n    Plane_Plane.buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, 0, 1, 2, 1, -1, i += (wSegs + 1) * (hSegs + 1), ii += wSegs * hSegs);\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Sphere.js\n\n\nclass Sphere_Sphere extends Geometry_Geometry {\n  constructor(gl, {\n    radius = 0.5,\n    widthSegments = 16,\n    heightSegments = Math.ceil(widthSegments * 0.5),\n    phiStart = 0,\n    phiLength = Math.PI * 2,\n    thetaStart = 0,\n    thetaLength = Math.PI,\n    attributes = {}\n  } = {}) {\n    const wSegs = widthSegments;\n    const hSegs = heightSegments;\n    const pStart = phiStart;\n    const pLength = phiLength;\n    const tStart = thetaStart;\n    const tLength = thetaLength;\n    const num = (wSegs + 1) * (hSegs + 1);\n    const numIndices = wSegs * hSegs * 6;\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    let i = 0;\n    let iv = 0;\n    let ii = 0;\n    let te = tStart + tLength;\n    const grid = [];\n    let n = new Vec3_Vec3();\n\n    for (let iy = 0; iy <= hSegs; iy++) {\n      let vRow = [];\n      let v = iy / hSegs;\n\n      for (let ix = 0; ix <= wSegs; ix++, i++) {\n        let u = ix / wSegs;\n        let x = -radius * Math.cos(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n        let y = radius * Math.cos(tStart + v * tLength);\n        let z = radius * Math.sin(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n        position[i * 3] = x;\n        position[i * 3 + 1] = y;\n        position[i * 3 + 2] = z;\n        n.set(x, y, z).normalize();\n        normal[i * 3] = n.x;\n        normal[i * 3 + 1] = n.y;\n        normal[i * 3 + 2] = n.z;\n        uv[i * 2] = u;\n        uv[i * 2 + 1] = 1 - v;\n        vRow.push(iv++);\n      }\n\n      grid.push(vRow);\n    }\n\n    for (let iy = 0; iy < hSegs; iy++) {\n      for (let ix = 0; ix < wSegs; ix++) {\n        let a = grid[iy][ix + 1];\n        let b = grid[iy][ix];\n        let c = grid[iy + 1][ix];\n        let d = grid[iy + 1][ix + 1];\n\n        if (iy !== 0 || tStart > 0) {\n          index[ii * 3] = a;\n          index[ii * 3 + 1] = b;\n          index[ii * 3 + 2] = d;\n          ii++;\n        }\n\n        if (iy !== hSegs - 1 || te < Math.PI) {\n          index[ii * 3] = b;\n          index[ii * 3 + 1] = c;\n          index[ii * 3 + 2] = d;\n          ii++;\n        }\n      }\n    }\n\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Cylinder.js\n\n\nclass Cylinder_Cylinder extends Geometry_Geometry {\n  constructor(gl, {\n    radiusTop = 0.5,\n    radiusBottom = 0.5,\n    height = 1,\n    radialSegments = 8,\n    heightSegments = 1,\n    openEnded = false,\n    thetaStart = 0,\n    thetaLength = Math.PI * 2,\n    attributes = {}\n  } = {}) {\n    const rSegs = radialSegments;\n    const hSegs = heightSegments;\n    const tStart = thetaStart;\n    const tLength = thetaLength;\n    const numCaps = openEnded ? 0 : radiusBottom && radiusTop ? 2 : 1;\n    const num = (rSegs + 1) * (hSegs + 1 + numCaps) + numCaps;\n    const numIndices = rSegs * hSegs * 6 + numCaps * rSegs * 3;\n    const position = new Float32Array(num * 3);\n    const normal = new Float32Array(num * 3);\n    const uv = new Float32Array(num * 2);\n    const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    let i = 0;\n    let ii = 0;\n    const indexArray = [];\n    addHeight();\n\n    if (!openEnded) {\n      if (radiusTop) addCap(true);\n      if (radiusBottom) addCap(false);\n    }\n\n    function addHeight() {\n      let x, y;\n      const n = new Vec3_Vec3();\n      const slope = (radiusBottom - radiusTop) / height;\n\n      for (y = 0; y <= hSegs; y++) {\n        const indexRow = [];\n        const v = y / hSegs;\n        const r = v * (radiusBottom - radiusTop) + radiusTop;\n\n        for (x = 0; x <= rSegs; x++) {\n          const u = x / rSegs;\n          const theta = u * tLength + tStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n          position.set([r * sinTheta, (0.5 - v) * height, r * cosTheta], i * 3);\n          n.set(sinTheta, slope, cosTheta).normalize();\n          normal.set([n.x, n.y, n.z], i * 3);\n          uv.set([u, 1 - v], i * 2);\n          indexRow.push(i++);\n        }\n\n        indexArray.push(indexRow);\n      }\n\n      for (x = 0; x < rSegs; x++) {\n        for (y = 0; y < hSegs; y++) {\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1];\n          index.set([a, b, d, b, c, d], ii * 3);\n          ii += 2;\n        }\n      }\n    }\n\n    function addCap(isTop) {\n      let x;\n      const r = isTop === true ? radiusTop : radiusBottom;\n      const sign = isTop === true ? 1 : -1;\n      const centerIndex = i;\n      position.set([0, 0.5 * height * sign, 0], i * 3);\n      normal.set([0, sign, 0], i * 3);\n      uv.set([0.5, 0.5], i * 2);\n      i++;\n\n      for (x = 0; x <= rSegs; x++) {\n        const u = x / rSegs;\n        const theta = u * tLength + tStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n        position.set([r * sinTheta, 0.5 * height * sign, r * cosTheta], i * 3);\n        normal.set([0, sign, 0], i * 3);\n        uv.set([cosTheta * 0.5 + 0.5, sinTheta * 0.5 * sign + 0.5], i * 2);\n        i++;\n      }\n\n      for (x = 0; x < rSegs; x++) {\n        const j = centerIndex + x + 1;\n\n        if (isTop) {\n          index.set([j, j + 1, centerIndex], ii * 3);\n        } else {\n          index.set([j + 1, j, centerIndex], ii * 3);\n        }\n\n        ii++;\n      }\n    }\n\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: position\n      },\n      normal: {\n        size: 3,\n        data: normal\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        data: index\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Triangle.js\n\nclass Triangle_Triangle extends Geometry_Geometry {\n  constructor(gl, {\n    attributes = {}\n  } = {}) {\n    Object.assign(attributes, {\n      position: {\n        size: 2,\n        data: new Float32Array([-1, -1, 3, -1, -1, 3])\n      },\n      uv: {\n        size: 2,\n        data: new Float32Array([0, 0, 2, 0, 0, 2])\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Torus.js\n// https://github.com/mrdoob/three.js/blob/master/src/geometries/TorusGeometry.js\n\n\nclass Torus_Torus extends Geometry_Geometry {\n  constructor(gl, {\n    radius = 0.5,\n    tube = 0.2,\n    radialSegments = 8,\n    tubularSegments = 6,\n    arc = Math.PI * 2,\n    attributes = {}\n  } = {}) {\n    const num = (radialSegments + 1) * (tubularSegments + 1);\n    const numIndices = radialSegments * tubularSegments * 6;\n    const vertices = new Float32Array(num * 3);\n    const normals = new Float32Array(num * 3);\n    const uvs = new Float32Array(num * 2);\n    const indices = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n    const center = new Vec3_Vec3();\n    const vertex = new Vec3_Vec3();\n    const normal = new Vec3_Vec3(); // generate vertices, normals and uvs\n\n    let idx = 0;\n\n    for (let j = 0; j <= radialSegments; j++) {\n      for (let i = 0; i <= tubularSegments; i++, idx++) {\n        const u = i / tubularSegments * arc;\n        const v = j / radialSegments * Math.PI * 2; // vertex\n\n        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n        vertex.z = tube * Math.sin(v);\n        vertices.set([vertex.x, vertex.y, vertex.z], idx * 3); // normal\n\n        center.x = radius * Math.cos(u);\n        center.y = radius * Math.sin(u);\n        normal.sub(vertex, center).normalize();\n        normals.set([normal.x, normal.y, normal.z], idx * 3); // uv\n\n        uvs.set([i / tubularSegments, j / radialSegments], idx * 2);\n      }\n    } // generate indices\n\n\n    idx = 0;\n\n    for (let j = 1; j <= radialSegments; j++) {\n      for (let i = 1; i <= tubularSegments; i++, idx++) {\n        // indices\n        const a = (tubularSegments + 1) * j + i - 1;\n        const b = (tubularSegments + 1) * (j - 1) + i - 1;\n        const c = (tubularSegments + 1) * (j - 1) + i;\n        const d = (tubularSegments + 1) * j + i; // faces\n\n        indices.set([a, b, d, b, c, d], idx * 6);\n      }\n    }\n\n    Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: vertices\n      },\n      normal: {\n        size: 3,\n        data: normals\n      },\n      uv: {\n        size: 2,\n        data: uvs\n      },\n      index: {\n        data: indices\n      }\n    });\n    super(gl, attributes);\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Orbit.js\n// Based from ThreeJS' OrbitControls class, rewritten using es6 with some additions and subtractions.\n// TODO: abstract event handlers so can be fed from other sources\n// TODO: make scroll zoom more accurate than just >/< zero\n// TODO: be able to pass in new camera position\n\n\nconst STATE = {\n  NONE: -1,\n  ROTATE: 0,\n  DOLLY: 1,\n  PAN: 2,\n  DOLLY_PAN: 3\n};\nconst Orbit_tempVec3 = new Vec3_Vec3();\nconst tempVec2a = new Vec2_Vec2();\nconst tempVec2b = new Vec2_Vec2();\nfunction Orbit(object, {\n  element = document,\n  enabled = true,\n  target = new Vec3_Vec3(),\n  ease = 0.25,\n  inertia = 0.85,\n  enableRotate = true,\n  rotateSpeed = 0.1,\n  autoRotate = false,\n  autoRotateSpeed = 1.0,\n  enableZoom = true,\n  zoomSpeed = 1,\n  enablePan = true,\n  panSpeed = 0.1,\n  minPolarAngle = 0,\n  maxPolarAngle = Math.PI,\n  minAzimuthAngle = -Infinity,\n  maxAzimuthAngle = Infinity,\n  minDistance = 0,\n  maxDistance = Infinity\n} = {}) {\n  this.enabled = enabled;\n  this.target = target; // Catch attempts to disable - set to 1 so has no effect\n\n  ease = ease || 1;\n  inertia = inertia || 1;\n  this.minDistance = minDistance;\n  this.maxDistance = maxDistance; // current position in sphericalTarget coordinates\n\n  const sphericalDelta = {\n    radius: 1,\n    phi: 0,\n    theta: 0\n  };\n  const sphericalTarget = {\n    radius: 1,\n    phi: 0,\n    theta: 0\n  };\n  const spherical = {\n    radius: 1,\n    phi: 0,\n    theta: 0\n  };\n  const panDelta = new Vec3_Vec3(); // Grab initial position values\n\n  const offset = new Vec3_Vec3();\n  offset.copy(object.position).sub(this.target);\n  spherical.radius = sphericalTarget.radius = offset.distance();\n  spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n  spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n\n  this.update = () => {\n    if (autoRotate) {\n      handleAutoRotate();\n    } // apply delta\n\n\n    sphericalTarget.radius *= sphericalDelta.radius;\n    sphericalTarget.theta += sphericalDelta.theta;\n    sphericalTarget.phi += sphericalDelta.phi; // apply boundaries\n\n    sphericalTarget.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sphericalTarget.theta));\n    sphericalTarget.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, sphericalTarget.phi));\n    sphericalTarget.radius = Math.max(this.minDistance, Math.min(this.maxDistance, sphericalTarget.radius)); // ease values\n\n    spherical.phi += (sphericalTarget.phi - spherical.phi) * ease;\n    spherical.theta += (sphericalTarget.theta - spherical.theta) * ease;\n    spherical.radius += (sphericalTarget.radius - spherical.radius) * ease; // apply pan to target. As offset is relative to target, it also shifts\n\n    this.target.add(panDelta); // apply rotation to offset\n\n    let sinPhiRadius = spherical.radius * Math.sin(Math.max(0.000001, spherical.phi));\n    offset.x = sinPhiRadius * Math.sin(spherical.theta);\n    offset.y = spherical.radius * Math.cos(spherical.phi);\n    offset.z = sinPhiRadius * Math.cos(spherical.theta); // Apply updated values to object\n\n    object.position.copy(this.target).add(offset);\n    object.lookAt(this.target); // Apply inertia to values\n\n    sphericalDelta.theta *= inertia;\n    sphericalDelta.phi *= inertia;\n    panDelta.multiply(inertia); // Reset scale every frame to avoid applying scale multiple times\n\n    sphericalDelta.radius = 1;\n  }; // Everything below here just updates panDelta and sphericalDelta\n  // Using those two objects' values, the orbit is calculated\n\n\n  const rotateStart = new Vec2_Vec2();\n  const panStart = new Vec2_Vec2();\n  const dollyStart = new Vec2_Vec2();\n  let state = STATE.NONE;\n  this.mouseButtons = {\n    ORBIT: 0,\n    ZOOM: 1,\n    PAN: 2\n  };\n\n  function getZoomScale() {\n    return Math.pow(0.95, zoomSpeed);\n  }\n\n  function panLeft(distance, m) {\n    Orbit_tempVec3.set(m[0], m[1], m[2]);\n    Orbit_tempVec3.multiply(-distance);\n    panDelta.add(Orbit_tempVec3);\n  }\n\n  function panUp(distance, m) {\n    Orbit_tempVec3.set(m[4], m[5], m[6]);\n    Orbit_tempVec3.multiply(distance);\n    panDelta.add(Orbit_tempVec3);\n  }\n\n  const pan = (deltaX, deltaY) => {\n    let el = element === document ? document.body : element;\n    Orbit_tempVec3.copy(object.position).sub(this.target);\n    let targetDistance = Orbit_tempVec3.distance();\n    targetDistance *= Math.tan((object.fov || 45) / 2 * Math.PI / 180.0);\n    panLeft(2 * deltaX * targetDistance / el.clientHeight, object.matrix);\n    panUp(2 * deltaY * targetDistance / el.clientHeight, object.matrix);\n  };\n\n  function dolly(dollyScale) {\n    sphericalDelta.radius /= dollyScale;\n  }\n\n  function handleAutoRotate() {\n    const angle = 2 * Math.PI / 60 / 60 * autoRotateSpeed;\n    sphericalDelta.theta -= angle;\n  }\n\n  function handleMoveRotate(x, y) {\n    tempVec2a.set(x, y);\n    tempVec2b.sub(tempVec2a, rotateStart).multiply(rotateSpeed);\n    let el = element === document ? document.body : element;\n    sphericalDelta.theta -= 2 * Math.PI * tempVec2b.x / el.clientHeight;\n    sphericalDelta.phi -= 2 * Math.PI * tempVec2b.y / el.clientHeight;\n    rotateStart.copy(tempVec2a);\n  }\n\n  function handleMouseMoveDolly(e) {\n    tempVec2a.set(e.clientX, e.clientY);\n    tempVec2b.sub(tempVec2a, dollyStart);\n\n    if (tempVec2b.y > 0) {\n      dolly(getZoomScale());\n    } else if (tempVec2b.y < 0) {\n      dolly(1 / getZoomScale());\n    }\n\n    dollyStart.copy(tempVec2a);\n  }\n\n  function handleMovePan(x, y) {\n    tempVec2a.set(x, y);\n    tempVec2b.sub(tempVec2a, panStart).multiply(panSpeed);\n    pan(tempVec2b.x, tempVec2b.y);\n    panStart.copy(tempVec2a);\n  }\n\n  function handleTouchStartDollyPan(e) {\n    if (enableZoom) {\n      let dx = e.touches[0].pageX - e.touches[1].pageX;\n      let dy = e.touches[0].pageY - e.touches[1].pageY;\n      let distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n\n    if (enablePan) {\n      let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n      let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n      panStart.set(x, y);\n    }\n  }\n\n  function handleTouchMoveDollyPan(e) {\n    if (enableZoom) {\n      let dx = e.touches[0].pageX - e.touches[1].pageX;\n      let dy = e.touches[0].pageY - e.touches[1].pageY;\n      let distance = Math.sqrt(dx * dx + dy * dy);\n      tempVec2a.set(0, distance);\n      tempVec2b.set(0, Math.pow(tempVec2a.y / dollyStart.y, zoomSpeed));\n      dolly(tempVec2b.y);\n      dollyStart.copy(tempVec2a);\n    }\n\n    if (enablePan) {\n      let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n      let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n      handleMovePan(x, y);\n    }\n  }\n\n  const onMouseDown = e => {\n    if (!this.enabled) return;\n\n    switch (e.button) {\n      case this.mouseButtons.ORBIT:\n        if (enableRotate === false) return;\n        rotateStart.set(e.clientX, e.clientY);\n        state = STATE.ROTATE;\n        break;\n\n      case this.mouseButtons.ZOOM:\n        if (enableZoom === false) return;\n        dollyStart.set(e.clientX, e.clientY);\n        state = STATE.DOLLY;\n        break;\n\n      case this.mouseButtons.PAN:\n        if (enablePan === false) return;\n        panStart.set(e.clientX, e.clientY);\n        state = STATE.PAN;\n        break;\n    }\n\n    if (state !== STATE.NONE) {\n      window.addEventListener('mousemove', onMouseMove, false);\n      window.addEventListener('mouseup', onMouseUp, false);\n    }\n  };\n\n  const onMouseMove = e => {\n    if (!this.enabled) return;\n\n    switch (state) {\n      case STATE.ROTATE:\n        if (enableRotate === false) return;\n        handleMoveRotate(e.clientX, e.clientY);\n        break;\n\n      case STATE.DOLLY:\n        if (enableZoom === false) return;\n        handleMouseMoveDolly(e);\n        break;\n\n      case STATE.PAN:\n        if (enablePan === false) return;\n        handleMovePan(e.clientX, e.clientY);\n        break;\n    }\n  };\n\n  const onMouseUp = () => {\n    window.removeEventListener('mousemove', onMouseMove, false);\n    window.removeEventListener('mouseup', onMouseUp, false);\n    state = STATE.NONE;\n  };\n\n  const onMouseWheel = e => {\n    if (!this.enabled || !enableZoom || state !== STATE.NONE && state !== STATE.ROTATE) return;\n    e.stopPropagation();\n    e.preventDefault();\n\n    if (e.deltaY < 0) {\n      dolly(1 / getZoomScale());\n    } else if (e.deltaY > 0) {\n      dolly(getZoomScale());\n    }\n  };\n\n  const onTouchStart = e => {\n    if (!this.enabled) return;\n    e.preventDefault();\n\n    switch (e.touches.length) {\n      case 1:\n        if (enableRotate === false) return;\n        rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);\n        state = STATE.ROTATE;\n        break;\n\n      case 2:\n        if (enableZoom === false && enablePan === false) return;\n        handleTouchStartDollyPan(e);\n        state = STATE.DOLLY_PAN;\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n  };\n\n  const onTouchMove = e => {\n    if (!this.enabled) return;\n    e.preventDefault();\n    e.stopPropagation();\n\n    switch (e.touches.length) {\n      case 1:\n        if (enableRotate === false) return;\n        handleMoveRotate(e.touches[0].pageX, e.touches[0].pageY);\n        break;\n\n      case 2:\n        if (enableZoom === false && enablePan === false) return;\n        handleTouchMoveDollyPan(e);\n        break;\n\n      default:\n        state = STATE.NONE;\n    }\n  };\n\n  const onTouchEnd = () => {\n    if (!this.enabled) return;\n    state = STATE.NONE;\n  };\n\n  const onContextMenu = e => {\n    if (!this.enabled) return;\n    e.preventDefault();\n  };\n\n  function addHandlers() {\n    element.addEventListener('contextmenu', onContextMenu, false);\n    element.addEventListener('mousedown', onMouseDown, false);\n    element.addEventListener('wheel', onMouseWheel, {\n      passive: false\n    });\n    element.addEventListener('touchstart', onTouchStart, {\n      passive: false\n    });\n    element.addEventListener('touchend', onTouchEnd, false);\n    element.addEventListener('touchmove', onTouchMove, {\n      passive: false\n    });\n  }\n\n  this.remove = function () {\n    element.removeEventListener('contextmenu', onContextMenu);\n    element.removeEventListener('mousedown', onMouseDown);\n    element.removeEventListener('wheel', onMouseWheel);\n    element.removeEventListener('touchstart', onTouchStart);\n    element.removeEventListener('touchend', onTouchEnd);\n    element.removeEventListener('touchmove', onTouchMove);\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n  };\n\n  addHandlers();\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Raycast.js\n// TODO: add barycentric ?\n\n\nconst Raycast_tempVec3a = new Vec3_Vec3();\nconst Raycast_tempVec3b = new Vec3_Vec3();\nconst tempVec3c = new Vec3_Vec3();\nconst Raycast_tempMat4 = new Mat4_Mat4();\nclass Raycast_Raycast {\n  constructor(gl) {\n    this.gl = gl;\n    this.origin = new Vec3_Vec3();\n    this.direction = new Vec3_Vec3();\n  } // Set ray from mouse unprojection\n\n\n  castMouse(camera, mouse = [0, 0]) {\n    if (camera.type === 'orthographic') {\n      // Set origin\n      // Since camera is orthographic, origin is not the camera position\n      const {\n        left,\n        right,\n        bottom,\n        top,\n        zoom\n      } = camera;\n      const x = left / zoom + (right - left) / zoom * (mouse[0] * 0.5 + 0.5);\n      const y = bottom / zoom + (top - bottom) / zoom * (mouse[1] * 0.5 + 0.5);\n      this.origin.set(x, y, 0);\n      this.origin.applyMatrix4(camera.worldMatrix); // Set direction\n      // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n\n      this.direction.x = -camera.worldMatrix[8];\n      this.direction.y = -camera.worldMatrix[9];\n      this.direction.z = -camera.worldMatrix[10];\n    } else {\n      // Set origin\n      camera.worldMatrix.getTranslation(this.origin); // Set direction\n\n      this.direction.set(mouse[0], mouse[1], 0.5);\n      camera.unproject(this.direction);\n      this.direction.sub(this.origin).normalize();\n    }\n  }\n\n  intersectBounds(meshes) {\n    if (!Array.isArray(meshes)) meshes = [meshes];\n    const invWorldMat4 = Raycast_tempMat4;\n    const origin = Raycast_tempVec3a;\n    const direction = Raycast_tempVec3b;\n    const hits = [];\n    meshes.forEach(mesh => {\n      // Create bounds\n      if (!mesh.geometry.bounds) mesh.geometry.computeBoundingBox();\n      if (mesh.geometry.raycast === 'sphere' && mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere(); // Take world space ray and make it object space to align with bounding box\n\n      invWorldMat4.inverse(mesh.worldMatrix);\n      origin.copy(this.origin).applyMatrix4(invWorldMat4);\n      direction.copy(this.direction).transformDirection(invWorldMat4);\n      let localDistance = 0;\n\n      if (mesh.geometry.raycast === 'sphere') {\n        localDistance = this.intersectSphere(mesh.geometry.bounds, origin, direction);\n      } else {\n        localDistance = this.intersectBox(mesh.geometry.bounds, origin, direction);\n      }\n\n      if (!localDistance) return; // Create object on mesh to avoid generating lots of objects\n\n      if (!mesh.hit) mesh.hit = {\n        localPoint: new Vec3_Vec3(),\n        point: new Vec3_Vec3()\n      };\n      mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n      mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n      mesh.hit.distance = mesh.hit.point.distance(this.origin);\n      hits.push(mesh);\n    });\n    hits.sort((a, b) => a.hit.distance - b.hit.distance);\n    return hits;\n  }\n\n  intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n    const ray = tempVec3c;\n    ray.sub(sphere.center, origin);\n    const tca = ray.dot(direction);\n    const d2 = ray.dot(ray) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return 0;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 = tca - thc;\n    const t1 = tca + thc;\n    if (t0 < 0 && t1 < 0) return 0;\n    if (t0 < 0) return t1;\n    return t0;\n  } // Ray AABB - Ray Axis aligned bounding box testing\n\n\n  intersectBox(box, origin = this.origin, direction = this.direction) {\n    let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n    const invdirx = 1 / direction.x;\n    const invdiry = 1 / direction.y;\n    const invdirz = 1 / direction.z;\n    const min = box.min;\n    const max = box.max;\n    tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n    tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n    tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n    tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n    if (tmin > tYmax || tYmin > tmax) return 0;\n    if (tYmin > tmin) tmin = tYmin;\n    if (tYmax < tmax) tmax = tYmax;\n    tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n    tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n    if (tmin > tZmax || tZmin > tmax) return 0;\n    if (tZmin > tmin) tmin = tZmin;\n    if (tZmax < tmax) tmax = tZmax;\n    if (tmax < 0) return 0;\n    return tmin >= 0 ? tmin : tmax;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Curve.js\n\nconst CATMULLROM = 'catmullrom';\nconst CUBICBEZIER = 'cubicbezier';\nconst QUADRATICBEZIER = 'quadraticbezier'; // temp\n\nconst _a0 = new Vec3_Vec3(),\n      _a1 = new Vec3_Vec3(),\n      _a2 = new Vec3_Vec3(),\n      _a3 = new Vec3_Vec3();\n/**\n * Get the control points of cubic bezier curve.\n * @param {*} i\n * @param {*} a\n * @param {*} b\n */\n\n\nfunction getCtrlPoint(points, i, a = 0.168, b = 0.168) {\n  if (i < 1) {\n    _a0.sub(points[1], points[0]).scale(a).add(points[0]);\n  } else {\n    _a0.sub(points[i + 1], points[i - 1]).scale(a).add(points[i]);\n  }\n\n  if (i > points.length - 3) {\n    const last = points.length - 1;\n\n    _a1.sub(points[last - 1], points[last]).scale(b).add(points[last]);\n  } else {\n    _a1.sub(points[i], points[i + 2]).scale(b).add(points[i + 1]);\n  }\n\n  return [_a0.clone(), _a1.clone()];\n}\n\nfunction getQuadraticBezierPoint(t, p0, c0, p1) {\n  const k = 1 - t;\n\n  _a0.copy(p0).scale(k ** 2);\n\n  _a1.copy(c0).scale(2 * k * t);\n\n  _a2.copy(p1).scale(t ** 2);\n\n  const ret = new Vec3_Vec3();\n  ret.add(_a0, _a1).add(_a2);\n  return ret;\n}\n\nfunction getCubicBezierPoint(t, p0, c0, c1, p1) {\n  const k = 1 - t;\n\n  _a0.copy(p0).scale(k ** 3);\n\n  _a1.copy(c0).scale(3 * k ** 2 * t);\n\n  _a2.copy(c1).scale(3 * k * t ** 2);\n\n  _a3.copy(p1).scale(t ** 3);\n\n  const ret = new Vec3_Vec3();\n  ret.add(_a0, _a1).add(_a2).add(_a3);\n  return ret;\n}\n\nclass Curve_Curve {\n  constructor({\n    points = [new Vec3_Vec3(0, 0, 0), new Vec3_Vec3(0, 1, 0), new Vec3_Vec3(1, 1, 0), new Vec3_Vec3(1, 0, 0)],\n    divisions = 12,\n    type = CATMULLROM\n  } = {}) {\n    this.points = points;\n    this.divisions = divisions;\n    this.type = type;\n  }\n\n  _getQuadraticBezierPoints(divisions = this.divisions) {\n    const points = [];\n    const count = this.points.length;\n\n    if (count < 3) {\n      console.warn('Not enough points provided.');\n      return [];\n    }\n\n    const p0 = this.points[0];\n    let c0 = this.points[1],\n        p1 = this.points[2];\n\n    for (let i = 0; i <= divisions; i++) {\n      const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n      points.push(p);\n    }\n\n    let offset = 3;\n\n    while (count - offset > 0) {\n      p0.copy(p1);\n      c0 = p1.scale(2).sub(c0);\n      p1 = this.points[offset];\n\n      for (let i = 1; i <= divisions; i++) {\n        const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n        points.push(p);\n      }\n\n      offset++;\n    }\n\n    return points;\n  }\n\n  _getCubicBezierPoints(divisions = this.divisions) {\n    const points = [];\n    const count = this.points.length;\n\n    if (count < 4) {\n      console.warn('Not enough points provided.');\n      return [];\n    }\n\n    let p0 = this.points[0],\n        c0 = this.points[1],\n        c1 = this.points[2],\n        p1 = this.points[3];\n\n    for (let i = 0; i <= divisions; i++) {\n      const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n      points.push(p);\n    }\n\n    let offset = 4;\n\n    while (count - offset > 1) {\n      p0.copy(p1);\n      c0 = p1.scale(2).sub(c1);\n      c1 = this.points[offset];\n      p1 = this.points[offset + 1];\n\n      for (let i = 1; i <= divisions; i++) {\n        const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n        points.push(p);\n      }\n\n      offset += 2;\n    }\n\n    return points;\n  }\n\n  _getCatmullRomPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n    const points = [];\n    const count = this.points.length;\n\n    if (count <= 2) {\n      return this.points;\n    }\n\n    let p0;\n    this.points.forEach((p, i) => {\n      if (i === 0) {\n        p0 = p;\n      } else {\n        const [c0, c1] = getCtrlPoint(this.points, i - 1, a, b);\n        const c = new Curve_Curve({\n          points: [p0, c0, c1, p],\n          type: CUBICBEZIER\n        });\n        points.pop();\n        points.push(...c.getPoints(divisions));\n        p0 = p;\n      }\n    });\n    return points;\n  }\n\n  getPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n    const type = this.type;\n\n    if (type === QUADRATICBEZIER) {\n      return this._getQuadraticBezierPoints(divisions);\n    }\n\n    if (type === CUBICBEZIER) {\n      return this._getCubicBezierPoints(divisions);\n    }\n\n    if (type === CATMULLROM) {\n      return this._getCatmullRomPoints(divisions, a, b);\n    }\n\n    return this.points;\n  }\n\n}\nCurve_Curve.CATMULLROM = CATMULLROM;\nCurve_Curve.CUBICBEZIER = CUBICBEZIER;\nCurve_Curve.QUADRATICBEZIER = QUADRATICBEZIER;\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Post.js\n// TODO: Destroy render targets if size changed and exists\n\n\n\n\nclass Post_Post {\n  constructor(gl, {\n    width,\n    height,\n    dpr,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    minFilter = gl.LINEAR,\n    magFilter = gl.LINEAR,\n    geometry = new Triangle_Triangle(gl),\n    targetOnly = null\n  } = {}) {\n    this.gl = gl;\n    this.options = {\n      wrapS,\n      wrapT,\n      minFilter,\n      magFilter\n    };\n    this.passes = [];\n    this.geometry = geometry;\n    this.uniform = {\n      value: null\n    };\n    this.targetOnly = targetOnly;\n    const fbo = this.fbo = {\n      read: null,\n      write: null,\n      swap: () => {\n        let temp = fbo.read;\n        fbo.read = fbo.write;\n        fbo.write = temp;\n      }\n    };\n    this.resize({\n      width,\n      height,\n      dpr\n    });\n  }\n\n  addPass({\n    vertex = defaultVertex,\n    fragment = defaultFragment,\n    uniforms = {},\n    textureUniform = 'tMap',\n    enabled = true\n  } = {}) {\n    uniforms[textureUniform] = {\n      value: this.fbo.read.texture\n    };\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh_Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n\n  resize({\n    width,\n    height,\n    dpr\n  } = {}) {\n    if (dpr) this.dpr = dpr;\n\n    if (width) {\n      this.width = width;\n      this.height = height || width;\n    }\n\n    dpr = this.dpr || this.gl.renderer.dpr;\n    width = (this.width || this.gl.renderer.width) * dpr;\n    height = (this.height || this.gl.renderer.height) * dpr;\n    this.options.width = width;\n    this.options.height = height;\n    this.fbo.read = new RenderTarget_RenderTarget(this.gl, this.options);\n    this.fbo.write = new RenderTarget_RenderTarget(this.gl, this.options);\n  } // Uses same arguments as renderer.render\n\n\n  render({\n    scene,\n    camera,\n    target = null,\n    update = true,\n    sort = true,\n    frustumCull = true\n  }) {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    this.gl.renderer.render({\n      scene,\n      camera,\n      target: enabledPasses.length || !target && this.targetOnly ? this.fbo.write : target,\n      update,\n      sort,\n      frustumCull\n    });\n    this.fbo.swap();\n    enabledPasses.forEach((pass, i) => {\n      pass.mesh.program.uniforms[pass.textureUniform].value = this.fbo.read.texture;\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n        clear: true\n      });\n      this.fbo.swap();\n    });\n    this.uniform.value = this.fbo.read.texture;\n  }\n\n}\nconst defaultVertex =\n/* glsl */\n`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst defaultFragment =\n/* glsl */\n`\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Animation.js\n\n\nconst prevPos = new Vec3_Vec3();\nconst prevRot = new Quat_Quat();\nconst prevScl = new Vec3_Vec3();\nconst nextPos = new Vec3_Vec3();\nconst nextRot = new Quat_Quat();\nconst nextScl = new Vec3_Vec3();\nclass Animation {\n  constructor({\n    objects,\n    data\n  }) {\n    this.objects = objects;\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = 1;\n    this.duration = data.frames.length - 1;\n  }\n\n  update(totalWeight = 1, isSet) {\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = this.elapsed % this.duration;\n    const floorFrame = Math.floor(elapsed);\n    const blend = elapsed - floorFrame;\n    const prevKey = this.data.frames[floorFrame];\n    const nextKey = this.data.frames[(floorFrame + 1) % this.duration];\n    this.objects.forEach((object, i) => {\n      prevPos.fromArray(prevKey.position, i * 3);\n      prevRot.fromArray(prevKey.quaternion, i * 4);\n      prevScl.fromArray(prevKey.scale, i * 3);\n      nextPos.fromArray(nextKey.position, i * 3);\n      nextRot.fromArray(nextKey.quaternion, i * 4);\n      nextScl.fromArray(nextKey.scale, i * 3);\n      prevPos.lerp(nextPos, blend);\n      prevRot.slerp(nextRot, blend);\n      prevScl.lerp(nextScl, blend);\n      object.position.lerp(prevPos, weight);\n      object.quaternion.slerp(prevRot, weight);\n      object.scale.lerp(prevScl, weight);\n    });\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Skin.js\n\n\n\n\n\nconst Skin_tempMat4 = new Mat4_Mat4();\nclass Skin_Skin extends Mesh_Mesh {\n  constructor(gl, {\n    rig,\n    geometry,\n    program,\n    mode = gl.TRIANGLES\n  } = {}) {\n    super(gl, {\n      geometry,\n      program,\n      mode\n    });\n    this.createBones(rig);\n    this.createBoneTexture();\n    this.animations = [];\n    Object.assign(this.program.uniforms, {\n      boneTexture: {\n        value: this.boneTexture\n      },\n      boneTextureSize: {\n        value: this.boneTextureSize\n      }\n    });\n  }\n\n  createBones(rig) {\n    // Create root so that can simply update world matrix of whole skeleton\n    this.root = new Transform_Transform(); // Create bones\n\n    this.bones = [];\n    if (!rig.bones || !rig.bones.length) return;\n\n    for (let i = 0; i < rig.bones.length; i++) {\n      const bone = new Transform_Transform(); // Set initial values (bind pose)\n\n      bone.position.fromArray(rig.bindPose.position, i * 3);\n      bone.quaternion.fromArray(rig.bindPose.quaternion, i * 4);\n      bone.scale.fromArray(rig.bindPose.scale, i * 3);\n      this.bones.push(bone);\n    } // Once created, set the hierarchy\n\n\n    rig.bones.forEach((data, i) => {\n      this.bones[i].name = data.name;\n      if (data.parent === -1) return this.bones[i].setParent(this.root);\n      this.bones[i].setParent(this.bones[data.parent]);\n    }); // Then update to calculate world matrices\n\n    this.root.updateMatrixWorld(true); // Store inverse of bind pose to calculate differences\n\n    this.bones.forEach(bone => {\n      bone.bindInverse = new Mat4_Mat4(...bone.worldMatrix).inverse();\n    });\n  }\n\n  createBoneTexture() {\n    if (!this.bones.length) return;\n    const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));\n    this.boneMatrices = new Float32Array(size * size * 4);\n    this.boneTextureSize = size;\n    this.boneTexture = new Texture(this.gl, {\n      image: this.boneMatrices,\n      generateMipmaps: false,\n      type: this.gl.FLOAT,\n      internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA16F : this.gl.RGBA,\n      flipY: false,\n      width: size\n    });\n  }\n\n  addAnimation(data) {\n    const animation = new Animation({\n      objects: this.bones,\n      data\n    });\n    this.animations.push(animation);\n    return animation;\n  }\n\n  update() {\n    // Calculate combined animation weight\n    let total = 0;\n    this.animations.forEach(animation => total += animation.weight);\n    this.animations.forEach((animation, i) => {\n      // force first animation to set in order to reset frame\n      animation.update(total, i === 0);\n    });\n  }\n\n  draw({\n    camera\n  } = {}) {\n    // Update world matrices manually, as not part of scene graph\n    this.root.updateMatrixWorld(true); // Update bone texture\n\n    this.bones.forEach((bone, i) => {\n      // Find difference between current and bind pose\n      Skin_tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n      this.boneMatrices.set(Skin_tempMat4, i * 16);\n    });\n    if (this.boneTexture) this.boneTexture.needsUpdate = true;\n    super.draw({\n      camera\n    });\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Text.js\nfunction Text({\n  font,\n  text,\n  width = Infinity,\n  align = 'left',\n  size = 1,\n  letterSpacing = 0,\n  lineHeight = 1.4,\n  wordSpacing = 0,\n  wordBreak = false\n}) {\n  const _this = this;\n\n  let glyphs, buffers;\n  let fontHeight, baseline, scale;\n  const newline = /\\n/;\n  const whitespace = /\\s/;\n  {\n    parseFont();\n    createGeometry();\n  }\n\n  function parseFont() {\n    glyphs = {};\n    font.chars.forEach(d => glyphs[d.char] = d);\n  }\n\n  function createGeometry() {\n    fontHeight = font.common.lineHeight;\n    baseline = font.common.base; // Use baseline so that actual text height is as close to 'size' value as possible\n\n    scale = size / baseline; // Strip spaces and newlines to get actual character length for buffers\n\n    let chars = text.replace(/[ \\n]/g, '');\n    let numChars = chars.length; // Create output buffers\n\n    buffers = {\n      position: new Float32Array(numChars * 4 * 3),\n      uv: new Float32Array(numChars * 4 * 2),\n      id: new Float32Array(numChars * 4),\n      index: new Uint16Array(numChars * 6)\n    }; // Set values for buffers that don't require calculation\n\n    for (let i = 0; i < numChars; i++) {\n      buffers.id[i] = i;\n      buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);\n    }\n\n    layout();\n  }\n\n  function layout() {\n    const lines = [];\n    let cursor = 0;\n    let wordCursor = 0;\n    let wordWidth = 0;\n    let line = newLine();\n\n    function newLine() {\n      const line = {\n        width: 0,\n        glyphs: []\n      };\n      lines.push(line);\n      wordCursor = cursor;\n      wordWidth = 0;\n      return line;\n    }\n\n    let maxTimes = 100;\n    let count = 0;\n\n    while (cursor < text.length && count < maxTimes) {\n      count++;\n      const char = text[cursor]; // Skip whitespace at start of line\n\n      if (!line.width && whitespace.test(char)) {\n        cursor++;\n        wordCursor = cursor;\n        wordWidth = 0;\n        continue;\n      } // If newline char, skip to next line\n\n\n      if (newline.test(char)) {\n        cursor++;\n        line = newLine();\n        continue;\n      }\n\n      const glyph = glyphs[char]; // Find any applicable kern pairs\n\n      if (line.glyphs.length) {\n        const prevGlyph = line.glyphs[line.glyphs.length - 1][0];\n        let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;\n        line.width += kern;\n        wordWidth += kern;\n      } // add char to line\n\n\n      line.glyphs.push([glyph, line.width]); // calculate advance for next glyph\n\n      let advance = 0; // If whitespace, update location of current word for line breaks\n\n      if (whitespace.test(char)) {\n        wordCursor = cursor;\n        wordWidth = 0; // Add wordspacing\n\n        advance += wordSpacing * size;\n      } else {\n        // Add letterspacing\n        advance += letterSpacing * size;\n      }\n\n      advance += glyph.xadvance * scale;\n      line.width += advance;\n      wordWidth += advance; // If width defined\n\n      if (line.width > width) {\n        // If can break words, undo latest glyph if line not empty and create new line\n        if (wordBreak && line.glyphs.length > 1) {\n          line.width -= advance;\n          line.glyphs.pop();\n          line = newLine();\n          continue; // If not first word, undo current word and cursor and create new line\n        } else if (!wordBreak && wordWidth !== line.width) {\n          let numGlyphs = cursor - wordCursor + 1;\n          line.glyphs.splice(-numGlyphs, numGlyphs);\n          cursor = wordCursor;\n          line.width -= wordWidth;\n          line = newLine();\n          continue;\n        }\n      }\n\n      cursor++;\n    } // Remove last line if empty\n\n\n    if (!line.width) lines.pop();\n    populateBuffers(lines);\n  }\n\n  function populateBuffers(lines) {\n    const texW = font.common.scaleW;\n    const texH = font.common.scaleH; // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.\n\n    let y = 0.07 * size;\n    let j = 0;\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      let line = lines[lineIndex];\n\n      for (let i = 0; i < line.glyphs.length; i++) {\n        const glyph = line.glyphs[i][0];\n        let x = line.glyphs[i][1];\n\n        if (align === 'center') {\n          x -= line.width * 0.5;\n        } else if (align === 'right') {\n          x -= line.width;\n        } // If space, don't add to geometry\n\n\n        if (whitespace.test(glyph.char)) continue; // Apply char sprite offsets\n\n        x += glyph.xoffset * scale;\n        y -= glyph.yoffset * scale; // each letter is a quad. axis bottom left\n\n        let w = glyph.width * scale;\n        let h = glyph.height * scale;\n        buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);\n        let u = glyph.x / texW;\n        let uw = glyph.width / texW;\n        let v = 1.0 - glyph.y / texH;\n        let vh = glyph.height / texH;\n        buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2); // Reset cursor to baseline\n\n        y += glyph.yoffset * scale;\n        j++;\n      }\n\n      y -= size * lineHeight;\n    }\n\n    _this.buffers = buffers;\n    _this.numLines = lines.length;\n    _this.height = _this.numLines * size * lineHeight;\n  }\n\n  function getKernPairOffset(id1, id2) {\n    for (let i = 0; i < font.kernings.length; i++) {\n      let k = font.kernings[i];\n      if (k.first < id1) continue;\n      if (k.second < id2) continue;\n      if (k.first > id1) return 0;\n      if (k.first === id1 && k.second > id2) return 0;\n      return k.amount;\n    }\n\n    return 0;\n  } // Update buffers to layout with new layout\n\n\n  this.resize = function (options) {\n    ({\n      width\n    } = options);\n    layout();\n  }; // Completely change text (like creating new Text)\n\n\n  this.update = function (options) {\n    ({\n      text\n    } = options);\n    createGeometry();\n  };\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/NormalProgram.js\n\nconst NormalProgram_vertex =\n/* glsl */\n`\n    precision highp float;\n    precision highp int;\n\n    attribute vec3 position;\n    attribute vec3 normal;\n\n    uniform mat3 normalMatrix;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vNormal;\n\n    void main() {\n        vNormal = normalize(normalMatrix * normal);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\nconst NormalProgram_fragment =\n/* glsl */\n`\n    precision highp float;\n    precision highp int;\n\n    varying vec3 vNormal;\n\n    void main() {\n        gl_FragColor.rgb = normalize(vNormal);\n        gl_FragColor.a = 1.0;\n    }\n`;\nfunction NormalProgram(gl) {\n  return new Program(gl, {\n    vertex: NormalProgram_vertex,\n    fragment: NormalProgram_fragment,\n    cullFace: null\n  });\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Flowmap.js\n\n\n\n\n\nclass Flowmap_Flowmap {\n  constructor(gl, {\n    size = 128,\n    // default size of the render targets\n    falloff = 0.3,\n    // size of the stamp, percentage of the size\n    alpha = 1,\n    // opacity of the stamp\n    dissipation = 0.98,\n    // affects the speed that the stamp fades. Closer to 1 is slower\n    type // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n\n  } = {}) {\n    const _this = this;\n\n    this.gl = gl; // output uniform containing render target textures\n\n    this.uniform = {\n      value: null\n    };\n    this.mask = {\n      read: null,\n      write: null,\n      // Helper function to ping pong the render targets and update the uniform\n      swap: () => {\n        let temp = _this.mask.read;\n        _this.mask.read = _this.mask.write;\n        _this.mask.write = temp;\n        _this.uniform.value = _this.mask.read.texture;\n      }\n    };\n    {\n      createFBOs();\n      this.aspect = 1;\n      this.mouse = new Vec2_Vec2();\n      this.velocity = new Vec2_Vec2();\n      this.mesh = initProgram();\n    }\n\n    function createFBOs() {\n      // Requested type not supported, fall back to half float\n      if (!type) type = gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES;\n\n      let minFilter = (() => {\n        if (gl.renderer.isWebgl2) return gl.LINEAR;\n        if (gl.renderer.extensions[`OES_texture_${type === gl.FLOAT ? '' : 'half_'}float_linear`]) return gl.LINEAR;\n        return gl.NEAREST;\n      })();\n\n      const options = {\n        width: size,\n        height: size,\n        type,\n        format: gl.RGBA,\n        internalFormat: gl.renderer.isWebgl2 ? type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F : gl.RGBA,\n        minFilter,\n        depth: false\n      };\n      _this.mask.read = new RenderTarget_RenderTarget(gl, options);\n      _this.mask.write = new RenderTarget_RenderTarget(gl, options);\n\n      _this.mask.swap();\n    }\n\n    function initProgram() {\n      return new Mesh_Mesh(gl, {\n        // Triangle that includes -1 to 1 range for 'position', and 0 to 1 range for 'uv'.\n        geometry: new Triangle_Triangle(gl),\n        program: new Program(gl, {\n          vertex: Flowmap_vertex,\n          fragment: Flowmap_fragment,\n          uniforms: {\n            tMap: _this.uniform,\n            uFalloff: {\n              value: falloff * 0.5\n            },\n            uAlpha: {\n              value: alpha\n            },\n            uDissipation: {\n              value: dissipation\n            },\n            // User needs to update these\n            uAspect: {\n              value: 1\n            },\n            uMouse: {\n              value: _this.mouse\n            },\n            uVelocity: {\n              value: _this.velocity\n            }\n          },\n          depthTest: false\n        })\n      });\n    }\n  }\n\n  update() {\n    this.mesh.program.uniforms.uAspect.value = this.aspect;\n    this.gl.renderer.render({\n      scene: this.mesh,\n      target: this.mask.write,\n      clear: false\n    });\n    this.mask.swap();\n  }\n\n}\nconst Flowmap_vertex =\n/* glsl */\n`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst Flowmap_fragment =\n/* glsl */\n`\n    precision highp float;\n\n    uniform sampler2D tMap;\n\n    uniform float uFalloff;\n    uniform float uAlpha;\n    uniform float uDissipation;\n    \n    uniform float uAspect;\n    uniform vec2 uMouse;\n    uniform vec2 uVelocity;\n\n    varying vec2 vUv;\n\n    void main() {\n        vec4 color = texture2D(tMap, vUv) * uDissipation;\n\n        vec2 cursor = vUv - uMouse;\n        cursor.x *= uAspect;\n\n        vec3 stamp = vec3(uVelocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(uVelocity)), 3.0));\n        float falloff = smoothstep(uFalloff, 0.0, length(cursor)) * uAlpha;\n\n        color.rgb = mix(color.rgb, stamp, vec3(falloff));\n\n        gl_FragColor = color;\n    }\n`;\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/GPGPU.js\n\n\n\n\n\nclass GPGPU_GPGPU {\n  constructor(gl, {\n    // Always pass in array of vec4s (RGBA values within texture)\n    data = new Float32Array(16),\n    geometry = new Triangle_Triangle(gl),\n    type // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n\n  }) {\n    this.gl = gl;\n    const initialData = data;\n    this.passes = [];\n    this.geometry = geometry;\n    this.dataLength = initialData.length / 4; // Windows and iOS only like power of 2 textures\n    // Find smallest PO2 that fits data\n\n    this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2)); // Create coords for output texture\n\n    this.coords = new Float32Array(this.dataLength * 2);\n\n    for (let i = 0; i < this.dataLength; i++) {\n      const x = i % this.size / this.size; // to add 0.5 to be center pixel ?\n\n      const y = Math.floor(i / this.size) / this.size;\n      this.coords.set([x, y], i * 2);\n    } // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n\n\n    const floatArray = (() => {\n      if (initialData.length === this.size * this.size * 4) {\n        return initialData;\n      } else {\n        const a = new Float32Array(this.size * this.size * 4);\n        a.set(initialData);\n        return a;\n      }\n    })(); // Create output texture uniform using input float texture with initial data\n\n\n    this.uniform = {\n      value: new Texture(gl, {\n        image: floatArray,\n        target: gl.TEXTURE_2D,\n        type: gl.FLOAT,\n        format: gl.RGBA,\n        internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        generateMipmaps: false,\n        minFilter: gl.NEAREST,\n        magFilter: gl.NEAREST,\n        width: this.size,\n        flipY: false\n      })\n    }; // Create FBOs\n\n    const options = {\n      width: this.size,\n      height: this.size,\n      type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n      format: gl.RGBA,\n      internalFormat: gl.renderer.isWebgl2 ? type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F : gl.RGBA,\n      minFilter: gl.NEAREST,\n      depth: false,\n      unpackAlignment: 1\n    };\n    this.fbo = {\n      read: new RenderTarget_RenderTarget(gl, options),\n      write: new RenderTarget_RenderTarget(gl, options),\n      swap: () => {\n        let temp = this.fbo.read;\n        this.fbo.read = this.fbo.write;\n        this.fbo.write = temp;\n        this.uniform.value = this.fbo.read.texture;\n      }\n    };\n  }\n\n  addPass({\n    vertex = GPGPU_defaultVertex,\n    fragment = GPGPU_defaultFragment,\n    uniforms = {},\n    textureUniform = 'tMap',\n    enabled = true\n  } = {}) {\n    uniforms[textureUniform] = this.uniform;\n    const program = new Program(this.gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    const mesh = new Mesh_Mesh(this.gl, {\n      geometry: this.geometry,\n      program\n    });\n    const pass = {\n      mesh,\n      program,\n      uniforms,\n      enabled,\n      textureUniform\n    };\n    this.passes.push(pass);\n    return pass;\n  }\n\n  render() {\n    const enabledPasses = this.passes.filter(pass => pass.enabled);\n    enabledPasses.forEach((pass, i) => {\n      this.gl.renderer.render({\n        scene: pass.mesh,\n        target: this.fbo.write,\n        clear: false\n      });\n      this.fbo.swap();\n    });\n  }\n\n}\nconst GPGPU_defaultVertex =\n/* glsl */\n`\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\nconst GPGPU_defaultFragment =\n/* glsl */\n`\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Polyline.js\n\n\n\n\n\n\nconst tmp = new Vec3_Vec3();\nclass Polyline_Polyline {\n  constructor(gl, {\n    points,\n    // Array of Vec3s\n    vertex = Polyline_defaultVertex,\n    fragment = Polyline_defaultFragment,\n    uniforms = {},\n    attributes = {} // For passing in custom attribs\n\n  }) {\n    this.gl = gl;\n    this.points = points;\n    this.count = points.length; // Create buffers\n\n    this.position = new Float32Array(this.count * 3 * 2);\n    this.prev = new Float32Array(this.count * 3 * 2);\n    this.next = new Float32Array(this.count * 3 * 2);\n    const side = new Float32Array(this.count * 1 * 2);\n    const uv = new Float32Array(this.count * 2 * 2);\n    const index = new Uint16Array((this.count - 1) * 3 * 2); // Set static buffers\n\n    for (let i = 0; i < this.count; i++) {\n      side.set([-1, 1], i * 2);\n      const v = i / (this.count - 1);\n      uv.set([0, v, 1, v], i * 4);\n      if (i === this.count - 1) continue;\n      const ind = i * 2;\n      index.set([ind + 0, ind + 1, ind + 2], (ind + 0) * 3);\n      index.set([ind + 2, ind + 1, ind + 3], (ind + 1) * 3);\n    }\n\n    const geometry = this.geometry = new Geometry_Geometry(gl, Object.assign(attributes, {\n      position: {\n        size: 3,\n        data: this.position\n      },\n      prev: {\n        size: 3,\n        data: this.prev\n      },\n      next: {\n        size: 3,\n        data: this.next\n      },\n      side: {\n        size: 1,\n        data: side\n      },\n      uv: {\n        size: 2,\n        data: uv\n      },\n      index: {\n        size: 1,\n        data: index\n      }\n    })); // Populate dynamic buffers\n\n    this.updateGeometry();\n    if (!uniforms.uResolution) this.resolution = uniforms.uResolution = {\n      value: new Vec2_Vec2()\n    };\n    if (!uniforms.uDPR) this.dpr = uniforms.uDPR = {\n      value: 1\n    };\n    if (!uniforms.uThickness) this.thickness = uniforms.uThickness = {\n      value: 1\n    };\n    if (!uniforms.uColor) this.color = uniforms.uColor = {\n      value: new Color_Color('#000')\n    };\n    if (!uniforms.uMiter) this.miter = uniforms.uMiter = {\n      value: 1\n    }; // Set size uniforms' values\n\n    this.resize();\n    const program = this.program = new Program(gl, {\n      vertex,\n      fragment,\n      uniforms\n    });\n    this.mesh = new Mesh_Mesh(gl, {\n      geometry,\n      program\n    });\n  }\n\n  updateGeometry() {\n    this.points.forEach((p, i) => {\n      p.toArray(this.position, i * 3 * 2);\n      p.toArray(this.position, i * 3 * 2 + 3);\n\n      if (!i) {\n        // If first point, calculate prev using the distance to 2nd point\n        tmp.copy(p).sub(this.points[i + 1]).add(p);\n        tmp.toArray(this.prev, i * 3 * 2);\n        tmp.toArray(this.prev, i * 3 * 2 + 3);\n      } else {\n        p.toArray(this.next, (i - 1) * 3 * 2);\n        p.toArray(this.next, (i - 1) * 3 * 2 + 3);\n      }\n\n      if (i === this.points.length - 1) {\n        // If last point, calculate next using distance to 2nd last point\n        tmp.copy(p).sub(this.points[i - 1]).add(p);\n        tmp.toArray(this.next, i * 3 * 2);\n        tmp.toArray(this.next, i * 3 * 2 + 3);\n      } else {\n        p.toArray(this.prev, (i + 1) * 3 * 2);\n        p.toArray(this.prev, (i + 1) * 3 * 2 + 3);\n      }\n    });\n    this.geometry.attributes.position.needsUpdate = true;\n    this.geometry.attributes.prev.needsUpdate = true;\n    this.geometry.attributes.next.needsUpdate = true;\n  } // Only need to call if not handling resolution uniforms manually\n\n\n  resize() {\n    // Update automatic uniforms if not overridden\n    if (this.resolution) this.resolution.value.set(this.gl.canvas.width, this.gl.canvas.height);\n    if (this.dpr) this.dpr.value = this.gl.renderer.dpr;\n  }\n\n}\nconst Polyline_defaultVertex =\n/* glsl */\n`\n    precision highp float;\n\n    attribute vec3 position;\n    attribute vec3 next;\n    attribute vec3 prev;\n    attribute vec2 uv;\n    attribute float side;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    uniform vec2 uResolution;\n    uniform float uDPR;\n    uniform float uThickness;\n    uniform float uMiter;\n\n    varying vec2 vUv;\n\n    vec4 getPosition() {\n        mat4 mvp = projectionMatrix * modelViewMatrix;\n        vec4 current = mvp * vec4(position, 1);\n        vec4 nextPos = mvp * vec4(next, 1);\n        vec4 prevPos = mvp * vec4(prev, 1);\n\n        vec2 aspect = vec2(uResolution.x / uResolution.y, 1);    \n        vec2 currentScreen = current.xy / current.w * aspect;\n        vec2 nextScreen = nextPos.xy / nextPos.w * aspect;\n        vec2 prevScreen = prevPos.xy / prevPos.w * aspect;\n    \n        vec2 dir1 = normalize(currentScreen - prevScreen);\n        vec2 dir2 = normalize(nextScreen - currentScreen);\n        vec2 dir = normalize(dir1 + dir2);\n    \n        vec2 normal = vec2(-dir.y, dir.x);\n        normal /= mix(1.0, max(0.3, dot(normal, vec2(-dir1.y, dir1.x))), uMiter);\n        normal /= aspect;\n\n        float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n        float pixelWidth = current.w * pixelWidthRatio;\n        normal *= pixelWidth * uThickness;\n        current.xy -= normal * side;\n    \n        return current;\n    }\n\n    void main() {\n        vUv = uv;\n        gl_Position = getPosition();\n    }\n`;\nconst Polyline_defaultFragment =\n/* glsl */\n`\n    precision highp float;\n\n    uniform vec3 uColor;\n    \n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor.rgb = uColor;\n        gl_FragColor.a = 1.0;\n    }\n`;\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/Shadow.js\n\n\n\nclass Shadow_Shadow {\n  constructor(gl, {\n    light = new Camera_Camera(gl),\n    width = 1024,\n    height = width\n  }) {\n    this.gl = gl;\n    this.light = light;\n    this.target = new RenderTarget_RenderTarget(gl, {\n      width,\n      height\n    });\n    this.depthProgram = new Program(gl, {\n      vertex: Shadow_defaultVertex,\n      fragment: Shadow_defaultFragment,\n      cullFace: null\n    });\n    this.castMeshes = [];\n  }\n\n  add({\n    mesh,\n    receive = true,\n    cast = true,\n    vertex = Shadow_defaultVertex,\n    fragment = Shadow_defaultFragment,\n    uniformProjection = 'shadowProjectionMatrix',\n    uniformView = 'shadowViewMatrix',\n    uniformTexture = 'tShadow'\n  }) {\n    // Add uniforms to existing program\n    if (receive && !mesh.program.uniforms[uniformProjection]) {\n      mesh.program.uniforms[uniformProjection] = {\n        value: this.light.projectionMatrix\n      };\n      mesh.program.uniforms[uniformView] = {\n        value: this.light.viewMatrix\n      };\n      mesh.program.uniforms[uniformTexture] = {\n        value: this.target.texture\n      };\n    }\n\n    if (!cast) return;\n    this.castMeshes.push(mesh); // Store program for when switching between depth override\n\n    mesh.colorProgram = mesh.program; // Check if depth program already attached\n\n    if (mesh.depthProgram) return; // Use global depth override if nothing custom passed in\n\n    if (vertex === Shadow_defaultVertex && fragment === Shadow_defaultFragment) {\n      mesh.depthProgram = this.depthProgram;\n      return;\n    } // Create custom override program\n\n\n    mesh.depthProgram = new Program(gl, {\n      vertex,\n      fragment,\n      cullFace: null\n    });\n  }\n\n  render({\n    scene\n  }) {\n    // For depth render, replace program with depth override.\n    // Hide meshes not casting shadows.\n    scene.traverse(node => {\n      if (!node.draw) return;\n\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.depthProgram;\n      } else {\n        node.isForceVisibility = node.visible;\n        node.visible = false;\n      }\n    }); // Render the depth shadow map using the light as the camera\n\n    this.gl.renderer.render({\n      scene,\n      camera: this.light,\n      target: this.target\n    }); // Then switch the program back to the normal one\n\n    scene.traverse(node => {\n      if (!node.draw) return;\n\n      if (!!~this.castMeshes.indexOf(node)) {\n        node.program = node.colorProgram;\n      } else {\n        node.visible = node.isForceVisibility;\n      }\n    });\n  }\n\n}\nconst Shadow_defaultVertex =\n/* glsl */\n`\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\nconst Shadow_defaultFragment =\n/* glsl */\n`\n    precision highp float;\n\n    vec4 packRGBA (float v) {\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\n        return pack;\n    }\n\n    void main() {\n        gl_FragColor = packRGBA(gl_FragCoord.z);\n    }\n`;\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/KTXTexture.js\n // TODO: Support cubemaps\n// Generate textures using https://github.com/TimvanScherpenzeel/texture-compressor\n\nclass KTXTexture_KTXTexture extends Texture {\n  constructor(gl, {\n    buffer,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    anisotropy = 0\n  } = {}) {\n    super(gl, {\n      generateMipmaps: false,\n      wrapS,\n      wrapT,\n      anisotropy\n    });\n    if (buffer) return this.parseBuffer(buffer);\n  }\n\n  parseBuffer(buffer) {\n    const ktx = new KhronosTextureContainer(buffer);\n    ktx.mipmaps.isCompressedTexture = true; // Update texture\n\n    this.image = ktx.mipmaps;\n    this.internalFormat = ktx.glInternalFormat;\n    this.minFilter = ktx.numberOfMipmapLevels > 1 ? this.gl.NEAREST_MIPMAP_LINEAR : this.gl.LINEAR; // TODO: support cube maps\n    // ktx.numberOfFaces\n  }\n\n}\n\nfunction KhronosTextureContainer(buffer) {\n  const idCheck = [0xab, 0x4b, 0x54, 0x58, 0x20, 0x31, 0x31, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\n  const id = new Uint8Array(buffer, 0, 12);\n\n  for (let i = 0; i < id.length; i++) if (id[i] !== idCheck[i]) return console.error('File missing KTX identifier'); // TODO: Is this always 4? Tested: [android, macos]\n\n\n  const size = Uint32Array.BYTES_PER_ELEMENT;\n  const head = new DataView(buffer, 12, 13 * size);\n  const littleEndian = head.getUint32(0, true) === 0x04030201;\n  const glType = head.getUint32(1 * size, littleEndian);\n  if (glType !== 0) return console.warn('only compressed formats currently supported');\n  this.glInternalFormat = head.getUint32(4 * size, littleEndian);\n  let width = head.getUint32(6 * size, littleEndian);\n  let height = head.getUint32(7 * size, littleEndian);\n  this.numberOfFaces = head.getUint32(10 * size, littleEndian);\n  this.numberOfMipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));\n  const bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);\n  this.mipmaps = [];\n  let offset = 12 + 13 * 4 + bytesOfKeyValueData;\n\n  for (let level = 0; level < this.numberOfMipmapLevels; level++) {\n    const levelSize = new Int32Array(buffer, offset, 1)[0]; // size per face, since not supporting array cubemaps\n\n    offset += 4; // levelSize field\n\n    for (let face = 0; face < this.numberOfFaces; face++) {\n      const data = new Uint8Array(buffer, offset, levelSize);\n      this.mipmaps.push({\n        data,\n        width,\n        height\n      });\n      offset += levelSize;\n      offset += 3 - (levelSize + 3) % 4; // add padding for odd sized image\n    }\n\n    width = width >> 1;\n    height = height >> 1;\n  }\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/TextureLoader.js\n\n // For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\n\nlet cache = {};\nconst supportedExtensions = [];\nclass TextureLoader_TextureLoader {\n  static load(gl, {\n    src,\n    // string or object of extension:src key-values\n    // {\n    //     pvrtc: '...ktx',\n    //     s3tc: '...ktx',\n    //     etc: '...ktx',\n    //     etc1: '...ktx',\n    //     astc: '...ktx',\n    //     webp: '...webp',\n    //     jpg: '...jpg',\n    //     png: '...png',\n    // }\n    // Only props relevant to KTXTexture\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    anisotropy = 0,\n    // For regular images\n    format = gl.RGBA,\n    internalFormat = format,\n    generateMipmaps = true,\n    minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n    magFilter = gl.LINEAR,\n    premultiplyAlpha = false,\n    unpackAlignment = 4,\n    flipY = true\n  } = {}) {\n    const support = this.getSupportedExtensions(gl);\n    let ext = 'none'; // If src is string, determine which format from the extension\n\n    if (typeof src === 'string') {\n      ext = src.split('.').pop().split('?')[0].toLowerCase();\n    } // If src is object, use supported extensions and provided list to choose best option\n    // Get first supported match, so put in order of preference\n\n\n    if (typeof src === 'object') {\n      for (const prop in src) {\n        if (support.includes(prop.toLowerCase())) {\n          ext = prop.toLowerCase();\n          src = src[prop];\n          break;\n        }\n      }\n    } // Stringify props\n\n\n    const cacheID = src + wrapS + wrapT + anisotropy + format + internalFormat + generateMipmaps + minFilter + magFilter + premultiplyAlpha + unpackAlignment + flipY + gl.renderer.id; // Check cache for existing texture\n\n    if (cache[cacheID]) return cache[cacheID];\n    let texture;\n\n    switch (ext) {\n      case 'ktx':\n      case 'pvrtc':\n      case 's3tc':\n      case 'etc':\n      case 'etc1':\n      case 'astc':\n        // Load compressed texture using KTX format\n        texture = new KTXTexture_KTXTexture(gl, {\n          src,\n          wrapS,\n          wrapT,\n          anisotropy\n        });\n        texture.loaded = this.loadKTX(src, texture);\n        break;\n\n      case 'webp':\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n        texture = new Texture(gl, {\n          wrapS,\n          wrapT,\n          anisotropy,\n          format,\n          internalFormat,\n          generateMipmaps,\n          minFilter,\n          magFilter,\n          premultiplyAlpha,\n          unpackAlignment,\n          flipY\n        });\n        texture.loaded = this.loadImage(gl, src, texture);\n        break;\n\n      default:\n        console.warn('No supported format supplied');\n        texture = new Texture(gl);\n    }\n\n    texture.ext = ext;\n    cache[cacheID] = texture;\n    return texture;\n  }\n\n  static getSupportedExtensions(gl) {\n    if (supportedExtensions.length) return supportedExtensions;\n    const extensions = {\n      pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      s3tc: gl.renderer.getExtension('WEBGL_compressed_texture_s3tc') || gl.renderer.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc'),\n      etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\n      etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\n      astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc')\n    };\n\n    for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext); // Check for WebP support\n\n\n    if (detectWebP) supportedExtensions.push('webp'); // Formats supported by all\n\n    supportedExtensions.push('png', 'jpg');\n    return supportedExtensions;\n  }\n\n  static loadKTX(src, texture) {\n    return fetch(src).then(res => res.arrayBuffer()).then(buffer => texture.parseBuffer(buffer));\n  }\n\n  static loadImage(gl, src, texture) {\n    return decodeImage(src).then(imgBmp => {\n      // Catch non POT textures and update params to avoid errors\n      if (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height)) {\n        if (texture.generateMipmaps) texture.generateMipmaps = false;\n        if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\n        if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\n      }\n\n      texture.image = imgBmp; // For createImageBitmap, close once uploaded\n\n      texture.onUpdate = () => {\n        if (imgBmp.close) imgBmp.close();\n        texture.onUpdate = null;\n      };\n    });\n  }\n\n  static clearCache() {\n    cache = {};\n  }\n\n}\n\nfunction detectWebP() {\n  return document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\n\nfunction powerOfTwo(value) {\n  return Math.log2(value) % 1 === 0;\n}\n\nfunction decodeImage(src) {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.src = src; // Only chrome's implementation of createImageBitmap is fully supported\n\n    const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\n\n    if (!!window.createImageBitmap && isChrome) {\n      img.onload = () => {\n        createImageBitmap(img, {\n          imageOrientation: 'flipY',\n          premultiplyAlpha: 'none'\n        }).then(imgBmp => {\n          resolve(imgBmp);\n        });\n      };\n    } else {\n      img.onload = () => resolve(img);\n    }\n  });\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/GLTFAnimation.js\n\n\nconst tmpVec3A = new Vec3_Vec3();\nconst tmpVec3B = new Vec3_Vec3();\nconst tmpVec3C = new Vec3_Vec3();\nconst tmpVec3D = new Vec3_Vec3();\nconst tmpQuatA = new Quat_Quat();\nconst tmpQuatB = new Quat_Quat();\nconst tmpQuatC = new Quat_Quat();\nconst tmpQuatD = new Quat_Quat();\nclass GLTFAnimation {\n  constructor(data, weight = 1) {\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = weight; // Set to false to not apply modulo to elapsed against duration\n\n    this.loop = true; // Get duration from largest final time in all channels\n\n    this.duration = data.reduce((a, {\n      times\n    }) => Math.max(a, times[times.length - 1]), 0);\n  }\n\n  update(totalWeight = 1, isSet) {\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration);\n    this.data.forEach(({\n      node,\n      transform,\n      interpolation,\n      times,\n      values\n    }) => {\n      // Get index of two time values elapsed is between\n      const prevIndex = Math.max(1, times.findIndex(t => t > elapsed)) - 1;\n      const nextIndex = prevIndex + 1; // Get linear blend/alpha between the two\n\n      let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n      if (interpolation === 'STEP') alpha = 0;\n      let prevVal = tmpVec3A;\n      let prevTan = tmpVec3B;\n      let nextTan = tmpVec3C;\n      let nextVal = tmpVec3D;\n      let size = 3;\n\n      if (transform === 'quaternion') {\n        prevVal = tmpQuatA;\n        prevTan = tmpQuatB;\n        nextTan = tmpQuatC;\n        nextVal = tmpQuatD;\n        size = 4;\n      }\n\n      if (interpolation === 'CUBICSPLINE') {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n        prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n        nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n        nextVal.fromArray(values, nextIndex * size * 3 + size * 1); // interpolate for final value\n\n        prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n        if (size === 4) prevVal.normalize();\n      } else {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size);\n        nextVal.fromArray(values, nextIndex * size); // interpolate for final value\n\n        if (size === 4) prevVal.slerp(nextVal, alpha);else prevVal.lerp(nextVal, alpha);\n      } // interpolate between multiple possible animations\n\n\n      if (size === 4) node[transform].slerp(prevVal, weight);else node[transform].lerp(prevVal, weight);\n    });\n  }\n\n  cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const s2 = 3 * t2 - 2 * t3;\n    const s3 = t3 - t2;\n    const s0 = 1 - s2;\n    const s1 = s3 - t2 + t;\n\n    for (let i = 0; i < prevVal.length; i++) {\n      prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n    }\n\n    return prevVal;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/GLTFSkin.js\n\n\n\nconst GLTFSkin_tempMat4 = new Mat4_Mat4();\nclass GLTFSkin_GLTFSkin extends Mesh_Mesh {\n  constructor(gl, {\n    skeleton,\n    geometry,\n    program,\n    mode = gl.TRIANGLES\n  } = {}) {\n    super(gl, {\n      geometry,\n      program,\n      mode\n    });\n    this.skeleton = skeleton;\n    this.program = program;\n    this.createBoneTexture();\n    this.animations = [];\n  }\n\n  createBoneTexture() {\n    if (!this.skeleton.joints.length) return;\n    const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n    this.boneMatrices = new Float32Array(size * size * 4);\n    this.boneTextureSize = size;\n    this.boneTexture = new Texture(this.gl, {\n      image: this.boneMatrices,\n      generateMipmaps: false,\n      type: this.gl.FLOAT,\n      internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA16F : this.gl.RGBA,\n      flipY: false,\n      width: size\n    });\n  } // addAnimation(data) {\n  //     const animation = new Animation({ objects: this.bones, data });\n  //     this.animations.push(animation);\n  //     return animation;\n  // }\n  // updateAnimations() {\n  //     // Calculate combined animation weight\n  //     let total = 0;\n  //     this.animations.forEach((animation) => (total += animation.weight));\n  //     this.animations.forEach((animation, i) => {\n  //         // force first animation to set in order to reset frame\n  //         animation.update(total, i === 0);\n  //     });\n  // }\n\n\n  updateUniforms() {\n    // Update bone texture\n    this.skeleton.joints.forEach((bone, i) => {\n      // Find difference between current and bind pose\n      GLTFSkin_tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n      this.boneMatrices.set(GLTFSkin_tempMat4, i * 16);\n    });\n    if (this.boneTexture) this.boneTexture.needsUpdate = true;\n  }\n\n  draw({\n    camera\n  } = {}) {\n    if (!this.program.uniforms.boneTexture) {\n      Object.assign(this.program.uniforms, {\n        boneTexture: {\n          value: this.boneTexture\n        },\n        boneTextureSize: {\n          value: this.boneTextureSize\n        }\n      });\n    }\n\n    this.updateUniforms(); // Switch this world matrix with root node's to populate uniforms\n\n    const _worldMatrix = this.worldMatrix;\n    this.worldMatrix = this.skeleton.skeleton.worldMatrix;\n    super.draw({\n      camera\n    });\n    this.worldMatrix = _worldMatrix;\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/extras/GLTFLoader.js\n\n\n\n\n\n\n // Supports\n// [x] Geometry\n// [ ] Sparse support\n// [x] Nodes and Hierarchy\n// [ ] Morph Targets\n// [x] Skins\n// [ ] Materials\n// [ ] Textures\n// [x] Animation\n// [ ] Cameras\n// [ ] Extensions\n// TODO: Sparse accessor packing? For morph targets basically\n// TODO: init accessor missing bufferView with 0s\n// TODO: morph target animations\n\nconst TYPE_ARRAY = {\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst TYPE_SIZE = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nconst TRANSFORMS = {\n  translation: 'position',\n  rotation: 'quaternion',\n  scale: 'scale'\n};\nclass GLTFLoader_GLTFLoader {\n  static async load(gl, src) {\n    const dir = src.split('/').slice(0, -1).join('/') + '/'; // load main description json\n\n    const desc = await fetch(src).then(res => res.json());\n    if (desc.asset === undefined || desc.asset.version[0] < 2) console.warn('Only GLTF >=2.0 supported. Attempting to parse.'); // Load buffers async\n\n    const buffers = await this.loadBuffers(desc, dir); // Create gl buffers from bufferViews\n\n    const bufferViews = this.parseBufferViews(gl, desc, buffers); // Create geometries for each mesh primitive\n\n    const meshes = this.parseMeshes(gl, desc, bufferViews); // Fetch the inverse bind matrices for skeleton joints\n\n    const skins = this.parseSkins(gl, desc, bufferViews); // Create transforms, meshes and hierarchy\n\n    const nodes = this.parseNodes(gl, desc, meshes, skins); // Place nodes in skeletons\n\n    this.populateSkins(skins, nodes); // Create animation handlers\n\n    const animations = this.parseAnimations(gl, desc, nodes, bufferViews); // Get top level nodes for each scene\n\n    const scenes = this.parseScenes(desc, nodes);\n    const scene = scenes[desc.scene];\n    return {\n      json: desc,\n      buffers,\n      bufferViews,\n      meshes,\n      nodes,\n      animations,\n      scenes,\n      scene\n    };\n  } // Threejs GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n\n\n  static resolveURI(uri, dir) {\n    // Invalid URI\n    if (typeof uri !== 'string' || uri === '') return ''; // Host Relative URI\n\n    if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n      dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    } // Absolute URI http://, https://, //\n\n\n    if (/^(https?:)?\\/\\//i.test(uri)) return uri; // Data URI\n\n    if (/^data:.*,.*$/i.test(uri)) return uri; // Blob URI\n\n    if (/^blob:.*$/i.test(uri)) return uri; // Relative URI\n\n    return dir + uri;\n  }\n\n  static async loadBuffers(desc, dir) {\n    return await Promise.all(desc.buffers.map(buffer => {\n      const uri = this.resolveURI(buffer.uri, dir);\n      return fetch(uri).then(res => res.arrayBuffer());\n    }));\n  }\n\n  static parseBufferViews(gl, desc, buffers) {\n    // Clone to leave description pure\n    const bufferViews = desc.bufferViews.map(o => Object.assign({}, o));\n    desc.meshes.forEach(({\n      primitives\n    }) => {\n      primitives.forEach(({\n        attributes,\n        indices\n      }) => {\n        // Flag bufferView as an attribute, so it knows to create a gl buffer\n        for (let attr in attributes) bufferViews[desc.accessors[attributes[attr]].bufferView].isAttribute = true;\n\n        if (indices === undefined) return;\n        bufferViews[desc.accessors[indices].bufferView].isAttribute = true; // Make sure indices bufferView have a target property for gl buffer binding\n\n        bufferViews[desc.accessors[indices].bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n      });\n    }); // Get componentType of each bufferView from the accessors\n\n    desc.accessors.forEach(({\n      bufferView: i,\n      componentType\n    }) => {\n      bufferViews[i].componentType = componentType;\n    }); // Push each bufferView to the GPU as a separate buffer\n\n    bufferViews.forEach(({\n      buffer: bufferIndex,\n      // required\n      byteOffset = 0,\n      // optional\n      byteLength,\n      // required\n      byteStride,\n      // optional\n      target = gl.ARRAY_BUFFER,\n      // optional, added above for elements\n      name,\n      // optional\n      extensions,\n      // optional\n      extras,\n      // optional\n      componentType,\n      // required, added from accessor above\n      isAttribute\n    }, i) => {\n      const TypeArray = TYPE_ARRAY[componentType];\n      const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n      const data = new TypeArray(buffers[bufferIndex], byteOffset, byteLength / elementBytes);\n      bufferViews[i].data = data; // Create gl buffers for the bufferView, pushing it to the GPU\n\n      if (!isAttribute) return;\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(target, buffer);\n      gl.renderer.state.boundBuffer = buffer;\n      gl.bufferData(target, data, gl.STATIC_DRAW);\n      bufferViews[i].buffer = buffer;\n    });\n    return bufferViews;\n  }\n\n  static parseMeshes(gl, desc, bufferViews) {\n    return desc.meshes.map(({\n      primitives,\n      // required\n      weights,\n      // optional\n      name,\n      // optional\n      extensions,\n      // optional\n      extras // optional\n\n    }) => {\n      return {\n        primitives: this.parsePrimitives(gl, primitives, desc, bufferViews),\n        weights,\n        name\n      };\n    });\n  }\n\n  static parseSkins(gl, desc, bufferViews) {\n    if (!desc.skins) return null;\n    return desc.skins.map(({\n      inverseBindMatrices,\n      // optional\n      skeleton,\n      // optional\n      joints // required\n      // name,\n      // extensions,\n      // extras,\n\n    }) => {\n      return {\n        inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n        skeleton,\n        joints\n      };\n    });\n  }\n\n  static populateSkins(skins, nodes) {\n    if (!skins) return;\n    skins.forEach(skin => {\n      skin.joints = skin.joints.map((i, index) => {\n        const joint = nodes[i];\n        joint.bindInverse = new Mat4_Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n        return joint;\n      });\n      skin.skeleton = nodes[skin.skeleton];\n    });\n  }\n\n  static parsePrimitives(gl, primitives, desc, bufferViews) {\n    return primitives.map(({\n      attributes,\n      // required\n      indices,\n      // optional\n      material,\n      // optional\n      mode = 4,\n      // optional\n      targets,\n      // optional\n      extensions,\n      // optional\n      extras // optional\n\n    }) => {\n      const geometry = new Geometry_Geometry(gl); // Add each attribute found in primitive\n\n      for (let attr in attributes) {\n        geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n      } // Add index attribute if found\n\n\n      if (indices !== undefined) geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews)); // TODO: materials\n\n      const program = new NormalProgram(gl);\n      return {\n        geometry,\n        program,\n        mode\n      };\n    });\n  }\n\n  static parseAccessor(index, desc, bufferViews) {\n    // TODO: init missing bufferView with 0s\n    // TODO: support sparse\n    const {\n      bufferView: bufferViewIndex,\n      // optional\n      byteOffset = 0,\n      // optional\n      componentType,\n      // required\n      normalized = false,\n      // optional\n      count,\n      // required\n      type,\n      // required\n      min,\n      // optional\n      max,\n      // optional\n      sparse // optional\n      // name, // optional\n      // extensions, // optional\n      // extras, // optional\n\n    } = desc.accessors[index];\n    const {\n      data,\n      // attached in parseBufferViews\n      buffer,\n      // replaced to be the actual GL buffer\n      // byteOffset = 0, // applied in parseBufferViews\n      // byteLength, // applied in parseBufferViews\n      byteStride = 0,\n      target // name,\n      // extensions,\n      // extras,\n\n    } = bufferViews[bufferViewIndex];\n    const size = TYPE_SIZE[type]; // Return attribute data\n\n    return {\n      data,\n      // Optional. Used for computing bounds if no min/max\n      size,\n      type: componentType,\n      normalized,\n      buffer,\n      stride: byteStride,\n      offset: byteOffset,\n      count,\n      min,\n      max\n    };\n  }\n\n  static parseNodes(gl, desc, meshes, skins) {\n    const nodes = desc.nodes.map(({\n      camera,\n      // optional\n      children,\n      // optional\n      skin: skinIndex,\n      // optional\n      matrix,\n      // optional\n      mesh: meshIndex,\n      // optional\n      rotation,\n      // optional\n      scale,\n      // optional\n      translation,\n      // optional\n      weights,\n      // optional\n      name,\n      // optional\n      extensions,\n      // optional\n      extras // optional\n\n    }) => {\n      const node = new Transform_Transform();\n      if (name) node.name = name; // Apply transformations\n\n      if (matrix) {\n        node.matrix.copy(matrix);\n        node.decompose();\n      } else {\n        if (rotation) node.quaternion.copy(rotation);\n        if (scale) node.scale.copy(scale);\n        if (translation) node.position.copy(translation);\n      } // add mesh if included\n\n\n      if (meshIndex !== undefined) {\n        meshes[meshIndex].primitives.forEach(({\n          geometry,\n          program,\n          mode\n        }) => {\n          if (typeof skinIndex === 'number') {\n            const skin = new GLTFSkin_GLTFSkin(gl, {\n              skeleton: skins[skinIndex],\n              geometry,\n              program,\n              mode\n            });\n            skin.setParent(node);\n          } else {\n            const mesh = new Mesh_Mesh(gl, {\n              geometry,\n              program,\n              mode\n            });\n            mesh.setParent(node);\n          }\n        });\n      }\n\n      return node;\n    });\n    desc.nodes.forEach(({\n      children = []\n    }, i) => {\n      // Set hierarchy now all nodes created\n      children.forEach(childIndex => {\n        nodes[childIndex].setParent(nodes[i]);\n      });\n    });\n    return nodes;\n  }\n\n  static parseAnimations(gl, desc, nodes, bufferViews) {\n    if (!desc.animations) return null;\n    return desc.animations.map(({\n      channels,\n      // required\n      samplers,\n      // required\n      name // optional\n      // extensions, // optional\n      // extras,  // optional\n\n    }) => {\n      const data = channels.map(({\n        sampler: samplerIndex,\n        // required\n        target // required\n        // extensions, // optional\n        // extras, // optional\n\n      }) => {\n        const {\n          input: inputIndex,\n          // required\n          interpolation = 'LINEAR',\n          output: outputIndex // required\n          // extensions, // optional\n          // extras, // optional\n\n        } = samplers[samplerIndex];\n        const {\n          node: nodeIndex,\n          // optional - TODO: when is it not included?\n          path // required\n          // extensions, // optional\n          // extras, // optional\n\n        } = target;\n        const node = nodes[nodeIndex];\n        const transform = TRANSFORMS[path];\n        const timesAcc = this.parseAccessor(inputIndex, desc, bufferViews);\n        const times = timesAcc.data.slice(timesAcc.offset / 4, timesAcc.offset / 4 + timesAcc.count * timesAcc.size);\n        const valuesAcc = this.parseAccessor(outputIndex, desc, bufferViews);\n        const values = valuesAcc.data.slice(valuesAcc.offset / 4, valuesAcc.offset / 4 + valuesAcc.count * valuesAcc.size);\n        return {\n          node,\n          transform,\n          interpolation,\n          times,\n          values\n        };\n      });\n      return {\n        name,\n        animation: new GLTFAnimation(data)\n      };\n    });\n  }\n\n  static parseScenes(desc, nodes) {\n    return desc.scenes.map(({\n      nodes: nodesIndices = [],\n      name,\n      // optional\n      extensions,\n      extras\n    }) => {\n      return nodesIndices.map(i => nodes[i]);\n    });\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/common/lib/ogl/index.mjs\n// Core\n\n\n\n\n\n\n\n\n\n// Maths\n\n\n\n\n\n\n\n\n\n// Extras\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./graphics/common/lib/phong.js\nconst phong_vertex = `\n  precision highp float;\n\n  attribute vec3 position;\n  attribute vec3 normal;\n  uniform mat4 modelViewMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform mat3 normalMatrix;\n  uniform vec3 cameraPosition;\n\n  varying vec3 vNormal;\n  varying vec3 vPos;\n  varying vec3 vCameraPos;\n\n  void main() {\n    vec4 pos = modelViewMatrix * vec4(position, 1.0);\n    vPos = pos.xyz;\n    vCameraPos = (viewMatrix * vec4(cameraPosition, 1.0)).xyz;\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = projectionMatrix * pos;\n  }\n`;\nconst phong_fragment = `\n  precision highp float;\n\n  #define MAX_LIGHT_COUNT 16\n  uniform mat4 viewMatrix;\n\n  uniform vec3 ambientLight;\n  uniform vec3 directionalLightDirection[MAX_LIGHT_COUNT];\n  uniform vec3 directionalLightColor[MAX_LIGHT_COUNT];\n  uniform vec3 pointLightColor[MAX_LIGHT_COUNT];\n  uniform vec3 pointLightPosition[MAX_LIGHT_COUNT];\n  uniform vec3 pointLightDecay[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightColor[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightDirection[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightPosition[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightDecay[MAX_LIGHT_COUNT];\n  uniform float spotLightAngle[MAX_LIGHT_COUNT];\n\n  uniform vec3 materialReflection;\n  uniform float shininess;\n  uniform float specularFactor;\n\n  varying vec3 vNormal;\n  varying vec3 vPos;\n  varying vec3 vCameraPos;\n\n  float getSpecular(vec3 dir, vec3 normal, vec3 eye) {\n    vec3 reflectionLight = reflect(-dir, normal);\n    float eyeCos = max(dot(eye, reflectionLight), 0.0);\n    return specularFactor *  pow(eyeCos, shininess);\n  }\n\n  vec4 phongReflection(vec3 pos, vec3 normal, vec3 eye) {\n    float specular = 0.0;\n    vec3 diffuse = vec3(0);\n    \n    // \n    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {\n      vec3 dir = directionalLightDirection[i];\n      if(dir.x == 0.0 && dir.y == 0.0 && dir.z == 0.0) continue;\n      vec4 d = viewMatrix * vec4(dir, 0.0);\n      dir = normalize(-d.xyz);\n      float cos = max(dot(dir, normal), 0.0);\n      diffuse += cos * directionalLightColor[i];\n      specular += getSpecular(dir, normal, eye);\n    }\n\n    // \n    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {\n      vec3 decay = pointLightDecay[i];\n      if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;\n      vec3 dir = (viewMatrix * vec4(pointLightPosition[i], 1.0)).xyz - pos;\n      float dis = length(dir);\n      dir = normalize(dir);\n      float cos = max(dot(dir, normal), 0.0);\n      float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));\n      diffuse += d * cos * pointLightColor[i];\n      specular += getSpecular(dir, normal, eye);\n    }\n\n    // \n    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {\n      vec3 decay = spotLightDecay[i];\n      if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;\n\n      vec3 dir = (viewMatrix * vec4(spotLightPosition[i], 1.0)).xyz - pos;\n      float dis = length(dir);\n      dir = normalize(dir);\n\n      // \n      vec3 spotDir = (viewMatrix * vec4(spotLightDirection[i], 0.0)).xyz;\n      // \n      float ang = cos(spotLightAngle[i]);\n      float r = step(ang, dot(dir, normalize(-spotDir)));\n\n      float cos = max(dot(dir, normal), 0.0);\n      float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));\n      diffuse += r * d * cos * spotLightColor[i];\n      specular += r * getSpecular(dir, normal, eye);\n    }\n\n    return vec4(diffuse, specular);\n  }\n\n  void main() {\n    vec3 eyeDirection = normalize(vCameraPos - vPos);\n    vec4 phong = phongReflection(vPos, vNormal, eyeDirection);\n\n    // \n    gl_FragColor.rgb = phong.w + (phong.xyz + ambientLight) * materialReflection;\n    gl_FragColor.a = 1.0;\n  }\n`;\nclass Phong {\n  constructor(ambientLight = [0.5, 0.5, 0.5]) {\n    this.ambientLight = ambientLight;\n    this.directionalLights = new Set();\n    this.pointLights = new Set();\n    this.spotLights = new Set();\n  }\n\n  addLight(light) {\n    const {\n      position,\n      direction,\n      color,\n      decay,\n      angle\n    } = light;\n    if (!position && !direction) throw new TypeError('invalid light');\n    light.color = color || [1, 1, 1];\n    if (!position) this.directionalLights.add(light);else {\n      light.decay = decay || [0, 0, 1];\n\n      if (!angle) {\n        this.pointLights.add(light);\n      } else {\n        this.spotLights.add(light);\n      }\n    }\n  }\n\n  removeLight(light) {\n    if (this.directionalLights.has(light)) this.directionalLights.delete(light);else if (this.pointLights.has(light)) this.pointLights.delete(light);else if (this.spotLights.has(light)) this.spotLights.delete(light);\n  }\n\n  get uniforms() {\n    const MAX_LIGHT_COUNT = 16; // 16\n\n    this._lightData = this._lightData || {};\n    const lightData = this._lightData;\n    lightData.directionalLightDirection = lightData.directionalLightDirection || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.directionalLightColor = lightData.directionalLightColor || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.pointLightPosition = lightData.pointLightPosition || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.pointLightColor = lightData.pointLightColor || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.pointLightDecay = lightData.pointLightDecay || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.spotLightDirection = lightData.spotLightDirection || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.spotLightPosition = lightData.spotLightPosition || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.spotLightColor = lightData.spotLightColor || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.spotLightDecay = lightData.spotLightDecay || {\n      value: new Float32Array(MAX_LIGHT_COUNT * 3)\n    };\n    lightData.spotLightAngle = lightData.spotLightAngle || {\n      value: new Float32Array(MAX_LIGHT_COUNT)\n    };\n    [...this.directionalLights].forEach((light, idx) => {\n      lightData.directionalLightDirection.value.set(light.direction, idx * 3);\n      lightData.directionalLightColor.value.set(light.color, idx * 3);\n    });\n    [...this.pointLights].forEach((light, idx) => {\n      lightData.pointLightPosition.value.set(light.position, idx * 3);\n      lightData.pointLightColor.value.set(light.color, idx * 3);\n      lightData.pointLightDecay.value.set(light.decay, idx * 3);\n    });\n    [...this.spotLights].forEach((light, idx) => {\n      lightData.spotLightPosition.value.set(light.position, idx * 3);\n      lightData.spotLightColor.value.set(light.color, idx * 3);\n      lightData.spotLightDecay.value.set(light.decay, idx * 3);\n      lightData.spotLightDirection.value.set(light.direction, idx * 3);\n      lightData.spotLightAngle.value[idx] = light.angle;\n    });\n    return {\n      ambientLight: {\n        value: this.ambientLight\n      },\n      ...lightData\n    };\n  }\n\n}\nclass Material {\n  constructor(reflection, specularFactor = 0, shininess = 50) {\n    this.reflection = reflection;\n    this.specularFactor = specularFactor;\n    this.shininess = shininess;\n  }\n\n  get uniforms() {\n    return {\n      materialReflection: {\n        value: this.reflection\n      },\n      specularFactor: {\n        value: this.specularFactor\n      },\n      shininess: {\n        value: this.shininess\n      }\n    };\n  }\n\n}\n// CONCATENATED MODULE: ./graphics/normal-maps/cube/cube.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vertex\", function() { return cube_vertex; });\n\n\nconst cube_vertex = `#version 300 es\n  precision highp float;\n\n  in vec3 position;\n  in vec3 normal;\n  in vec2 uv;\n  in vec3 tang;\n  in vec3 bitang;\n\n  uniform mat4 modelMatrix;\n  uniform mat4 modelViewMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform mat3 normalMatrix;\n  uniform vec3 cameraPosition;\n\n  out vec3 vNormal;\n  out vec3 vPos;\n  out vec2 vUv;\n  out vec3 vCameraPos;\n  out mat3 vTBN;\n\n  void main() {\n    vec4 pos = modelViewMatrix * vec4(position, 1.0);\n    vPos = pos.xyz;\n    vUv = uv;\n    vCameraPos = (viewMatrix * vec4(cameraPosition, 1.0)).xyz;\n    vNormal = normalize(normalMatrix * normal);\n\n    vec3 N = vNormal;\n    vec3 T = normalize(normalMatrix * tang);\n    vec3 B = normalize(normalMatrix * bitang);\n\n    vTBN = mat3(T, B, N);\n    \n    gl_Position = projectionMatrix * pos;\n  }\n`;\nconst cube_fragment = `#version 300 es\n  precision highp float;\n\n  #define MAX_LIGHT_COUNT 16\n  uniform mat4 viewMatrix;\n\n  uniform vec3 ambientLight;\n  uniform vec3 directionalLightDirection[MAX_LIGHT_COUNT];\n  uniform vec3 directionalLightColor[MAX_LIGHT_COUNT];\n  uniform vec3 pointLightColor[MAX_LIGHT_COUNT];\n  uniform vec3 pointLightPosition[MAX_LIGHT_COUNT];\n  uniform vec3 pointLightDecay[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightColor[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightDirection[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightPosition[MAX_LIGHT_COUNT];\n  uniform vec3 spotLightDecay[MAX_LIGHT_COUNT];\n  uniform float spotLightAngle[MAX_LIGHT_COUNT];\n\n  uniform vec3 materialReflection;\n  uniform float shininess;\n  uniform float specularFactor;\n\n  uniform sampler2D tNormal;\n\n  in vec3 vNormal;\n  in vec3 vPos;\n  in vec2 vUv;\n  in vec3 vCameraPos;\n  in mat3 vTBN;\n\n  out vec4 FragColor;\n\n  float getSpecular(vec3 dir, vec3 normal, vec3 eye) {\n    vec3 reflectionLight = reflect(-dir, normal);\n    float eyeCos = max(dot(eye, reflectionLight), 0.0);\n    return specularFactor *  pow(eyeCos, shininess);\n  }\n\n  vec4 phongReflection(vec3 pos, vec3 normal, vec3 eye) {\n    float specular = 0.0;\n    vec3 diffuse = vec3(0);\n    \n    // \n    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {\n      vec3 dir = directionalLightDirection[i];\n      if(dir.x == 0.0 && dir.y == 0.0 && dir.z == 0.0) continue;\n      vec4 d = viewMatrix * vec4(dir, 0.0);\n      dir = normalize(-d.xyz);\n      float cos = max(dot(dir, normal), 0.0);\n      diffuse += cos * directionalLightColor[i];\n      specular += getSpecular(dir, normal, eye);\n    }\n\n    // \n    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {\n      vec3 decay = pointLightDecay[i];\n      if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;\n      vec3 dir = (viewMatrix * vec4(pointLightPosition[i], 1.0)).xyz - pos;\n      float dis = length(dir);\n      dir = normalize(dir);\n      float cos = max(dot(dir, normal), 0.0);\n      float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));\n      diffuse += d * cos * pointLightColor[i];\n      specular += getSpecular(dir, normal, eye);\n    }\n\n    // \n    for(int i = 0; i < MAX_LIGHT_COUNT; i++) {\n      vec3 decay = spotLightDecay[i];\n      if(decay.x == 0.0 && decay.y == 0.0 && decay.z == 0.0) continue;\n\n      vec3 dir = (viewMatrix * vec4(spotLightPosition[i], 1.0)).xyz - pos;\n      float dis = length(dir);\n      dir = normalize(dir);\n\n      // \n      vec3 spotDir = (viewMatrix * vec4(spotLightDirection[i], 0.0)).xyz;\n      // \n      float ang = cos(spotLightAngle[i]);\n      float r = step(ang, dot(dir, normalize(-spotDir)));\n\n      float cos = max(dot(dir, normal), 0.0);\n      float d = min(1.0, 1.0 / (decay.x * pow(dis, 2.0) + decay.y * dis + decay.z));\n      diffuse += r * d * cos * spotLightColor[i];\n      specular += r * getSpecular(dir, normal, eye);\n    }\n\n    return vec4(diffuse, specular);\n  }\n\n  // vec3 getNormal() {\n  //   vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;\n  //   return normalize(vTBN * n);\n  // }\n\n  vec3 getNormal() {\n    vec3 pos_dx = dFdx(vPos.xyz);\n    vec3 pos_dy = dFdy(vPos.xyz);\n    vec2 tex_dx = dFdx(vUv);\n    vec2 tex_dy = dFdy(vUv);\n\n    vec3 t = normalize(pos_dx * tex_dy.t - pos_dy * tex_dx.t);\n    vec3 b = normalize(-pos_dx * tex_dy.s + pos_dy * tex_dx.s);\n    mat3 tbn = mat3(t, b, normalize(vNormal));\n\n    vec3 n = texture(tNormal, vUv).rgb * 2.0 - 1.0;\n    return normalize(tbn * n);\n  }\n\n  void main() {\n    vec3 eyeDirection = normalize(vCameraPos - vPos);\n    vec3 normal = getNormal();\n    vec4 phong = phongReflection(vPos, normal, eyeDirection);\n\n    // \n    FragColor.rgb = phong.w + (phong.xyz + ambientLight) * materialReflection;\n    FragColor.a = 1.0;\n  }\n`;\nconst canvas = document.querySelector('canvas');\nconst renderer = new Renderer({\n  canvas,\n  width: 512,\n  height: 512,\n  antialias: true,\n  alpha: true\n});\nconst cube_gl = renderer.gl;\ncube_gl.clearColor(1, 1, 1, 1);\nconst cube_camera = new Camera_Camera(cube_gl, {\n  fov: 35\n});\ncube_camera.position.set(2, 2, 2);\ncube_camera.lookAt([0, 0, 0]);\nconst scene = new Transform_Transform();\nconst phong = new Phong();\nphong.addLight({\n  // color: [1, 0.5, 0.5],\n  direction: [0, -3, -3]\n});\nphong.addLight({\n  // color: [1, 0.5, 1],\n  direction: [0, 3, 3]\n});\nconst matrial = new Material(new Color_Color('#808080'));\n\nfunction loadTexture(src) {\n  const texture = new Texture(cube_gl);\n  return new Promise(resolve => {\n    const img = new Image();\n\n    img.onload = () => {\n      texture.image = img;\n      resolve(texture);\n    };\n\n    img.src = src;\n  });\n}\n\nfunction createTB(geometry) {\n  const {\n    position,\n    index,\n    uv\n  } = geometry.attributes;\n  if (!uv) throw new Error('NO uv.');\n\n  function getTBNTriangle(p1, p2, p3, uv1, uv2, uv3) {\n    const edge1 = new Vec3_Vec3().sub(p2, p1);\n    const edge2 = new Vec3_Vec3().sub(p3, p1);\n    const deltaUV1 = new Vec2_Vec2().sub(uv2, uv1);\n    const deltaUV2 = new Vec2_Vec2().sub(uv3, uv1);\n    const tang = new Vec3_Vec3();\n    const bitang = new Vec3_Vec3();\n    const f = 1.0 / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);\n    tang.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);\n    tang.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);\n    tang.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);\n    tang.normalize();\n    bitang.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);\n    bitang.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);\n    bitang.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);\n    bitang.normalize();\n    return {\n      tang,\n      bitang\n    };\n  }\n\n  const size = position.size;\n  if (size < 3) throw new Error('Error dimension.');\n  const len = position.data.length / size;\n  const tang = new Float32Array(len * 3);\n  const bitang = new Float32Array(len * 3);\n\n  for (let i = 0; i < index.data.length; i += 3) {\n    const i1 = index.data[i];\n    const i2 = index.data[i + 1];\n    const i3 = index.data[i + 2];\n    const p1 = [position.data[i1 * size], position.data[i1 * size + 1], position.data[i1 * size + 2]];\n    const p2 = [position.data[i2 * size], position.data[i2 * size + 1], position.data[i2 * size + 2]];\n    const p3 = [position.data[i3 * size], position.data[i3 * size + 1], position.data[i3 * size + 2]];\n    const u1 = [uv.data[i1 * 2], uv.data[i1 * 2 + 1]];\n    const u2 = [uv.data[i2 * 2], uv.data[i2 * 2 + 1]];\n    const u3 = [uv.data[i3 * 2], uv.data[i3 * 2 + 1]];\n    const {\n      tang: t,\n      bitang: b\n    } = getTBNTriangle(p1, p2, p3, u1, u2, u3);\n    tang.set(t, i1 * 3);\n    tang.set(t, i2 * 3);\n    tang.set(t, i3 * 3);\n    bitang.set(b, i1 * 3);\n    bitang.set(b, i2 * 3);\n    bitang.set(b, i3 * 3);\n  }\n\n  geometry.addAttribute('tang', {\n    data: tang,\n    size: 3\n  });\n  geometry.addAttribute('bitang', {\n    data: bitang,\n    size: 3\n  });\n  return geometry;\n}\n\n(async function () {\n  const normalMap = await loadTexture('../../assets/normal_map.png');\n  const program = new Program(cube_gl, {\n    vertex: cube_vertex,\n    fragment: cube_fragment,\n    uniforms: { ...phong.uniforms,\n      ...matrial.uniforms,\n      tNormal: {\n        value: normalMap\n      }\n    }\n  });\n  const geometry = new Box_Box(cube_gl);\n  createTB(geometry);\n  const cube = new Mesh_Mesh(cube_gl, {\n    geometry,\n    program\n  });\n  cube.setParent(scene);\n  cube.rotation.x = -Math.PI / 2; // renderer.render({scene, camera});\n\n  const controls = new Orbit(cube_camera);\n  requestAnimationFrame(update);\n\n  function update() {\n    requestAnimationFrame(update);\n    controls.update();\n    renderer.render({\n      scene,\n      camera: cube_camera\n    });\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ncmFwaGljcy9ub3JtYWwtbWFwcy9jdWJlL2N1YmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9tYXRoL2Z1bmN0aW9ucy9WZWMzRnVuYy5qcz8wZjQ3Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL21hdGgvVmVjMy5qcz9kNjM2Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2NvcmUvR2VvbWV0cnkuanM/Y2QzZiIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9jb3JlL1Byb2dyYW0uanM/ZGUwNCIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9jb3JlL1JlbmRlcmVyLmpzP2UyYTUiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9mdW5jdGlvbnMvVmVjNEZ1bmMuanM/NWY4ZSIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9tYXRoL2Z1bmN0aW9ucy9RdWF0RnVuYy5qcz8xOTJjIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL21hdGgvUXVhdC5qcz8yNzU0Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL21hdGgvZnVuY3Rpb25zL01hdDRGdW5jLmpzPzJiNDYiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9NYXQ0LmpzPzAxOTUiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9mdW5jdGlvbnMvRXVsZXJGdW5jLmpzP2JkYzYiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9FdWxlci5qcz82Y2E4Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2NvcmUvVHJhbnNmb3JtLmpzPzcxYWIiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvY29yZS9DYW1lcmEuanM/MjY1MSIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9tYXRoL2Z1bmN0aW9ucy9NYXQzRnVuYy5qcz8zNGY4Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL21hdGgvTWF0My5qcz9kMDc4Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2NvcmUvTWVzaC5qcz84MmMyIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2NvcmUvVGV4dHVyZS5qcz9iOTgwIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2NvcmUvUmVuZGVyVGFyZ2V0LmpzPzZjZTIiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9mdW5jdGlvbnMvQ29sb3JGdW5jLmpzPzg2MDQiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9Db2xvci5qcz8xOTE0Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL21hdGgvZnVuY3Rpb25zL1ZlYzJGdW5jLmpzPzM3NTkiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9WZWMyLmpzP2U0YzIiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvbWF0aC9WZWM0LmpzPzNmOTciLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL1BsYW5lLmpzP2MzMjEiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL0JveC5qcz9kNTA5Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9TcGhlcmUuanM/MjM5ZSIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9leHRyYXMvQ3lsaW5kZXIuanM/ZTVjMSIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9leHRyYXMvVHJpYW5nbGUuanM/ZTZhNCIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9leHRyYXMvVG9ydXMuanM/Nzk5ZiIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9leHRyYXMvT3JiaXQuanM/YjA1NiIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9leHRyYXMvUmF5Y2FzdC5qcz84NTViIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9DdXJ2ZS5qcz83OGI5Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9Qb3N0LmpzPzBlZWMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL0FuaW1hdGlvbi5qcz8wODJmIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9Ta2luLmpzP2NmYjEiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL1RleHQuanM/NjA0MCIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9leHRyYXMvTm9ybWFsUHJvZ3JhbS5qcz9iNTQ4Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9GbG93bWFwLmpzPzcwNGYiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL0dQR1BVLmpzPzFkNjkiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL1BvbHlsaW5lLmpzPzU4YjkiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL1NoYWRvdy5qcz82NjRjIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9LVFhUZXh0dXJlLmpzP2FjODAiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvZXh0cmFzL1RleHR1cmVMb2FkZXIuanM/YzcwMSIsIndlYnBhY2s6Ly8vLi9ncmFwaGljcy9jb21tb24vbGliL29nbC9leHRyYXMvR0xURkFuaW1hdGlvbi5qcz83NDI3Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9HTFRGU2tpbi5qcz8yZDNiIiwid2VicGFjazovLy8uL2dyYXBoaWNzL2NvbW1vbi9saWIvb2dsL2V4dHJhcy9HTFRGTG9hZGVyLmpzPzM2NDIiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9vZ2wvaW5kZXgubWpzPzY2OTIiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpY3MvY29tbW9uL2xpYi9waG9uZy5qcz9iNWY2Iiwid2VicGFjazovLy8uL2dyYXBoaWNzL25vcm1hbC1tYXBzL2N1YmUvY3ViZS5qcz81OWY3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVQU0lMT04gPSAwLjAwMDAwMTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIGxldCB4ID0gYlswXSAtIGFbMF07XG4gIGxldCB5ID0gYlsxXSAtIGFbMV07XG4gIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgbGV0IGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXTtcbiAgbGV0IGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIGxldCBheCA9IGFbMF07XG4gIGxldCBheSA9IGFbMV07XG4gIGxldCBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgbGV0IHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgbGV0IHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgbGV0IHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgbGV0IHV2eCA9IHF5ICogeiAtIHF6ICogeTtcbiAgbGV0IHV2eSA9IHF6ICogeCAtIHF4ICogejtcbiAgbGV0IHV2eiA9IHF4ICogeSAtIHF5ICogeDtcbiAgbGV0IHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5O1xuICBsZXQgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dno7XG4gIGxldCB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDtcbiAgbGV0IHcyID0gcXcgKiAyO1xuICB1dnggKj0gdzI7XG4gIHV2eSAqPSB3MjtcbiAgdXZ6ICo9IHcyO1xuICB1dXZ4ICo9IDI7XG4gIHV1dnkgKj0gMjtcbiAgdXV2eiAqPSAyO1xuICBvdXRbMF0gPSB4ICsgdXZ4ICsgdXV2eDtcbiAgb3V0WzFdID0geSArIHV2eSArIHV1dnk7XG4gIG91dFsyXSA9IHogKyB1dnogKyB1dXZ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuXG5leHBvcnQgY29uc3QgYW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHRlbXBBID0gWzAsIDAsIDBdO1xuICBjb25zdCB0ZW1wQiA9IFswLCAwLCAwXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgY29weSh0ZW1wQSwgYSk7XG4gICAgY29weSh0ZW1wQiwgYik7XG4gICAgbm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gICAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQik7XG4gICAgbGV0IGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpO1xuXG4gICAgaWYgKGNvc2luZSA+IDEuMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChjb3NpbmUgPCAtMS4wKSB7XG4gICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICAgIH1cbiAgfTtcbn0oKTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59IiwiaW1wb3J0ICogYXMgVmVjM0Z1bmMgZnJvbSAnLi9mdW5jdGlvbnMvVmVjM0Z1bmMuanMnO1xuZXhwb3J0IGNsYXNzIFZlYzMgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0geCwgeiA9IHgpIHtcbiAgICBzdXBlcih4LCB5LCB6KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzWzBdO1xuICB9XG5cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXNbMV07XG4gIH1cblxuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpc1syXTtcbiAgfVxuXG4gIHNldCB4KHYpIHtcbiAgICB0aGlzWzBdID0gdjtcbiAgfVxuXG4gIHNldCB5KHYpIHtcbiAgICB0aGlzWzFdID0gdjtcbiAgfVxuXG4gIHNldCB6KHYpIHtcbiAgICB0aGlzWzJdID0gdjtcbiAgfVxuXG4gIHNldCh4LCB5ID0geCwgeiA9IHgpIHtcbiAgICBpZiAoeC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkoeCk7XG4gICAgVmVjM0Z1bmMuc2V0KHRoaXMsIHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29weSh2KSB7XG4gICAgVmVjM0Z1bmMuY29weSh0aGlzLCB2KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZCh2YSwgdmIpIHtcbiAgICBpZiAodmIpIFZlYzNGdW5jLmFkZCh0aGlzLCB2YSwgdmIpO2Vsc2UgVmVjM0Z1bmMuYWRkKHRoaXMsIHRoaXMsIHZhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN1Yih2YSwgdmIpIHtcbiAgICBpZiAodmIpIFZlYzNGdW5jLnN1YnRyYWN0KHRoaXMsIHZhLCB2Yik7ZWxzZSBWZWMzRnVuYy5zdWJ0cmFjdCh0aGlzLCB0aGlzLCB2YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWx0aXBseSh2KSB7XG4gICAgaWYgKHYubGVuZ3RoKSBWZWMzRnVuYy5tdWx0aXBseSh0aGlzLCB0aGlzLCB2KTtlbHNlIFZlYzNGdW5jLnNjYWxlKHRoaXMsIHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGl2aWRlKHYpIHtcbiAgICBpZiAodi5sZW5ndGgpIFZlYzNGdW5jLmRpdmlkZSh0aGlzLCB0aGlzLCB2KTtlbHNlIFZlYzNGdW5jLnNjYWxlKHRoaXMsIHRoaXMsIDEgLyB2KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludmVyc2UodiA9IHRoaXMpIHtcbiAgICBWZWMzRnVuYy5pbnZlcnNlKHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENhbid0IHVzZSAnbGVuZ3RoJyBhcyBBcnJheS5wcm90b3R5cGUgdXNlcyBpdFxuXG5cbiAgbGVuKCkge1xuICAgIHJldHVybiBWZWMzRnVuYy5sZW5ndGgodGhpcyk7XG4gIH1cblxuICBkaXN0YW5jZSh2KSB7XG4gICAgaWYgKHYpIHJldHVybiBWZWMzRnVuYy5kaXN0YW5jZSh0aGlzLCB2KTtlbHNlIHJldHVybiBWZWMzRnVuYy5sZW5ndGgodGhpcyk7XG4gIH1cblxuICBzcXVhcmVkTGVuKCkge1xuICAgIHJldHVybiBWZWMzRnVuYy5zcXVhcmVkTGVuZ3RoKHRoaXMpO1xuICB9XG5cbiAgc3F1YXJlZERpc3RhbmNlKHYpIHtcbiAgICBpZiAodikgcmV0dXJuIFZlYzNGdW5jLnNxdWFyZWREaXN0YW5jZSh0aGlzLCB2KTtlbHNlIHJldHVybiBWZWMzRnVuYy5zcXVhcmVkTGVuZ3RoKHRoaXMpO1xuICB9XG5cbiAgbmVnYXRlKHYgPSB0aGlzKSB7XG4gICAgVmVjM0Z1bmMubmVnYXRlKHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY3Jvc3ModmEsIHZiKSB7XG4gICAgaWYgKHZiKSBWZWMzRnVuYy5jcm9zcyh0aGlzLCB2YSwgdmIpO2Vsc2UgVmVjM0Z1bmMuY3Jvc3ModGhpcywgdGhpcywgdmEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2NhbGUodikge1xuICAgIFZlYzNGdW5jLnNjYWxlKHRoaXMsIHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbm9ybWFsaXplKCkge1xuICAgIFZlYzNGdW5jLm5vcm1hbGl6ZSh0aGlzLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRvdCh2KSB7XG4gICAgcmV0dXJuIFZlYzNGdW5jLmRvdCh0aGlzLCB2KTtcbiAgfVxuXG4gIGVxdWFscyh2KSB7XG4gICAgcmV0dXJuIFZlYzNGdW5jLmV4YWN0RXF1YWxzKHRoaXMsIHYpO1xuICB9XG5cbiAgYXBwbHlNYXRyaXg0KG1hdDQpIHtcbiAgICBWZWMzRnVuYy50cmFuc2Zvcm1NYXQ0KHRoaXMsIHRoaXMsIG1hdDQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXBwbHlRdWF0ZXJuaW9uKHEpIHtcbiAgICBWZWMzRnVuYy50cmFuc2Zvcm1RdWF0KHRoaXMsIHRoaXMsIHEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYW5nbGUodikge1xuICAgIHJldHVybiBWZWMzRnVuYy5hbmdsZSh0aGlzLCB2KTtcbiAgfVxuXG4gIGxlcnAodiwgdCkge1xuICAgIFZlYzNGdW5jLmxlcnAodGhpcywgdGhpcywgdiwgdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFZlYzModGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSk7XG4gIH1cblxuICBmcm9tQXJyYXkoYSwgbyA9IDApIHtcbiAgICB0aGlzWzBdID0gYVtvXTtcbiAgICB0aGlzWzFdID0gYVtvICsgMV07XG4gICAgdGhpc1syXSA9IGFbbyArIDJdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9BcnJheShhID0gW10sIG8gPSAwKSB7XG4gICAgYVtvXSA9IHRoaXNbMF07XG4gICAgYVtvICsgMV0gPSB0aGlzWzFdO1xuICAgIGFbbyArIDJdID0gdGhpc1syXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHRyYW5zZm9ybURpcmVjdGlvbihtYXQ0KSB7XG4gICAgY29uc3QgeCA9IHRoaXNbMF07XG4gICAgY29uc3QgeSA9IHRoaXNbMV07XG4gICAgY29uc3QgeiA9IHRoaXNbMl07XG4gICAgdGhpc1swXSA9IG1hdDRbMF0gKiB4ICsgbWF0NFs0XSAqIHkgKyBtYXQ0WzhdICogejtcbiAgICB0aGlzWzFdID0gbWF0NFsxXSAqIHggKyBtYXQ0WzVdICogeSArIG1hdDRbOV0gKiB6O1xuICAgIHRoaXNbMl0gPSBtYXQ0WzJdICogeCArIG1hdDRbNl0gKiB5ICsgbWF0NFsxMF0gKiB6O1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuICB9XG5cbn0iLCIvLyBhdHRyaWJ1dGUgcGFyYW1zXG4vLyB7XG4vLyAgICAgZGF0YSAtIHR5cGVkIGFycmF5IGVnIFVJbnQxNkFycmF5IGZvciBpbmRpY2VzLCBGbG9hdDMyQXJyYXlcbi8vICAgICBzaXplIC0gaW50IGRlZmF1bHQgMVxuLy8gICAgIGluc3RhbmNlZCAtIGRlZmF1bHQgbnVsbC4gUGFzcyBkaXZpc29yIGFtb3VudFxuLy8gICAgIHR5cGUgLSBnbCBlbnVtIGRlZmF1bHQgZ2wuVU5TSUdORURfU0hPUlQgZm9yICdpbmRleCcsIGdsLkZMT0FUIGZvciBvdGhlcnNcbi8vICAgICBub3JtYWxpemVkIC0gYm9vbGVhbiBkZWZhdWx0IGZhbHNlXG4vLyAgICAgYnVmZmVyIC0gZ2wgYnVmZmVyLCBpZiBidWZmZXIgZXhpc3RzLCBkb24ndCBuZWVkIHRvIHByb3ZpZGUgZGF0YVxuLy8gICAgIHN0cmlkZSAtIGRlZmF1bHQgMCAtIGZvciB3aGVuIHBhc3NpbmcgaW4gYnVmZmVyXG4vLyAgICAgb2Zmc2V0IC0gZGVmYXVsdCAwIC0gZm9yIHdoZW4gcGFzc2luZyBpbiBidWZmZXJcbi8vICAgICBjb3VudCAtIGRlZmF1bHQgbnVsbCAtIGZvciB3aGVuIHBhc3NpbmcgaW4gYnVmZmVyXG4vLyAgICAgbWluIC0gYXJyYXkgLSBmb3Igd2hlbiBwYXNzaW5nIGluIGJ1ZmZlclxuLy8gICAgIG1heCAtIGFycmF5IC0gZm9yIHdoZW4gcGFzc2luZyBpbiBidWZmZXJcbi8vIH1cbi8vIFRPRE86IGZpdCBpbiB0cmFuc2Zvcm0gZmVlZGJhY2tcbi8vIFRPRE86IHdoZW4gd291bGQgSSBkaXNhYmxlVmVydGV4QXR0cmliQXJyYXkgP1xuLy8gVE9ETzogYWRkIGZhbGxiYWNrIGZvciBub24gdmFvIHN1cHBvcnQgKGllKVxuLy8gVE9ETzogdXNlIG9mZnNldC9zdHJpZGUgaWYgZXhpc3RzXG4vLyBUT0RPOiBjaGVjayBzaXplIG9mIHBvc2l0aW9uIChlZyB0cmlhbmdsZSB3aXRoIFZlYzIpXG5pbXBvcnQgeyBWZWMzIH0gZnJvbSAnLi4vbWF0aC9WZWMzLmpzJztcbmNvbnN0IHRlbXBWZWMzID0gbmV3IFZlYzMoKTtcbmxldCBJRCA9IDE7XG5sZXQgQVRUUl9JRCA9IDE7IC8vIFRvIHN0b3AgaW5pZmluaXRlIHdhcm5pbmdzXG5cbmxldCBpc0JvdW5kc1dhcm5lZCA9IGZhbHNlO1xuZXhwb3J0IGNsYXNzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoZ2wsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIGlmICghZ2wuY2FudmFzKSBjb25zb2xlLmVycm9yKCdnbCBub3QgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50IHRvIEdlb21ldHJ5Jyk7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgdGhpcy5pZCA9IElEKys7IC8vIFN0b3JlIG9uZSBWQU8gcGVyIHByb2dyYW0gYXR0cmlidXRlIGxvY2F0aW9ucyBvcmRlclxuXG4gICAgdGhpcy5WQU9zID0ge307XG4gICAgdGhpcy5kcmF3UmFuZ2UgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgICB0aGlzLmluc3RhbmNlZENvdW50ID0gMDsgLy8gVW5iaW5kIGN1cnJlbnQgVkFPIHNvIHRoYXQgbmV3IGJ1ZmZlcnMgZG9uJ3QgZ2V0IGFkZGVkIHRvIGFjdGl2ZSBtZXNoXG5cbiAgICB0aGlzLmdsLnJlbmRlcmVyLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICB0aGlzLmdsLnJlbmRlcmVyLmN1cnJlbnRHZW9tZXRyeSA9IG51bGw7IC8vIEFsaWFzIGZvciBzdGF0ZSBzdG9yZSB0byBhdm9pZCByZWR1bmRhbnQgY2FsbHMgZm9yIGdsb2JhbCBzdGF0ZVxuXG4gICAgdGhpcy5nbFN0YXRlID0gdGhpcy5nbC5yZW5kZXJlci5zdGF0ZTsgLy8gY3JlYXRlIHRoZSBidWZmZXJzXG5cbiAgICBmb3IgKGxldCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIGFkZEF0dHJpYnV0ZShrZXksIGF0dHIpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNba2V5XSA9IGF0dHI7IC8vIFNldCBvcHRpb25zXG5cbiAgICBhdHRyLmlkID0gQVRUUl9JRCsrOyAvLyBUT0RPOiBjdXJyZW50bHkgdW51c2VkLCByZW1vdmU/XG5cbiAgICBhdHRyLnNpemUgPSBhdHRyLnNpemUgfHwgMTtcbiAgICBhdHRyLnR5cGUgPSBhdHRyLnR5cGUgfHwgKGF0dHIuZGF0YS5jb25zdHJ1Y3RvciA9PT0gRmxvYXQzMkFycmF5ID8gdGhpcy5nbC5GTE9BVCA6IGF0dHIuZGF0YS5jb25zdHJ1Y3RvciA9PT0gVWludDE2QXJyYXkgPyB0aGlzLmdsLlVOU0lHTkVEX1NIT1JUIDogdGhpcy5nbC5VTlNJR05FRF9JTlQpOyAvLyBVaW50MzJBcnJheVxuXG4gICAgYXR0ci50YXJnZXQgPSBrZXkgPT09ICdpbmRleCcgPyB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogdGhpcy5nbC5BUlJBWV9CVUZGRVI7XG4gICAgYXR0ci5ub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkIHx8IGZhbHNlO1xuICAgIGF0dHIuc3RyaWRlID0gYXR0ci5zdHJpZGUgfHwgMDtcbiAgICBhdHRyLm9mZnNldCA9IGF0dHIub2Zmc2V0IHx8IDA7XG4gICAgYXR0ci5jb3VudCA9IGF0dHIuY291bnQgfHwgKGF0dHIuc3RyaWRlID8gYXR0ci5kYXRhLmJ5dGVMZW5ndGggLyBhdHRyLnN0cmlkZSA6IGF0dHIuZGF0YS5sZW5ndGggLyBhdHRyLnNpemUpO1xuICAgIGF0dHIuZGl2aXNvciA9IGF0dHIuaW5zdGFuY2VkIHx8IDA7XG4gICAgYXR0ci5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFhdHRyLmJ1ZmZlcikge1xuICAgICAgYXR0ci5idWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpOyAvLyBQdXNoIGRhdGEgdG8gYnVmZmVyXG5cbiAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKGF0dHIpO1xuICAgIH0gLy8gVXBkYXRlIGdlb21ldHJ5IGNvdW50cy4gSWYgaW5kZXhlZCwgaWdub3JlIHJlZ3VsYXIgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAoYXR0ci5kaXZpc29yKSB7XG4gICAgICB0aGlzLmlzSW5zdGFuY2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuaW5zdGFuY2VkQ291bnQgJiYgdGhpcy5pbnN0YW5jZWRDb3VudCAhPT0gYXR0ci5jb3VudCAqIGF0dHIuZGl2aXNvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dlb21ldHJ5IGhhcyBtdWx0aXBsZSBpbnN0YW5jZWQgYnVmZmVycyBvZiBkaWZmZXJlbnQgbGVuZ3RoJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlZENvdW50ID0gTWF0aC5taW4odGhpcy5pbnN0YW5jZWRDb3VudCwgYXR0ci5jb3VudCAqIGF0dHIuZGl2aXNvcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zdGFuY2VkQ291bnQgPSBhdHRyLmNvdW50ICogYXR0ci5kaXZpc29yO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5kZXgnKSB7XG4gICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGF0dHIuY291bnQ7XG4gICAgfSBlbHNlIGlmICghdGhpcy5hdHRyaWJ1dGVzLmluZGV4KSB7XG4gICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IE1hdGgubWF4KHRoaXMuZHJhd1JhbmdlLmNvdW50LCBhdHRyLmNvdW50KTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGUoYXR0cikge1xuICAgIGlmICh0aGlzLmdsU3RhdGUuYm91bmRCdWZmZXIgIT09IGF0dHIuYnVmZmVyKSB7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIoYXR0ci50YXJnZXQsIGF0dHIuYnVmZmVyKTtcbiAgICAgIHRoaXMuZ2xTdGF0ZS5ib3VuZEJ1ZmZlciA9IGF0dHIuYnVmZmVyO1xuICAgIH1cblxuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YShhdHRyLnRhcmdldCwgYXR0ci5kYXRhLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICBhdHRyLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICBzZXRJbmRleCh2YWx1ZSkge1xuICAgIHRoaXMuYWRkQXR0cmlidXRlKCdpbmRleCcsIHZhbHVlKTtcbiAgfVxuXG4gIHNldERyYXdSYW5nZShzdGFydCwgY291bnQpIHtcbiAgICB0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG4gIH1cblxuICBzZXRJbnN0YW5jZWRDb3VudCh2YWx1ZSkge1xuICAgIHRoaXMuaW5zdGFuY2VkQ291bnQgPSB2YWx1ZTtcbiAgfVxuXG4gIGNyZWF0ZVZBTyhwcm9ncmFtKSB7XG4gICAgdGhpcy5WQU9zW3Byb2dyYW0uYXR0cmlidXRlT3JkZXJdID0gdGhpcy5nbC5yZW5kZXJlci5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgIHRoaXMuZ2wucmVuZGVyZXIuYmluZFZlcnRleEFycmF5KHRoaXMuVkFPc1twcm9ncmFtLmF0dHJpYnV0ZU9yZGVyXSk7XG4gICAgdGhpcy5iaW5kQXR0cmlidXRlcyhwcm9ncmFtKTtcbiAgfVxuXG4gIGJpbmRBdHRyaWJ1dGVzKHByb2dyYW0pIHtcbiAgICAvLyBMaW5rIGFsbCBhdHRyaWJ1dGVzIHRvIHByb2dyYW0gdXNpbmcgZ2wudmVydGV4QXR0cmliUG9pbnRlclxuICAgIHByb2dyYW0uYXR0cmlidXRlTG9jYXRpb25zLmZvckVhY2goKGxvY2F0aW9uLCBuYW1lKSA9PiB7XG4gICAgICAvLyBJZiBnZW9tZXRyeSBtaXNzaW5nIGEgcmVxdWlyZWQgc2hhZGVyIGF0dHJpYnV0ZVxuICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZXNbbmFtZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBhY3RpdmUgYXR0cmlidXRlICR7bmFtZX0gbm90IGJlaW5nIHN1cHBsaWVkYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0ciA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcihhdHRyLnRhcmdldCwgYXR0ci5idWZmZXIpO1xuICAgICAgdGhpcy5nbFN0YXRlLmJvdW5kQnVmZmVyID0gYXR0ci5idWZmZXI7XG4gICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHIuc2l6ZSwgYXR0ci50eXBlLCBhdHRyLm5vcm1hbGl6ZWQsIGF0dHIuc3RyaWRlLCBhdHRyLm9mZnNldCk7XG4gICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTsgLy8gRm9yIGluc3RhbmNlZCBhdHRyaWJ1dGVzLCBkaXZpc29yIG5lZWRzIHRvIGJlIHNldC5cbiAgICAgIC8vIEZvciBmaXJlZm94LCBuZWVkIHRvIHNldCBiYWNrIHRvIDAgaWYgbm9uLWluc3RhbmNlZCBkcmF3biBhZnRlciBpbnN0YW5jZWQuIEVsc2Ugd29uJ3QgcmVuZGVyXG5cbiAgICAgIHRoaXMuZ2wucmVuZGVyZXIudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgYXR0ci5kaXZpc29yKTtcbiAgICB9KTsgLy8gQmluZCBpbmRpY2VzIGlmIGdlb21ldHJ5IGluZGV4ZWRcblxuICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaW5kZXgpIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmF0dHJpYnV0ZXMuaW5kZXguYnVmZmVyKTtcbiAgfVxuXG4gIGRyYXcoe1xuICAgIHByb2dyYW0sXG4gICAgbW9kZSA9IHRoaXMuZ2wuVFJJQU5HTEVTXG4gIH0pIHtcbiAgICBpZiAodGhpcy5nbC5yZW5kZXJlci5jdXJyZW50R2VvbWV0cnkgIT09IGAke3RoaXMuaWR9XyR7cHJvZ3JhbS5hdHRyaWJ1dGVPcmRlcn1gKSB7XG4gICAgICBpZiAoIXRoaXMuVkFPc1twcm9ncmFtLmF0dHJpYnV0ZU9yZGVyXSkgdGhpcy5jcmVhdGVWQU8ocHJvZ3JhbSk7XG4gICAgICB0aGlzLmdsLnJlbmRlcmVyLmJpbmRWZXJ0ZXhBcnJheSh0aGlzLlZBT3NbcHJvZ3JhbS5hdHRyaWJ1dGVPcmRlcl0pO1xuICAgICAgdGhpcy5nbC5yZW5kZXJlci5jdXJyZW50R2VvbWV0cnkgPSBgJHt0aGlzLmlkfV8ke3Byb2dyYW0uYXR0cmlidXRlT3JkZXJ9YDtcbiAgICB9IC8vIENoZWNrIGlmIGFueSBhdHRyaWJ1dGVzIG5lZWQgdXBkYXRpbmdcblxuXG4gICAgcHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnMuZm9yRWFjaCgobG9jYXRpb24sIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICBpZiAoYXR0ci5uZWVkc1VwZGF0ZSkgdGhpcy51cGRhdGVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcy5pbmRleCkge1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmVyLmRyYXdFbGVtZW50c0luc3RhbmNlZChtb2RlLCB0aGlzLmRyYXdSYW5nZS5jb3VudCwgdGhpcy5hdHRyaWJ1dGVzLmluZGV4LnR5cGUsIHRoaXMuZHJhd1JhbmdlLnN0YXJ0LCB0aGlzLmluc3RhbmNlZENvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2wucmVuZGVyZXIuZHJhd0FycmF5c0luc3RhbmNlZChtb2RlLCB0aGlzLmRyYXdSYW5nZS5zdGFydCwgdGhpcy5kcmF3UmFuZ2UuY291bnQsIHRoaXMuaW5zdGFuY2VkQ291bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLmluZGV4KSB7XG4gICAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzKG1vZGUsIHRoaXMuZHJhd1JhbmdlLmNvdW50LCB0aGlzLmF0dHJpYnV0ZXMuaW5kZXgudHlwZSwgdGhpcy5hdHRyaWJ1dGVzLmluZGV4Lm9mZnNldCArIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ICogMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdsLmRyYXdBcnJheXMobW9kZSwgdGhpcy5kcmF3UmFuZ2Uuc3RhcnQsIHRoaXMuZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRQb3NpdGlvbkFycmF5KCkge1xuICAgIC8vIFVzZSBwb3NpdGlvbiBidWZmZXIsIG9yIG1pbi9tYXggaWYgYXZhaWxhYmxlXG4gICAgY29uc3QgYXR0ciA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICBpZiAoYXR0ci5taW4pIHJldHVybiBbLi4uYXR0ci5taW4sIC4uLmF0dHIubWF4XTtcbiAgICBpZiAoYXR0ci5kYXRhKSByZXR1cm4gYXR0ci5kYXRhO1xuICAgIGlmIChpc0JvdW5kc1dhcm5lZCkgcmV0dXJuO1xuICAgIGNvbnNvbGUud2FybignTm8gcG9zaXRpb24gYnVmZmVyIGRhdGEgZm91bmQgdG8gY29tcHV0ZSBib3VuZHMnKTtcbiAgICByZXR1cm4gaXNCb3VuZHNXYXJuZWQgPSB0cnVlO1xuICB9XG5cbiAgY29tcHV0ZUJvdW5kaW5nQm94KGFycmF5KSB7XG4gICAgaWYgKCFhcnJheSkgYXJyYXkgPSB0aGlzLmdldFBvc2l0aW9uQXJyYXkoKTtcblxuICAgIGlmICghdGhpcy5ib3VuZHMpIHtcbiAgICAgIHRoaXMuYm91bmRzID0ge1xuICAgICAgICBtaW46IG5ldyBWZWMzKCksXG4gICAgICAgIG1heDogbmV3IFZlYzMoKSxcbiAgICAgICAgY2VudGVyOiBuZXcgVmVjMygpLFxuICAgICAgICBzY2FsZTogbmV3IFZlYzMoKSxcbiAgICAgICAgcmFkaXVzOiBJbmZpbml0eVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBtaW4gPSB0aGlzLmJvdW5kcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5ib3VuZHMubWF4O1xuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuYm91bmRzLmNlbnRlcjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuYm91bmRzLnNjYWxlO1xuICAgIG1pbi5zZXQoK0luZmluaXR5KTtcbiAgICBtYXguc2V0KC1JbmZpbml0eSk7IC8vIFRPRE86IHVzZSBvZmZzZXQvc3RyaWRlIGlmIGV4aXN0c1xuICAgIC8vIFRPRE86IGNoZWNrIHNpemUgb2YgcG9zaXRpb24gKGVnIHRyaWFuZ2xlIHdpdGggVmVjMilcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICBjb25zdCB4ID0gYXJyYXlbaV07XG4gICAgICBjb25zdCB5ID0gYXJyYXlbaSArIDFdO1xuICAgICAgY29uc3QgeiA9IGFycmF5W2kgKyAyXTtcbiAgICAgIG1pbi54ID0gTWF0aC5taW4oeCwgbWluLngpO1xuICAgICAgbWluLnkgPSBNYXRoLm1pbih5LCBtaW4ueSk7XG4gICAgICBtaW4ueiA9IE1hdGgubWluKHosIG1pbi56KTtcbiAgICAgIG1heC54ID0gTWF0aC5tYXgoeCwgbWF4LngpO1xuICAgICAgbWF4LnkgPSBNYXRoLm1heCh5LCBtYXgueSk7XG4gICAgICBtYXgueiA9IE1hdGgubWF4KHosIG1heC56KTtcbiAgICB9XG5cbiAgICBzY2FsZS5zdWIobWF4LCBtaW4pO1xuICAgIGNlbnRlci5hZGQobWluLCBtYXgpLmRpdmlkZSgyKTtcbiAgfVxuXG4gIGNvbXB1dGVCb3VuZGluZ1NwaGVyZShhcnJheSkge1xuICAgIGlmICghYXJyYXkpIGFycmF5ID0gdGhpcy5nZXRQb3NpdGlvbkFycmF5KCk7XG4gICAgaWYgKCF0aGlzLmJvdW5kcykgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goYXJyYXkpO1xuICAgIGxldCBtYXhSYWRpdXNTcSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgdGVtcFZlYzMuZnJvbUFycmF5KGFycmF5LCBpKTtcbiAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIHRoaXMuYm91bmRzLmNlbnRlci5zcXVhcmVkRGlzdGFuY2UodGVtcFZlYzMpKTtcbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kcy5yYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzU3EpO1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnZhbykgdGhpcy5nbC5yZW5kZXJlci5kZWxldGVWZXJ0ZXhBcnJheSh0aGlzLnZhbyk7XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmF0dHJpYnV0ZXNba2V5XS5idWZmZXIpO1xuICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgIH1cbiAgfVxuXG59IiwiLy8gVE9ETzogdXBsb2FkIGVtcHR5IHRleHR1cmUgaWYgbnVsbCA/IG1heWJlIG5vdFxuLy8gVE9ETzogdXBsb2FkIGlkZW50aXR5IG1hdHJpeCBpZiBudWxsID9cbi8vIFRPRE86IHNhbXBsZXIgQ3ViZVxubGV0IElEID0gMTsgLy8gY2FjaGUgb2YgdHlwZWQgYXJyYXlzIHVzZWQgdG8gZmxhdHRlbiB1bmlmb3JtIGFycmF5c1xuXG5jb25zdCBhcnJheUNhY2hlRjMyID0ge307XG5leHBvcnQgY2xhc3MgUHJvZ3JhbSB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgdmVydGV4LFxuICAgIGZyYWdtZW50LFxuICAgIHVuaWZvcm1zID0ge30sXG4gICAgdHJhbnNwYXJlbnQgPSBmYWxzZSxcbiAgICBjdWxsRmFjZSA9IGdsLkJBQ0ssXG4gICAgZnJvbnRGYWNlID0gZ2wuQ0NXLFxuICAgIGRlcHRoVGVzdCA9IHRydWUsXG4gICAgZGVwdGhXcml0ZSA9IHRydWUsXG4gICAgZGVwdGhGdW5jID0gZ2wuTEVTU1xuICB9ID0ge30pIHtcbiAgICBpZiAoIWdsLmNhbnZhcykgY29uc29sZS5lcnJvcignZ2wgbm90IHBhc3NlZCBhcyBmaXN0IGFyZ3VtZW50IHRvIFByb2dyYW0nKTtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMuaWQgPSBJRCsrO1xuICAgIGlmICghdmVydGV4KSBjb25zb2xlLndhcm4oJ3ZlcnRleCBzaGFkZXIgbm90IHN1cHBsaWVkJyk7XG4gICAgaWYgKCFmcmFnbWVudCkgY29uc29sZS53YXJuKCdmcmFnbWVudCBzaGFkZXIgbm90IHN1cHBsaWVkJyk7IC8vIFN0b3JlIHByb2dyYW0gc3RhdGVcblxuICAgIHRoaXMudHJhbnNwYXJlbnQgPSB0cmFuc3BhcmVudDtcbiAgICB0aGlzLmN1bGxGYWNlID0gY3VsbEZhY2U7XG4gICAgdGhpcy5mcm9udEZhY2UgPSBmcm9udEZhY2U7XG4gICAgdGhpcy5kZXB0aFRlc3QgPSBkZXB0aFRlc3Q7XG4gICAgdGhpcy5kZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcbiAgICB0aGlzLmRlcHRoRnVuYyA9IGRlcHRoRnVuYztcbiAgICB0aGlzLmJsZW5kRnVuYyA9IHt9O1xuICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IHt9OyAvLyBzZXQgZGVmYXVsdCBibGVuZEZ1bmMgaWYgdHJhbnNwYXJlbnQgZmxhZ2dlZFxuXG4gICAgaWYgKHRoaXMudHJhbnNwYXJlbnQgJiYgIXRoaXMuYmxlbmRGdW5jLnNyYykge1xuICAgICAgaWYgKHRoaXMuZ2wucmVuZGVyZXIucHJlbXVsdGlwbGllZEFscGhhKSB0aGlzLnNldEJsZW5kRnVuYyh0aGlzLmdsLk9ORSwgdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtlbHNlIHRoaXMuc2V0QmxlbmRGdW5jKHRoaXMuZ2wuU1JDX0FMUEhBLCB0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgIH0gLy8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyIGFuZCBsb2cgZXJyb3JzXG5cblxuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXgpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICAgIGlmIChnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikgIT09ICcnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYCR7Z2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpfVxcblZlcnRleCBTaGFkZXJcXG4ke2FkZExpbmVOdW1iZXJzKHZlcnRleCl9YCk7XG4gICAgfSAvLyBjb21waWxlIGZyYWdtZW50IHNoYWRlciBhbmQgbG9nIGVycm9yc1xuXG5cbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnQpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gICAgaWYgKGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpICE9PSAnJykge1xuICAgICAgY29uc29sZS53YXJuKGAke2dsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpfVxcbkZyYWdtZW50IFNoYWRlclxcbiR7YWRkTGluZU51bWJlcnMoZnJhZ21lbnQpfWApO1xuICAgIH0gLy8gY29tcGlsZSBwcm9ncmFtIGFuZCBsb2cgZXJyb3JzXG5cblxuICAgIHRoaXMucHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMucHJvZ3JhbSkpO1xuICAgIH0gLy8gUmVtb3ZlIHNoYWRlciBvbmNlIGxpbmtlZFxuXG5cbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpOyAvLyBHZXQgYWN0aXZlIHVuaWZvcm0gbG9jYXRpb25zXG5cbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG5cbiAgICBmb3IgKGxldCB1SW5kZXggPSAwOyB1SW5kZXggPCBudW1Vbmlmb3JtczsgdUluZGV4KyspIHtcbiAgICAgIGxldCB1bmlmb3JtID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSh0aGlzLnByb2dyYW0sIHVJbmRleCk7XG4gICAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMuc2V0KHVuaWZvcm0sIGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIHVuaWZvcm0ubmFtZSkpOyAvLyBzcGxpdCB1bmlmb3JtcycgbmFtZXMgdG8gc2VwYXJhdGUgYXJyYXkgYW5kIHN0cnVjdCBkZWNsYXJhdGlvbnNcblxuICAgICAgY29uc3Qgc3BsaXQgPSB1bmlmb3JtLm5hbWUubWF0Y2goLyhcXHcrKS9nKTtcbiAgICAgIHVuaWZvcm0udW5pZm9ybU5hbWUgPSBzcGxpdFswXTtcblxuICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICB1bmlmb3JtLmlzU3RydWN0QXJyYXkgPSB0cnVlO1xuICAgICAgICB1bmlmb3JtLnN0cnVjdEluZGV4ID0gTnVtYmVyKHNwbGl0WzFdKTtcbiAgICAgICAgdW5pZm9ybS5zdHJ1Y3RQcm9wZXJ0eSA9IHNwbGl0WzJdO1xuICAgICAgfSBlbHNlIGlmIChzcGxpdC5sZW5ndGggPT09IDIgJiYgaXNOYU4oTnVtYmVyKHNwbGl0WzFdKSkpIHtcbiAgICAgICAgdW5pZm9ybS5pc1N0cnVjdCA9IHRydWU7XG4gICAgICAgIHVuaWZvcm0uc3RydWN0UHJvcGVydHkgPSBzcGxpdFsxXTtcbiAgICAgIH1cbiAgICB9IC8vIEdldCBhY3RpdmUgYXR0cmlidXRlIGxvY2F0aW9uc1xuXG5cbiAgICB0aGlzLmF0dHJpYnV0ZUxvY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBsb2NhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBudW1BdHRyaWJzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcblxuICAgIGZvciAobGV0IGFJbmRleCA9IDA7IGFJbmRleCA8IG51bUF0dHJpYnM7IGFJbmRleCsrKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBhSW5kZXgpO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgIGxvY2F0aW9uc1tsb2NhdGlvbl0gPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlTG9jYXRpb25zLnNldChhdHRyaWJ1dGUubmFtZSwgbG9jYXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlT3JkZXIgPSBsb2NhdGlvbnMuam9pbignJyk7XG4gIH1cblxuICBzZXRCbGVuZEZ1bmMoc3JjLCBkc3QsIHNyY0FscGhhLCBkc3RBbHBoYSkge1xuICAgIHRoaXMuYmxlbmRGdW5jLnNyYyA9IHNyYztcbiAgICB0aGlzLmJsZW5kRnVuYy5kc3QgPSBkc3Q7XG4gICAgdGhpcy5ibGVuZEZ1bmMuc3JjQWxwaGEgPSBzcmNBbHBoYTtcbiAgICB0aGlzLmJsZW5kRnVuYy5kc3RBbHBoYSA9IGRzdEFscGhhO1xuICAgIGlmIChzcmMpIHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICB9XG5cbiAgc2V0QmxlbmRFcXVhdGlvbihtb2RlUkdCLCBtb2RlQWxwaGEpIHtcbiAgICB0aGlzLmJsZW5kRXF1YXRpb24ubW9kZVJHQiA9IG1vZGVSR0I7XG4gICAgdGhpcy5ibGVuZEVxdWF0aW9uLm1vZGVBbHBoYSA9IG1vZGVBbHBoYTtcbiAgfVxuXG4gIGFwcGx5U3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuZGVwdGhUZXN0KSB0aGlzLmdsLnJlbmRlcmVyLmVuYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO2Vsc2UgdGhpcy5nbC5yZW5kZXJlci5kaXNhYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG4gICAgaWYgKHRoaXMuY3VsbEZhY2UpIHRoaXMuZ2wucmVuZGVyZXIuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtlbHNlIHRoaXMuZ2wucmVuZGVyZXIuZGlzYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gICAgaWYgKHRoaXMuYmxlbmRGdW5jLnNyYykgdGhpcy5nbC5yZW5kZXJlci5lbmFibGUodGhpcy5nbC5CTEVORCk7ZWxzZSB0aGlzLmdsLnJlbmRlcmVyLmRpc2FibGUodGhpcy5nbC5CTEVORCk7XG4gICAgaWYgKHRoaXMuY3VsbEZhY2UpIHRoaXMuZ2wucmVuZGVyZXIuc2V0Q3VsbEZhY2UodGhpcy5jdWxsRmFjZSk7XG4gICAgdGhpcy5nbC5yZW5kZXJlci5zZXRGcm9udEZhY2UodGhpcy5mcm9udEZhY2UpO1xuICAgIHRoaXMuZ2wucmVuZGVyZXIuc2V0RGVwdGhNYXNrKHRoaXMuZGVwdGhXcml0ZSk7XG4gICAgdGhpcy5nbC5yZW5kZXJlci5zZXREZXB0aEZ1bmModGhpcy5kZXB0aEZ1bmMpO1xuICAgIGlmICh0aGlzLmJsZW5kRnVuYy5zcmMpIHRoaXMuZ2wucmVuZGVyZXIuc2V0QmxlbmRGdW5jKHRoaXMuYmxlbmRGdW5jLnNyYywgdGhpcy5ibGVuZEZ1bmMuZHN0LCB0aGlzLmJsZW5kRnVuYy5zcmNBbHBoYSwgdGhpcy5ibGVuZEZ1bmMuZHN0QWxwaGEpO1xuICAgIGlmICh0aGlzLmJsZW5kRXF1YXRpb24ubW9kZVJHQikgdGhpcy5nbC5yZW5kZXJlci5zZXRCbGVuZEVxdWF0aW9uKHRoaXMuYmxlbmRFcXVhdGlvbi5tb2RlUkdCLCB0aGlzLmJsZW5kRXF1YXRpb24ubW9kZUFscGhhKTtcbiAgfVxuXG4gIHVzZSh7XG4gICAgZmxpcEZhY2VzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgbGV0IHRleHR1cmVVbml0ID0gLTE7XG4gICAgY29uc3QgcHJvZ3JhbUFjdGl2ZSA9IHRoaXMuZ2wucmVuZGVyZXIuY3VycmVudFByb2dyYW0gPT09IHRoaXMuaWQ7IC8vIEF2b2lkIGdsIGNhbGwgaWYgcHJvZ3JhbSBhbHJlYWR5IGluIHVzZVxuXG4gICAgaWYgKCFwcm9ncmFtQWN0aXZlKSB7XG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgIHRoaXMuZ2wucmVuZGVyZXIuY3VycmVudFByb2dyYW0gPSB0aGlzLmlkO1xuICAgIH0gLy8gU2V0IG9ubHkgdGhlIGFjdGl2ZSB1bmlmb3JtcyBmb3VuZCBpbiB0aGUgc2hhZGVyXG5cblxuICAgIHRoaXMudW5pZm9ybUxvY2F0aW9ucy5mb3JFYWNoKChsb2NhdGlvbiwgYWN0aXZlVW5pZm9ybSkgPT4ge1xuICAgICAgbGV0IG5hbWUgPSBhY3RpdmVVbmlmb3JtLnVuaWZvcm1OYW1lOyAvLyBnZXQgc3VwcGxpZWQgdW5pZm9ybVxuXG4gICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07IC8vIEZvciBzdHJ1Y3RzLCBnZXQgdGhlIHNwZWNpZmljIHByb3BlcnR5IGluc3RlYWQgb2YgdGhlIGVudGlyZSBvYmplY3RcblxuICAgICAgaWYgKGFjdGl2ZVVuaWZvcm0uaXNTdHJ1Y3QpIHtcbiAgICAgICAgdW5pZm9ybSA9IHVuaWZvcm1bYWN0aXZlVW5pZm9ybS5zdHJ1Y3RQcm9wZXJ0eV07XG4gICAgICAgIG5hbWUgKz0gYC4ke2FjdGl2ZVVuaWZvcm0uc3RydWN0UHJvcGVydHl9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZVVuaWZvcm0uaXNTdHJ1Y3RBcnJheSkge1xuICAgICAgICB1bmlmb3JtID0gdW5pZm9ybVthY3RpdmVVbmlmb3JtLnN0cnVjdEluZGV4XVthY3RpdmVVbmlmb3JtLnN0cnVjdFByb3BlcnR5XTtcbiAgICAgICAgbmFtZSArPSBgWyR7YWN0aXZlVW5pZm9ybS5zdHJ1Y3RJbmRleH1dLiR7YWN0aXZlVW5pZm9ybS5zdHJ1Y3RQcm9wZXJ0eX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXVuaWZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHdhcm4oYEFjdGl2ZSB1bmlmb3JtICR7bmFtZX0gaGFzIG5vdCBiZWVuIHN1cHBsaWVkYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmlmb3JtICYmIHVuaWZvcm0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gd2FybihgJHtuYW1lfSB1bmlmb3JtIGlzIG1pc3NpbmcgYSB2YWx1ZSBwYXJhbWV0ZXJgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVuaWZvcm0udmFsdWUudGV4dHVyZSkge1xuICAgICAgICB0ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0ICsgMTsgLy8gQ2hlY2sgaWYgdGV4dHVyZSBuZWVkcyB0byBiZSB1cGRhdGVkXG5cbiAgICAgICAgdW5pZm9ybS52YWx1ZS51cGRhdGUodGV4dHVyZVVuaXQpO1xuICAgICAgICByZXR1cm4gc2V0VW5pZm9ybSh0aGlzLmdsLCBhY3RpdmVVbmlmb3JtLnR5cGUsIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgICB9IC8vIEZvciB0ZXh0dXJlIGFycmF5cywgc2V0IHVuaWZvcm0gYXMgYW4gYXJyYXkgb2YgdGV4dHVyZSB1bml0cyBpbnN0ZWFkIG9mIGp1c3Qgb25lXG5cblxuICAgICAgaWYgKHVuaWZvcm0udmFsdWUubGVuZ3RoICYmIHVuaWZvcm0udmFsdWVbMF0udGV4dHVyZSkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlVW5pdHMgPSBbXTtcbiAgICAgICAgdW5pZm9ybS52YWx1ZS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICB0ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0ICsgMTtcbiAgICAgICAgICB2YWx1ZS51cGRhdGUodGV4dHVyZVVuaXQpO1xuICAgICAgICAgIHRleHR1cmVVbml0cy5wdXNoKHRleHR1cmVVbml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXRVbmlmb3JtKHRoaXMuZ2wsIGFjdGl2ZVVuaWZvcm0udHlwZSwgbG9jYXRpb24sIHRleHR1cmVVbml0cyk7XG4gICAgICB9XG5cbiAgICAgIHNldFVuaWZvcm0odGhpcy5nbCwgYWN0aXZlVW5pZm9ybS50eXBlLCBsb2NhdGlvbiwgdW5pZm9ybS52YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5hcHBseVN0YXRlKCk7XG4gICAgaWYgKGZsaXBGYWNlcykgdGhpcy5nbC5yZW5kZXJlci5zZXRGcm9udEZhY2UodGhpcy5mcm9udEZhY2UgPT09IHRoaXMuZ2wuQ0NXID8gdGhpcy5nbC5DVyA6IHRoaXMuZ2wuQ0NXKTtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHNldFVuaWZvcm0oZ2wsIHR5cGUsIGxvY2F0aW9uLCB2YWx1ZSkge1xuICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA/IGZsYXR0ZW4odmFsdWUpIDogdmFsdWU7XG4gIGNvbnN0IHNldFZhbHVlID0gZ2wucmVuZGVyZXIuc3RhdGUudW5pZm9ybUxvY2F0aW9ucy5nZXQobG9jYXRpb24pOyAvLyBBdm9pZCByZWR1bmRhbnQgdW5pZm9ybSBjb21tYW5kc1xuXG4gIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICBpZiAoc2V0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2xvbmUgYXJyYXkgdG8gc3RvcmUgYXMgY2FjaGVcbiAgICAgIGdsLnJlbmRlcmVyLnN0YXRlLnVuaWZvcm1Mb2NhdGlvbnMuc2V0KGxvY2F0aW9uLCB2YWx1ZS5zbGljZSgwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcnJheXNFcXVhbChzZXRWYWx1ZSwgdmFsdWUpKSByZXR1cm47IC8vIFVwZGF0ZSBjYWNoZWQgYXJyYXkgdmFsdWVzXG5cbiAgICAgIHNldFZhbHVlLnNldCA/IHNldFZhbHVlLnNldCh2YWx1ZSkgOiBzZXRBcnJheShzZXRWYWx1ZSwgdmFsdWUpO1xuICAgICAgZ2wucmVuZGVyZXIuc3RhdGUudW5pZm9ybUxvY2F0aW9ucy5zZXQobG9jYXRpb24sIHNldFZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNldFZhbHVlID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgIGdsLnJlbmRlcmVyLnN0YXRlLnVuaWZvcm1Mb2NhdGlvbnMuc2V0KGxvY2F0aW9uLCB2YWx1ZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIDUxMjY6XG4gICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID8gZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdmFsdWUpIDogZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgLy8gRkxPQVRcblxuICAgIGNhc2UgMzU2NjQ6XG4gICAgICByZXR1cm4gZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgIC8vIEZMT0FUX1ZFQzJcblxuICAgIGNhc2UgMzU2NjU6XG4gICAgICByZXR1cm4gZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgIC8vIEZMT0FUX1ZFQzNcblxuICAgIGNhc2UgMzU2NjY6XG4gICAgICByZXR1cm4gZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpO1xuICAgIC8vIEZMT0FUX1ZFQzRcblxuICAgIGNhc2UgMzU2NzA6IC8vIEJPT0xcblxuICAgIGNhc2UgNTEyNDogLy8gSU5UXG5cbiAgICBjYXNlIDM1Njc4OiAvLyBTQU1QTEVSXzJEXG5cbiAgICBjYXNlIDM1NjgwOlxuICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlKSA6IGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpO1xuICAgIC8vIFNBTVBMRVJfQ1VCRVxuXG4gICAgY2FzZSAzNTY3MTogLy8gQk9PTF9WRUMyXG5cbiAgICBjYXNlIDM1NjY3OlxuICAgICAgcmV0dXJuIGdsLnVuaWZvcm0yaXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAvLyBJTlRfVkVDMlxuXG4gICAgY2FzZSAzNTY3MjogLy8gQk9PTF9WRUMzXG5cbiAgICBjYXNlIDM1NjY4OlxuICAgICAgcmV0dXJuIGdsLnVuaWZvcm0zaXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAvLyBJTlRfVkVDM1xuXG4gICAgY2FzZSAzNTY3MzogLy8gQk9PTF9WRUM0XG5cbiAgICBjYXNlIDM1NjY5OlxuICAgICAgcmV0dXJuIGdsLnVuaWZvcm00aXYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAvLyBJTlRfVkVDNFxuXG4gICAgY2FzZSAzNTY3NDpcbiAgICAgIHJldHVybiBnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpO1xuICAgIC8vIEZMT0FUX01BVDJcblxuICAgIGNhc2UgMzU2NzU6XG4gICAgICByZXR1cm4gZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcbiAgICAvLyBGTE9BVF9NQVQzXG5cbiAgICBjYXNlIDM1Njc2OlxuICAgICAgcmV0dXJuIGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7XG4gICAgLy8gRkxPQVRfTUFUNFxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKHN0cmluZykge1xuICBsZXQgbGluZXMgPSBzdHJpbmcuc3BsaXQoJ1xcbicpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsaW5lc1tpXSA9IGkgKyAxICsgJzogJyArIGxpbmVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuKGEpIHtcbiAgY29uc3QgYXJyYXlMZW4gPSBhLmxlbmd0aDtcbiAgY29uc3QgdmFsdWVMZW4gPSBhWzBdLmxlbmd0aDtcbiAgaWYgKHZhbHVlTGVuID09PSB1bmRlZmluZWQpIHJldHVybiBhO1xuICBjb25zdCBsZW5ndGggPSBhcnJheUxlbiAqIHZhbHVlTGVuO1xuICBsZXQgdmFsdWUgPSBhcnJheUNhY2hlRjMyW2xlbmd0aF07XG4gIGlmICghdmFsdWUpIGFycmF5Q2FjaGVGMzJbbGVuZ3RoXSA9IHZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlMZW47IGkrKykgdmFsdWUuc2V0KGFbaV0sIGkgKiB2YWx1ZUxlbik7XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRBcnJheShhLCBiKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBhW2ldID0gYltpXTtcbiAgfVxufVxuXG5sZXQgd2FybkNvdW50ID0gMDtcblxuZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIGlmICh3YXJuQ291bnQgPiAxMDApIHJldHVybjtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB3YXJuQ291bnQrKztcbiAgaWYgKHdhcm5Db3VudCA+IDEwMCkgY29uc29sZS53YXJuKCdNb3JlIHRoYW4gMTAwIHByb2dyYW0gd2FybmluZ3MgLSBzdG9wcGluZyBsb2dzLicpO1xufSIsImltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnOyAvLyBUT0RPOiBIYW5kbGUgY29udGV4dCBsb3NzIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3dlYmdsL3dpa2kvSGFuZGxpbmdDb250ZXh0TG9zdFxuLy8gTm90IGF1dG9tYXRpYyAtIGRldnMgdG8gdXNlIHRoZXNlIG1ldGhvZHMgbWFudWFsbHlcbi8vIGdsLmNvbG9yTWFzayggY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrICk7XG4vLyBnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG4vLyBnbC5zdGVuY2lsTWFzayggc3RlbmNpbE1hc2sgKTtcbi8vIGdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcbi8vIGdsLnN0ZW5jaWxPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XG4vLyBnbC5jbGVhclN0ZW5jaWwoIHN0ZW5jaWwgKTtcblxuY29uc3QgdGVtcFZlYzMgPSBuZXcgVmVjMygpO1xubGV0IElEID0gMTtcbmV4cG9ydCBjbGFzcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICB3aWR0aCA9IDMwMCxcbiAgICBoZWlnaHQgPSAxNTAsXG4gICAgZHByID0gMSxcbiAgICBhbHBoYSA9IGZhbHNlLFxuICAgIGRlcHRoID0gdHJ1ZSxcbiAgICBzdGVuY2lsID0gZmFsc2UsXG4gICAgYW50aWFsaWFzID0gZmFsc2UsXG4gICAgcHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2UsXG4gICAgcG93ZXJQcmVmZXJlbmNlID0gJ2RlZmF1bHQnLFxuICAgIGF1dG9DbGVhciA9IHRydWUsXG4gICAgd2ViZ2wgPSAyXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBhbHBoYSxcbiAgICAgIGRlcHRoLFxuICAgICAgc3RlbmNpbCxcbiAgICAgIGFudGlhbGlhcyxcbiAgICAgIHByZW11bHRpcGxpZWRBbHBoYSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcixcbiAgICAgIHBvd2VyUHJlZmVyZW5jZVxuICAgIH07XG4gICAgdGhpcy5kcHIgPSBkcHI7XG4gICAgdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgIHRoaXMuY29sb3IgPSB0cnVlO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB0aGlzLnN0ZW5jaWwgPSBzdGVuY2lsO1xuICAgIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xuICAgIHRoaXMuYXV0b0NsZWFyID0gYXV0b0NsZWFyO1xuICAgIHRoaXMuaWQgPSBJRCsrOyAvLyBBdHRlbXB0IFdlYkdMMiB1bmxlc3MgZm9yY2VkIHRvIDEsIGlmIG5vdCBzdXBwb3J0ZWQgZmFsbGJhY2sgdG8gV2ViR0wxXG5cbiAgICBpZiAod2ViZ2wgPT09IDIpIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgYXR0cmlidXRlcyk7XG4gICAgdGhpcy5pc1dlYmdsMiA9ICEhdGhpcy5nbDtcblxuICAgIGlmICghdGhpcy5nbCkge1xuICAgICAgdGhpcy5nbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcbiAgICB9IC8vIEF0dGFjaCByZW5kZXJlciB0byBnbCBzbyB0aGF0IGFsbCBjbGFzc2VzIGhhdmUgYWNjZXNzIHRvIGludGVybmFsIHN0YXRlIGZ1bmN0aW9uc1xuXG5cbiAgICB0aGlzLmdsLnJlbmRlcmVyID0gdGhpczsgLy8gaW5pdGlhbGlzZSBzaXplIHZhbHVlc1xuXG4gICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpOyAvLyBnbCBzdGF0ZSBzdG9yZXMgdG8gYXZvaWQgcmVkdW5kYW50IGNhbGxzIG9uIG1ldGhvZHMgdXNlZCBpbnRlcm5hbGx5XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5zdGF0ZS5ibGVuZEZ1bmMgPSB7XG4gICAgICBzcmM6IHRoaXMuZ2wuT05FLFxuICAgICAgZHN0OiB0aGlzLmdsLlpFUk9cbiAgICB9O1xuICAgIHRoaXMuc3RhdGUuYmxlbmRFcXVhdGlvbiA9IHtcbiAgICAgIG1vZGVSR0I6IHRoaXMuZ2wuRlVOQ19BRERcbiAgICB9O1xuICAgIHRoaXMuc3RhdGUuY3VsbEZhY2UgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUuZnJvbnRGYWNlID0gdGhpcy5nbC5DQ1c7XG4gICAgdGhpcy5zdGF0ZS5kZXB0aE1hc2sgPSB0cnVlO1xuICAgIHRoaXMuc3RhdGUuZGVwdGhGdW5jID0gdGhpcy5nbC5MRVNTO1xuICAgIHRoaXMuc3RhdGUucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUuZmxpcFkgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLnVucGFja0FsaWdubWVudCA9IDQ7XG4gICAgdGhpcy5zdGF0ZS5mcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZS52aWV3cG9ydCA9IHtcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLnN0YXRlLnRleHR1cmVVbml0cyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuYWN0aXZlVGV4dHVyZVVuaXQgPSAwO1xuICAgIHRoaXMuc3RhdGUuYm91bmRCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUudW5pZm9ybUxvY2F0aW9ucyA9IG5ldyBNYXAoKTsgLy8gc3RvcmUgcmVxdWVzdGVkIGV4dGVuc2lvbnNcblxuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9OyAvLyBJbml0aWFsaXNlIGV4dHJhIGZvcm1hdCB0eXBlc1xuXG4gICAgaWYgKHRoaXMuaXNXZWJnbDIpIHtcbiAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgICB0aGlzLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpO1xuICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnKTtcbiAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicpO1xuICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKTtcbiAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKTtcbiAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdFWFRfc1JHQicpO1xuICAgICAgdGhpcy5nZXRFeHRlbnNpb24oJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcbiAgICAgIHRoaXMuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcbiAgICB9IC8vIENyZWF0ZSBtZXRob2QgYWxpYXNlcyB1c2luZyBleHRlbnNpb24gKFdlYkdMMSkgb3IgbmF0aXZlIGlmIGF2YWlsYWJsZSAoV2ViR0wyKVxuXG5cbiAgICB0aGlzLnZlcnRleEF0dHJpYkRpdmlzb3IgPSB0aGlzLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycsICd2ZXJ0ZXhBdHRyaWJEaXZpc29yJywgJ3ZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRScpO1xuICAgIHRoaXMuZHJhd0FycmF5c0luc3RhbmNlZCA9IHRoaXMuZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgJ2RyYXdBcnJheXNJbnN0YW5jZWQnLCAnZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFJyk7XG4gICAgdGhpcy5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSB0aGlzLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycsICdkcmF3RWxlbWVudHNJbnN0YW5jZWQnLCAnZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUnKTtcbiAgICB0aGlzLmNyZWF0ZVZlcnRleEFycmF5ID0gdGhpcy5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JywgJ2NyZWF0ZVZlcnRleEFycmF5JywgJ2NyZWF0ZVZlcnRleEFycmF5T0VTJyk7XG4gICAgdGhpcy5iaW5kVmVydGV4QXJyYXkgPSB0aGlzLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCAnYmluZFZlcnRleEFycmF5JywgJ2JpbmRWZXJ0ZXhBcnJheU9FUycpO1xuICAgIHRoaXMuZGVsZXRlVmVydGV4QXJyYXkgPSB0aGlzLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnLCAnZGVsZXRlVmVydGV4QXJyYXknLCAnZGVsZXRlVmVydGV4QXJyYXlPRVMnKTtcbiAgICB0aGlzLmRyYXdCdWZmZXJzID0gdGhpcy5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycsICdkcmF3QnVmZmVycycsICdkcmF3QnVmZmVyc1dFQkdMJyk7IC8vIFN0b3JlIGRldmljZSBwYXJhbWV0ZXJzXG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcbiAgICB0aGlzLnBhcmFtZXRlcnMubWF4VGV4dHVyZVVuaXRzID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgdGhpcy5wYXJhbWV0ZXJzLm1heEFuaXNvdHJvcHkgPSB0aGlzLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJykgPyB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJykuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKSA6IDA7XG4gIH1cblxuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5nbC5jYW52YXMud2lkdGggPSB3aWR0aCAqIHRoaXMuZHByO1xuICAgIHRoaXMuZ2wuY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMuZHByO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5nbC5jYW52YXMuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiB3aWR0aCArICdweCcsXG4gICAgICBoZWlnaHQ6IGhlaWdodCArICdweCdcbiAgICB9KTtcbiAgfVxuXG4gIHNldFZpZXdwb3J0KHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS52aWV3cG9ydC53aWR0aCA9PT0gd2lkdGggJiYgdGhpcy5zdGF0ZS52aWV3cG9ydC5oZWlnaHQgPT09IGhlaWdodCkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUudmlld3BvcnQud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnN0YXRlLnZpZXdwb3J0LmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgZW5hYmxlKGlkKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVbaWRdID09PSB0cnVlKSByZXR1cm47XG4gICAgdGhpcy5nbC5lbmFibGUoaWQpO1xuICAgIHRoaXMuc3RhdGVbaWRdID0gdHJ1ZTtcbiAgfVxuXG4gIGRpc2FibGUoaWQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZVtpZF0gPT09IGZhbHNlKSByZXR1cm47XG4gICAgdGhpcy5nbC5kaXNhYmxlKGlkKTtcbiAgICB0aGlzLnN0YXRlW2lkXSA9IGZhbHNlO1xuICB9XG5cbiAgc2V0QmxlbmRGdW5jKHNyYywgZHN0LCBzcmNBbHBoYSwgZHN0QWxwaGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5ibGVuZEZ1bmMuc3JjID09PSBzcmMgJiYgdGhpcy5zdGF0ZS5ibGVuZEZ1bmMuZHN0ID09PSBkc3QgJiYgdGhpcy5zdGF0ZS5ibGVuZEZ1bmMuc3JjQWxwaGEgPT09IHNyY0FscGhhICYmIHRoaXMuc3RhdGUuYmxlbmRGdW5jLmRzdEFscGhhID09PSBkc3RBbHBoYSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuYmxlbmRGdW5jLnNyYyA9IHNyYztcbiAgICB0aGlzLnN0YXRlLmJsZW5kRnVuYy5kc3QgPSBkc3Q7XG4gICAgdGhpcy5zdGF0ZS5ibGVuZEZ1bmMuc3JjQWxwaGEgPSBzcmNBbHBoYTtcbiAgICB0aGlzLnN0YXRlLmJsZW5kRnVuYy5kc3RBbHBoYSA9IGRzdEFscGhhO1xuICAgIGlmIChzcmNBbHBoYSAhPT0gdW5kZWZpbmVkKSB0aGlzLmdsLmJsZW5kRnVuY1NlcGFyYXRlKHNyYywgZHN0LCBzcmNBbHBoYSwgZHN0QWxwaGEpO2Vsc2UgdGhpcy5nbC5ibGVuZEZ1bmMoc3JjLCBkc3QpO1xuICB9XG5cbiAgc2V0QmxlbmRFcXVhdGlvbihtb2RlUkdCLCBtb2RlQWxwaGEpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5ibGVuZEVxdWF0aW9uLm1vZGVSR0IgPT09IG1vZGVSR0IgJiYgdGhpcy5zdGF0ZS5ibGVuZEVxdWF0aW9uLm1vZGVBbHBoYSA9PT0gbW9kZUFscGhhKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5ibGVuZEVxdWF0aW9uLm1vZGVSR0IgPSBtb2RlUkdCO1xuICAgIHRoaXMuc3RhdGUuYmxlbmRFcXVhdGlvbi5tb2RlQWxwaGEgPSBtb2RlQWxwaGE7XG4gICAgaWYgKG1vZGVBbHBoYSAhPT0gdW5kZWZpbmVkKSB0aGlzLmdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShtb2RlUkdCLCBtb2RlQWxwaGEpO2Vsc2UgdGhpcy5nbC5ibGVuZEVxdWF0aW9uKG1vZGVSR0IpO1xuICB9XG5cbiAgc2V0Q3VsbEZhY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5jdWxsRmFjZSA9PT0gdmFsdWUpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLmN1bGxGYWNlID0gdmFsdWU7XG4gICAgdGhpcy5nbC5jdWxsRmFjZSh2YWx1ZSk7XG4gIH1cblxuICBzZXRGcm9udEZhY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5mcm9udEZhY2UgPT09IHZhbHVlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5mcm9udEZhY2UgPSB2YWx1ZTtcbiAgICB0aGlzLmdsLmZyb250RmFjZSh2YWx1ZSk7XG4gIH1cblxuICBzZXREZXB0aE1hc2sodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kZXB0aE1hc2sgPT09IHZhbHVlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5kZXB0aE1hc2sgPSB2YWx1ZTtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh2YWx1ZSk7XG4gIH1cblxuICBzZXREZXB0aEZ1bmModmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kZXB0aEZ1bmMgPT09IHZhbHVlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5kZXB0aEZ1bmMgPSB2YWx1ZTtcbiAgICB0aGlzLmdsLmRlcHRoRnVuYyh2YWx1ZSk7XG4gIH1cblxuICBhY3RpdmVUZXh0dXJlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlVGV4dHVyZVVuaXQgPT09IHZhbHVlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5hY3RpdmVUZXh0dXJlVW5pdCA9IHZhbHVlO1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgdmFsdWUpO1xuICB9XG5cbiAgYmluZEZyYW1lYnVmZmVyKHtcbiAgICB0YXJnZXQgPSB0aGlzLmdsLkZSQU1FQlVGRkVSLFxuICAgIGJ1ZmZlciA9IG51bGxcbiAgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZnJhbWVidWZmZXIgPT09IGJ1ZmZlcikgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuZnJhbWVidWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBidWZmZXIpO1xuICB9XG5cbiAgZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbiwgd2ViZ2wyRnVuYywgZXh0RnVuYykge1xuICAgIC8vIGlmIHdlYmdsMiBmdW5jdGlvbiBzdXBwb3J0ZWQsIHJldHVybiBmdW5jIGJvdW5kIHRvIGdsIGNvbnRleHRcbiAgICBpZiAod2ViZ2wyRnVuYyAmJiB0aGlzLmdsW3dlYmdsMkZ1bmNdKSByZXR1cm4gdGhpcy5nbFt3ZWJnbDJGdW5jXS5iaW5kKHRoaXMuZ2wpOyAvLyBmZXRjaCBleHRlbnNpb24gb25jZSBvbmx5XG5cbiAgICBpZiAoIXRoaXMuZXh0ZW5zaW9uc1tleHRlbnNpb25dKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXSA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gICAgfSAvLyByZXR1cm4gZXh0ZW5zaW9uIGlmIG5vIGZ1bmN0aW9uIHJlcXVlc3RlZFxuXG5cbiAgICBpZiAoIXdlYmdsMkZ1bmMpIHJldHVybiB0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXTsgLy8gUmV0dXJuIG51bGwgaWYgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWRcblxuICAgIGlmICghdGhpcy5leHRlbnNpb25zW2V4dGVuc2lvbl0pIHJldHVybiBudWxsOyAvLyByZXR1cm4gZXh0ZW5zaW9uIGZ1bmN0aW9uLCBib3VuZCB0byBleHRlbnNpb25cblxuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXVtleHRGdW5jXS5iaW5kKHRoaXMuZXh0ZW5zaW9uc1tleHRlbnNpb25dKTtcbiAgfVxuXG4gIHNvcnRPcGFxdWUoYSwgYikge1xuICAgIGlmIChhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyKSB7XG4gICAgICByZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG4gICAgfSBlbHNlIGlmIChhLnByb2dyYW0uaWQgIT09IGIucHJvZ3JhbS5pZCkge1xuICAgICAgcmV0dXJuIGEucHJvZ3JhbS5pZCAtIGIucHJvZ3JhbS5pZDtcbiAgICB9IGVsc2UgaWYgKGEuekRlcHRoICE9PSBiLnpEZXB0aCkge1xuICAgICAgcmV0dXJuIGEuekRlcHRoIC0gYi56RGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcbiAgICB9XG4gIH1cblxuICBzb3J0VHJhbnNwYXJlbnQoYSwgYikge1xuICAgIGlmIChhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyKSB7XG4gICAgICByZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG4gICAgfVxuXG4gICAgaWYgKGEuekRlcHRoICE9PSBiLnpEZXB0aCkge1xuICAgICAgcmV0dXJuIGIuekRlcHRoIC0gYS56RGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcbiAgICB9XG4gIH1cblxuICBzb3J0VUkoYSwgYikge1xuICAgIGlmIChhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyKSB7XG4gICAgICByZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG4gICAgfSBlbHNlIGlmIChhLnByb2dyYW0uaWQgIT09IGIucHJvZ3JhbS5pZCkge1xuICAgICAgcmV0dXJuIGEucHJvZ3JhbS5pZCAtIGIucHJvZ3JhbS5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xuICAgIH1cbiAgfVxuXG4gIGdldFJlbmRlckxpc3Qoe1xuICAgIHNjZW5lLFxuICAgIGNhbWVyYSxcbiAgICBmcnVzdHVtQ3VsbCxcbiAgICBzb3J0XG4gIH0pIHtcbiAgICBsZXQgcmVuZGVyTGlzdCA9IFtdO1xuICAgIGlmIChjYW1lcmEgJiYgZnJ1c3R1bUN1bGwpIGNhbWVyYS51cGRhdGVGcnVzdHVtKCk7IC8vIEdldCB2aXNpYmxlXG5cbiAgICBzY2VuZS50cmF2ZXJzZShub2RlID0+IHtcbiAgICAgIGlmICghbm9kZS52aXNpYmxlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICghbm9kZS5kcmF3KSByZXR1cm47XG5cbiAgICAgIGlmIChmcnVzdHVtQ3VsbCAmJiBub2RlLmZydXN0dW1DdWxsZWQgJiYgY2FtZXJhKSB7XG4gICAgICAgIGlmICghY2FtZXJhLmZydXN0dW1JbnRlcnNlY3RzTWVzaChub2RlKSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJMaXN0LnB1c2gobm9kZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgY29uc3Qgb3BhcXVlID0gW107XG4gICAgICBjb25zdCB0cmFuc3BhcmVudCA9IFtdOyAvLyBkZXB0aFRlc3QgdHJ1ZVxuXG4gICAgICBjb25zdCB1aSA9IFtdOyAvLyBkZXB0aFRlc3QgZmFsc2VcblxuICAgICAgcmVuZGVyTGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAvLyBTcGxpdCBpbnRvIHRoZSAzIHJlbmRlciBncm91cHNcbiAgICAgICAgaWYgKCFub2RlLnByb2dyYW0udHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICBvcGFxdWUucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnByb2dyYW0uZGVwdGhUZXN0KSB7XG4gICAgICAgICAgdHJhbnNwYXJlbnQucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1aS5wdXNoKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS56RGVwdGggPSAwOyAvLyBPbmx5IGNhbGN1bGF0ZSB6LWRlcHRoIGlmIHJlbmRlck9yZGVyIHVuc2V0IGFuZCBkZXB0aFRlc3QgaXMgdHJ1ZVxuXG4gICAgICAgIGlmIChub2RlLnJlbmRlck9yZGVyICE9PSAwIHx8ICFub2RlLnByb2dyYW0uZGVwdGhUZXN0IHx8ICFjYW1lcmEpIHJldHVybjsgLy8gdXBkYXRlIHotZGVwdGhcblxuICAgICAgICBub2RlLndvcmxkTWF0cml4LmdldFRyYW5zbGF0aW9uKHRlbXBWZWMzKTtcbiAgICAgICAgdGVtcFZlYzMuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uVmlld01hdHJpeCk7XG4gICAgICAgIG5vZGUuekRlcHRoID0gdGVtcFZlYzMuejtcbiAgICAgIH0pO1xuICAgICAgb3BhcXVlLnNvcnQodGhpcy5zb3J0T3BhcXVlKTtcbiAgICAgIHRyYW5zcGFyZW50LnNvcnQodGhpcy5zb3J0VHJhbnNwYXJlbnQpO1xuICAgICAgdWkuc29ydCh0aGlzLnNvcnRVSSk7XG4gICAgICByZW5kZXJMaXN0ID0gb3BhcXVlLmNvbmNhdCh0cmFuc3BhcmVudCwgdWkpO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJMaXN0O1xuICB9XG5cbiAgcmVuZGVyKHtcbiAgICBzY2VuZSxcbiAgICBjYW1lcmEsXG4gICAgdGFyZ2V0ID0gbnVsbCxcbiAgICB1cGRhdGUgPSB0cnVlLFxuICAgIHNvcnQgPSB0cnVlLFxuICAgIGZydXN0dW1DdWxsID0gdHJ1ZSxcbiAgICBjbGVhclxuICB9KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgLy8gbWFrZSBzdXJlIG5vIHJlbmRlciB0YXJnZXQgYm91bmQgc28gZHJhd3MgdG8gY2FudmFzXG4gICAgICB0aGlzLmJpbmRGcmFtZWJ1ZmZlcigpO1xuICAgICAgdGhpcy5zZXRWaWV3cG9ydCh0aGlzLndpZHRoICogdGhpcy5kcHIsIHRoaXMuaGVpZ2h0ICogdGhpcy5kcHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBiaW5kIHN1cHBsaWVkIHJlbmRlciB0YXJnZXQgYW5kIHVwZGF0ZSB2aWV3cG9ydFxuICAgICAgdGhpcy5iaW5kRnJhbWVidWZmZXIodGFyZ2V0KTtcbiAgICAgIHRoaXMuc2V0Vmlld3BvcnQodGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAoY2xlYXIgfHwgdGhpcy5hdXRvQ2xlYXIgJiYgY2xlYXIgIT09IGZhbHNlKSB7XG4gICAgICAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZFxuICAgICAgaWYgKHRoaXMuZGVwdGggJiYgKCF0YXJnZXQgfHwgdGFyZ2V0LmRlcHRoKSkge1xuICAgICAgICB0aGlzLmVuYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgICAgICB0aGlzLnNldERlcHRoTWFzayh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5nbC5jbGVhcigodGhpcy5jb2xvciA/IHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCA6IDApIHwgKHRoaXMuZGVwdGggPyB0aGlzLmdsLkRFUFRIX0JVRkZFUl9CSVQgOiAwKSB8ICh0aGlzLnN0ZW5jaWwgPyB0aGlzLmdsLlNURU5DSUxfQlVGRkVSX0JJVCA6IDApKTtcbiAgICB9IC8vIHVwZGF0ZXMgYWxsIHNjZW5lIGdyYXBoIG1hdHJpY2VzXG5cblxuICAgIGlmICh1cGRhdGUpIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7IC8vIFVwZGF0ZSBjYW1lcmEgc2VwYXJhdGVseSwgaW4gY2FzZSBub3QgaW4gc2NlbmUgZ3JhcGhcblxuICAgIGlmIChjYW1lcmEpIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpOyAvLyBHZXQgcmVuZGVyIGxpc3QgLSBlbnRhaWxzIGN1bGxpbmcgYW5kIHNvcnRpbmdcblxuICAgIGNvbnN0IHJlbmRlckxpc3QgPSB0aGlzLmdldFJlbmRlckxpc3Qoe1xuICAgICAgc2NlbmUsXG4gICAgICBjYW1lcmEsXG4gICAgICBmcnVzdHVtQ3VsbCxcbiAgICAgIHNvcnRcbiAgICB9KTtcbiAgICByZW5kZXJMaXN0LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBub2RlLmRyYXcoe1xuICAgICAgICBjYW1lcmFcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn0iLCJjb25zdCBFUFNJTE9OID0gMC4wMDAwMDE7XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6LCB3KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgbGV0IHggPSBhWzBdO1xuICBsZXQgeSA9IGFbMV07XG4gIGxldCB6ID0gYVsyXTtcbiAgbGV0IHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCB3ID0gYVszXTtcbiAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0geCAqIGxlbjtcbiAgb3V0WzFdID0geSAqIGxlbjtcbiAgb3V0WzJdID0geiAqIGxlbjtcbiAgb3V0WzNdID0gdyAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICBsZXQgYXggPSBhWzBdO1xuICBsZXQgYXkgPSBhWzFdO1xuICBsZXQgYXogPSBhWzJdO1xuICBsZXQgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgcmV0dXJuIG91dDtcbn0iLCJpbXBvcnQgKiBhcyB2ZWM0IGZyb20gJy4vVmVjNEZ1bmMuanMnO1xuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBeGlzQW5nbGUob3V0LCBheGlzLCByYWQpIHtcbiAgcmFkID0gcmFkICogMC41O1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXRzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIGxldCBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuICBsZXQgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICBsZXQgYnggPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIGxldCBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIGxldCBieSA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgbGV0IGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgbGV0IGJ6ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgLy8gYmVuY2htYXJrczpcbiAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcbiAgbGV0IGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgbGV0IGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXSxcbiAgICAgIGJ3ID0gYlszXTtcbiAgbGV0IG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxOyAvLyBjYWxjIGNvc2luZVxuXG4gIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidzsgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG5cbiAgaWYgKGNvc29tIDwgMC4wKSB7XG4gICAgY29zb20gPSAtY29zb207XG4gICAgYnggPSAtYng7XG4gICAgYnkgPSAtYnk7XG4gICAgYnogPSAtYno7XG4gICAgYncgPSAtYnc7XG4gIH0gLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuXG5cbiAgaWYgKDEuMCAtIGNvc29tID4gMC4wMDAwMDEpIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICBzY2FsZTEgPSB0O1xuICB9IC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcblxuXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIGxldCBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICBsZXQgaW52RG90ID0gZG90ID8gMS4wIC8gZG90IDogMDsgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICBvdXRbMF0gPSAtYTAgKiBpbnZEb3Q7XG4gIG91dFsxXSA9IC1hMSAqIGludkRvdDtcbiAgb3V0WzJdID0gLWEyICogaW52RG90O1xuICBvdXRbM10gPSBhMyAqIGludkRvdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDMob3V0LCBtKSB7XG4gIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICBsZXQgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICBsZXQgZlJvb3Q7XG5cbiAgaWYgKGZUcmFjZSA+IDAuMCkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAvLyAyd1xuXG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsgLy8gMS8oNHcpXG5cbiAgICBvdXRbMF0gPSAobVs1XSAtIG1bN10pICogZlJvb3Q7XG4gICAgb3V0WzFdID0gKG1bNl0gLSBtWzJdKSAqIGZSb290O1xuICAgIG91dFsyXSA9IChtWzFdIC0gbVszXSkgKiBmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgbGV0IGkgPSAwO1xuICAgIGlmIChtWzRdID4gbVswXSkgaSA9IDE7XG4gICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pIGkgPSAyO1xuICAgIGxldCBqID0gKGkgKyAxKSAlIDM7XG4gICAgbGV0IGsgPSAoaSArIDIpICUgMztcbiAgICBmUm9vdCA9IE1hdGguc3FydChtW2kgKiAzICsgaV0gLSBtW2ogKiAzICsgal0gLSBtW2sgKiAzICsga10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiAqIDMgKyBrXSAtIG1bayAqIDMgKyBqXSkgKiBmUm9vdDtcbiAgICBvdXRbal0gPSAobVtqICogMyArIGldICsgbVtpICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sgKiAzICsgaV0gKyBtW2kgKiAzICsga10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBldWxlciBhbmdsZSB4LCB5LCB6LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBldWxlciBBbmdsZXMgdG8gcm90YXRlIGFyb3VuZCBlYWNoIGF4aXMgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlciBkZXRhaWxpbmcgb3JkZXIgb2Ygb3BlcmF0aW9ucy4gRGVmYXVsdCAnWFlaJy5cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXVsZXIob3V0LCBldWxlciwgb3JkZXIgPSAnWVhaJykge1xuICBsZXQgc3ggPSBNYXRoLnNpbihldWxlclswXSAqIDAuNSk7XG4gIGxldCBjeCA9IE1hdGguY29zKGV1bGVyWzBdICogMC41KTtcbiAgbGV0IHN5ID0gTWF0aC5zaW4oZXVsZXJbMV0gKiAwLjUpO1xuICBsZXQgY3kgPSBNYXRoLmNvcyhldWxlclsxXSAqIDAuNSk7XG4gIGxldCBzeiA9IE1hdGguc2luKGV1bGVyWzJdICogMC41KTtcbiAgbGV0IGN6ID0gTWF0aC5jb3MoZXVsZXJbMl0gKiAwLjUpO1xuXG4gIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcbiAgICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XG4gICAgb3V0WzFdID0gY3ggKiBzeSAqIGN6IC0gc3ggKiBjeSAqIHN6O1xuICAgIG91dFsyXSA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcbiAgICBvdXRbM10gPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XG4gIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWFonKSB7XG4gICAgb3V0WzBdID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xuICAgIG91dFsxXSA9IGN4ICogc3kgKiBjeiAtIHN4ICogY3kgKiBzejtcbiAgICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gICAgb3V0WzNdID0gY3ggKiBjeSAqIGN6ICsgc3ggKiBzeSAqIHN6O1xuICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWlhZJykge1xuICAgIG91dFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgICBvdXRbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gICAgb3V0WzJdID0gY3ggKiBjeSAqIHN6ICsgc3ggKiBzeSAqIGN6O1xuICAgIG91dFszXSA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcbiAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHtcbiAgICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gICAgb3V0WzFdID0gY3ggKiBzeSAqIGN6ICsgc3ggKiBjeSAqIHN6O1xuICAgIG91dFsyXSA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcbiAgICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7XG4gICAgb3V0WzBdID0gc3ggKiBjeSAqIGN6ICsgY3ggKiBzeSAqIHN6O1xuICAgIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gICAgb3V0WzNdID0gY3ggKiBjeSAqIGN6IC0gc3ggKiBzeSAqIHN6O1xuICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykge1xuICAgIG91dFswXSA9IHN4ICogY3kgKiBjeiAtIGN4ICogc3kgKiBzejtcbiAgICBvdXRbMV0gPSBjeCAqIHN5ICogY3ogLSBzeCAqIGN5ICogc3o7XG4gICAgb3V0WzJdID0gY3ggKiBjeSAqIHN6ICsgc3ggKiBzeSAqIGN6O1xuICAgIG91dFszXSA9IGN4ICogY3kgKiBjeiArIHN4ICogc3kgKiBzejtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCBjb25zdCBjb3B5ID0gdmVjNC5jb3B5O1xuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgY29uc3Qgc2V0ID0gdmVjNC5zZXQ7XG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgY29uc3QgYWRkID0gdmVjNC5hZGQ7XG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IGNvbnN0IHNjYWxlID0gdmVjNC5zY2FsZTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IGNvbnN0IGRvdCA9IHZlYzQuZG90O1xuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgY29uc3QgbGVycCA9IHZlYzQubGVycDtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gdmVjNC5sZW5ndGg7XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplOyIsImltcG9ydCAqIGFzIFF1YXRGdW5jIGZyb20gJy4vZnVuY3Rpb25zL1F1YXRGdW5jLmpzJztcbmV4cG9ydCBjbGFzcyBRdWF0IGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSkge1xuICAgIHN1cGVyKHgsIHksIHosIHcpO1xuXG4gICAgdGhpcy5vbkNoYW5nZSA9ICgpID0+IHt9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpc1swXTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzWzFdO1xuICB9XG5cbiAgZ2V0IHooKSB7XG4gICAgcmV0dXJuIHRoaXNbMl07XG4gIH1cblxuICBnZXQgdygpIHtcbiAgICByZXR1cm4gdGhpc1szXTtcbiAgfVxuXG4gIHNldCB4KHYpIHtcbiAgICB0aGlzWzBdID0gdjtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gIH1cblxuICBzZXQgeSh2KSB7XG4gICAgdGhpc1sxXSA9IHY7XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICB9XG5cbiAgc2V0IHoodikge1xuICAgIHRoaXNbMl0gPSB2O1xuICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgfVxuXG4gIHNldCB3KHYpIHtcbiAgICB0aGlzWzNdID0gdjtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gIH1cblxuICBpZGVudGl0eSgpIHtcbiAgICBRdWF0RnVuYy5pZGVudGl0eSh0aGlzKTtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXQoeCwgeSwgeiwgdykge1xuICAgIGlmICh4Lmxlbmd0aCkgcmV0dXJuIHRoaXMuY29weSh4KTtcbiAgICBRdWF0RnVuYy5zZXQodGhpcywgeCwgeSwgeiwgdyk7XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcm90YXRlWChhKSB7XG4gICAgUXVhdEZ1bmMucm90YXRlWCh0aGlzLCB0aGlzLCBhKTtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByb3RhdGVZKGEpIHtcbiAgICBRdWF0RnVuYy5yb3RhdGVZKHRoaXMsIHRoaXMsIGEpO1xuICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZVooYSkge1xuICAgIFF1YXRGdW5jLnJvdGF0ZVoodGhpcywgdGhpcywgYSk7XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW52ZXJzZShxID0gdGhpcykge1xuICAgIFF1YXRGdW5jLmludmVydCh0aGlzLCBxKTtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25qdWdhdGUocSA9IHRoaXMpIHtcbiAgICBRdWF0RnVuYy5jb25qdWdhdGUodGhpcywgcSk7XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29weShxKSB7XG4gICAgUXVhdEZ1bmMuY29weSh0aGlzLCBxKTtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBub3JtYWxpemUocSA9IHRoaXMpIHtcbiAgICBRdWF0RnVuYy5ub3JtYWxpemUodGhpcywgcSk7XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbXVsdGlwbHkocUEsIHFCKSB7XG4gICAgaWYgKHFCKSB7XG4gICAgICBRdWF0RnVuYy5tdWx0aXBseSh0aGlzLCBxQSwgcUIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBRdWF0RnVuYy5tdWx0aXBseSh0aGlzLCB0aGlzLCBxQSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZG90KHYpIHtcbiAgICByZXR1cm4gUXVhdEZ1bmMuZG90KHRoaXMsIHYpO1xuICB9XG5cbiAgZnJvbU1hdHJpeDMobWF0cml4Mykge1xuICAgIFF1YXRGdW5jLmZyb21NYXQzKHRoaXMsIG1hdHJpeDMpO1xuICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZyb21FdWxlcihldWxlcikge1xuICAgIFF1YXRGdW5jLmZyb21FdWxlcih0aGlzLCBldWxlciwgZXVsZXIub3JkZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbUF4aXNBbmdsZShheGlzLCBhKSB7XG4gICAgUXVhdEZ1bmMuc2V0QXhpc0FuZ2xlKHRoaXMsIGF4aXMsIGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2xlcnAocSwgdCkge1xuICAgIFF1YXRGdW5jLnNsZXJwKHRoaXMsIHRoaXMsIHEsIHQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbUFycmF5KGEsIG8gPSAwKSB7XG4gICAgdGhpc1swXSA9IGFbb107XG4gICAgdGhpc1sxXSA9IGFbbyArIDFdO1xuICAgIHRoaXNbMl0gPSBhW28gKyAyXTtcbiAgICB0aGlzWzNdID0gYVtvICsgM107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0FycmF5KGEgPSBbXSwgbyA9IDApIHtcbiAgICBhW29dID0gdGhpc1swXTtcbiAgICBhW28gKyAxXSA9IHRoaXNbMV07XG4gICAgYVtvICsgMl0gPSB0aGlzWzJdO1xuICAgIGFbbyArIDNdID0gdGhpc1szXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG59IiwiY29uc3QgRVBTSUxPTiA9IDAuMDAwMDAxO1xuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTAzO1xuICBvdXRbNF0gPSBtMTA7XG4gIG91dFs1XSA9IG0xMTtcbiAgb3V0WzZdID0gbTEyO1xuICBvdXRbN10gPSBtMTM7XG4gIG91dFs4XSA9IG0yMDtcbiAgb3V0WzldID0gbTIxO1xuICBvdXRbMTBdID0gbTIyO1xuICBvdXRbMTFdID0gbTIzO1xuICBvdXRbMTJdID0gbTMwO1xuICBvdXRbMTNdID0gbTMxO1xuICBvdXRbMTRdID0gbTMyO1xuICBvdXRbMTVdID0gbTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGxldCBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdO1xuICAgIGxldCBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuICAgIGxldCBhMjMgPSBhWzExXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICBsZXQgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICBsZXQgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICBsZXQgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICBsZXQgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBsZXQgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICBsZXQgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICBsZXQgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICBsZXQgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICBsZXQgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICBsZXQgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICBsZXQgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICBsZXQgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIGxldCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIGxldCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGxldCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIGxldCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGxldCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIGxldCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGxldCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIGxldCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdOyAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcblxuICBsZXQgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzFdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsyXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbM10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzRdO1xuICBiMSA9IGJbNV07XG4gIGIyID0gYls2XTtcbiAgYjMgPSBiWzddO1xuICBvdXRbNF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzVdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFs2XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbN10gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzhdO1xuICBiMSA9IGJbOV07XG4gIGIyID0gYlsxMF07XG4gIGIzID0gYlsxMV07XG4gIG91dFs4XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbOV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzEwXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTFdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYlsxMl07XG4gIGIxID0gYlsxM107XG4gIGIyID0gYlsxNF07XG4gIGIzID0gYlsxNV07XG4gIG91dFsxMl0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzEzXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTRdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxNV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBsZXQgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBsZXQgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICBsZXQgYTEwLCBhMTEsIGExMiwgYTEzO1xuICBsZXQgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gIGlmIChhID09PSBvdXQpIHtcbiAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgfSBlbHNlIHtcbiAgICBhMDAgPSBhWzBdO1xuICAgIGEwMSA9IGFbMV07XG4gICAgYTAyID0gYVsyXTtcbiAgICBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07XG4gICAgYTExID0gYVs1XTtcbiAgICBhMTIgPSBhWzZdO1xuICAgIGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTtcbiAgICBhMjEgPSBhWzldO1xuICAgIGEyMiA9IGFbMTBdO1xuICAgIGEyMyA9IGFbMTFdO1xuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuICAgIG91dFszXSA9IGEwMztcbiAgICBvdXRbNF0gPSBhMTA7XG4gICAgb3V0WzVdID0gYTExO1xuICAgIG91dFs2XSA9IGExMjtcbiAgICBvdXRbN10gPSBhMTM7XG4gICAgb3V0WzhdID0gYTIwO1xuICAgIG91dFs5XSA9IGEyMTtcbiAgICBvdXRbMTBdID0gYTIyO1xuICAgIG91dFsxMV0gPSBhMjM7XG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIGxldCB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIGxldCBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICBsZXQgcywgYywgdDtcbiAgbGV0IGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgbGV0IGExMCwgYTExLCBhMTIsIGExMztcbiAgbGV0IGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgbGV0IGIwMCwgYjAxLCBiMDI7XG4gIGxldCBiMTAsIGIxMSwgYjEyO1xuICBsZXQgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAoTWF0aC5hYnMobGVuKSA8IEVQU0lMT04pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG4gIHMgPSBNYXRoLnNpbihyYWQpO1xuICBjID0gTWF0aC5jb3MocmFkKTtcbiAgdCA9IDEgLSBjO1xuICBhMDAgPSBhWzBdO1xuICBhMDEgPSBhWzFdO1xuICBhMDIgPSBhWzJdO1xuICBhMDMgPSBhWzNdO1xuICBhMTAgPSBhWzRdO1xuICBhMTEgPSBhWzVdO1xuICBhMTIgPSBhWzZdO1xuICBhMTMgPSBhWzddO1xuICBhMjAgPSBhWzhdO1xuICBhMjEgPSBhWzldO1xuICBhMjIgPSBhWzEwXTtcbiAgYTIzID0gYVsxMV07IC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuXG4gIGIwMCA9IHggKiB4ICogdCArIGM7XG4gIGIwMSA9IHkgKiB4ICogdCArIHogKiBzO1xuICBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7XG4gIGIxMSA9IHkgKiB5ICogdCArIGM7XG4gIGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICBiMjAgPSB4ICogeiAqIHQgKyB5ICogcztcbiAgYjIxID0geSAqIHogKiB0IC0geCAqIHM7XG4gIGIyMiA9IHogKiB6ICogdCArIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0gIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcbiAqICB3aXRoIGEgbm9ybWFsaXplZCBRdWF0ZXJuaW9uIHBhcmFtdGVyLCB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmVcbiAqICB0aGUgc2FtZSBhcyB0aGUgc2NhbGluZyB2ZWN0b3JcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxuICogQHBhcmFtICB7dmVjM30gb3V0IFZlY3RvciB0byByZWNlaXZlIHNjYWxpbmcgZmFjdG9yIGNvbXBvbmVudFxuICogQHBhcmFtICB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2FsaW5nKG91dCwgbWF0KSB7XG4gIGxldCBtMTEgPSBtYXRbMF07XG4gIGxldCBtMTIgPSBtYXRbMV07XG4gIGxldCBtMTMgPSBtYXRbMl07XG4gIGxldCBtMjEgPSBtYXRbNF07XG4gIGxldCBtMjIgPSBtYXRbNV07XG4gIGxldCBtMjMgPSBtYXRbNl07XG4gIGxldCBtMzEgPSBtYXRbOF07XG4gIGxldCBtMzIgPSBtYXRbOV07XG4gIGxldCBtMzMgPSBtYXRbMTBdO1xuICBvdXRbMF0gPSBNYXRoLmh5cG90KG0xMSwgbTEyLCBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLmh5cG90KG0yMSwgbTIyLCBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLmh5cG90KG0zMSwgbTMyLCBtMzMpO1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heFNjYWxlT25BeGlzKG1hdCkge1xuICBsZXQgbTExID0gbWF0WzBdO1xuICBsZXQgbTEyID0gbWF0WzFdO1xuICBsZXQgbTEzID0gbWF0WzJdO1xuICBsZXQgbTIxID0gbWF0WzRdO1xuICBsZXQgbTIyID0gbWF0WzVdO1xuICBsZXQgbTIzID0gbWF0WzZdO1xuICBsZXQgbTMxID0gbWF0WzhdO1xuICBsZXQgbTMyID0gbWF0WzldO1xuICBsZXQgbTMzID0gbWF0WzEwXTtcbiAgY29uc3QgeCA9IG0xMSAqIG0xMSArIG0xMiAqIG0xMiArIG0xMyAqIG0xMztcbiAgY29uc3QgeSA9IG0yMSAqIG0yMSArIG0yMiAqIG0yMiArIG0yMyAqIG0yMztcbiAgY29uc3QgeiA9IG0zMSAqIG0zMSArIG0zMiAqIG0zMiArIG0zMyAqIG0zMztcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heCh4LCB5LCB6KSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0ge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xuXG5leHBvcnQgY29uc3QgZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHRlbXAgPSBbMCwgMCwgMF07XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBtYXQpIHtcbiAgICBsZXQgc2NhbGluZyA9IHRlbXA7XG4gICAgZ2V0U2NhbGluZyhzY2FsaW5nLCBtYXQpO1xuICAgIGxldCBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgICBsZXQgaXMyID0gMSAvIHNjYWxpbmdbMV07XG4gICAgbGV0IGlzMyA9IDEgLyBzY2FsaW5nWzJdO1xuICAgIGxldCBzbTExID0gbWF0WzBdICogaXMxO1xuICAgIGxldCBzbTEyID0gbWF0WzFdICogaXMyO1xuICAgIGxldCBzbTEzID0gbWF0WzJdICogaXMzO1xuICAgIGxldCBzbTIxID0gbWF0WzRdICogaXMxO1xuICAgIGxldCBzbTIyID0gbWF0WzVdICogaXMyO1xuICAgIGxldCBzbTIzID0gbWF0WzZdICogaXMzO1xuICAgIGxldCBzbTMxID0gbWF0WzhdICogaXMxO1xuICAgIGxldCBzbTMyID0gbWF0WzldICogaXMyO1xuICAgIGxldCBzbTMzID0gbWF0WzEwXSAqIGlzMztcbiAgICBsZXQgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gICAgbGV0IFMgPSAwO1xuXG4gICAgaWYgKHRyYWNlID4gMCkge1xuICAgICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgICBvdXRbMF0gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgICAgb3V0WzJdID0gKHNtMTIgLSBzbTIxKSAvIFM7XG4gICAgfSBlbHNlIGlmIChzbTExID4gc20yMiAmJiBzbTExID4gc20zMykge1xuICAgICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICAgIG91dFszXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgICAgb3V0WzBdID0gMC4yNSAqIFM7XG4gICAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICAgIG91dFsyXSA9IChzbTMxICsgc20xMykgLyBTO1xuICAgIH0gZWxzZSBpZiAoc20yMiA+IHNtMzMpIHtcbiAgICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgICBvdXRbM10gPSAoc20zMSAtIHNtMTMpIC8gUztcbiAgICAgIG91dFswXSA9IChzbTEyICsgc20yMSkgLyBTO1xuICAgICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgICBvdXRbMl0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICB9IGVsc2Uge1xuICAgICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICAgIG91dFszXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICAgICAgb3V0WzBdID0gKHNtMzEgKyBzbTEzKSAvIFM7XG4gICAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCk7XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHh5ID0geCAqIHkyO1xuICBsZXQgeHogPSB4ICogejI7XG4gIGxldCB5eSA9IHkgKiB5MjtcbiAgbGV0IHl6ID0geSAqIHoyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG4gIGxldCBzeCA9IHNbMF07XG4gIGxldCBzeSA9IHNbMV07XG4gIGxldCBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICBsZXQgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHl4ID0geSAqIHgyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB6eCA9IHogKiB4MjtcbiAgbGV0IHp5ID0geiAqIHkyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgbGV0IGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMik7XG4gIGxldCBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IGY7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAyICogZmFyICogbmVhciAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICBsZXQgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIGxldCBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF0cml4IHRoYXQgbWFrZXMgc29tZXRoaW5nIGxvb2sgYXQgc29tZXRoaW5nIGVsc2UuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSB0YXJnZXQgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgbGV0IGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcbiAgbGV0IHowID0gZXlleCAtIHRhcmdldFswXSxcbiAgICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcbiAgbGV0IGxlbiA9IHowICogejAgKyB6MSAqIHoxICsgejIgKiB6MjtcblxuICBpZiAobGVuID09PSAwKSB7XG4gICAgLy8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgejIgPSAxO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcbiAgfVxuXG4gIGxldCB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcblxuICBpZiAobGVuID09PSAwKSB7XG4gICAgLy8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXG4gICAgaWYgKHVweikge1xuICAgICAgdXB4ICs9IDFlLTY7XG4gICAgfSBlbHNlIGlmICh1cHkpIHtcbiAgICAgIHVweiArPSAxZS02O1xuICAgIH0gZWxzZSB7XG4gICAgICB1cHkgKz0gMWUtNjtcbiAgICB9XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsIHgxID0gdXB6ICogejAgLSB1cHggKiB6MiwgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcbiAgfVxuXG4gIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgeDAgKj0gbGVuO1xuICB4MSAqPSBsZW47XG4gIHgyICo9IGxlbjtcbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHgxO1xuICBvdXRbMl0gPSB4MjtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gejEgKiB4MiAtIHoyICogeDE7XG4gIG91dFs1XSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICBvdXRbNl0gPSB6MCAqIHgxIC0gejEgKiB4MDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gejA7XG4gIG91dFs5XSA9IHoxO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gZXlleDtcbiAgb3V0WzEzXSA9IGV5ZXk7XG4gIG91dFsxNF0gPSBleWV6O1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufSIsImltcG9ydCAqIGFzIE1hdDRGdW5jIGZyb20gJy4vZnVuY3Rpb25zL01hdDRGdW5jLmpzJztcbmV4cG9ydCBjbGFzcyBNYXQ0IGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcihtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMDMgPSAwLCBtMTAgPSAwLCBtMTEgPSAxLCBtMTIgPSAwLCBtMTMgPSAwLCBtMjAgPSAwLCBtMjEgPSAwLCBtMjIgPSAxLCBtMjMgPSAwLCBtMzAgPSAwLCBtMzEgPSAwLCBtMzIgPSAwLCBtMzMgPSAxKSB7XG4gICAgc3VwZXIobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzWzEyXTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzWzEzXTtcbiAgfVxuXG4gIGdldCB6KCkge1xuICAgIHJldHVybiB0aGlzWzE0XTtcbiAgfVxuXG4gIGdldCB3KCkge1xuICAgIHJldHVybiB0aGlzWzE1XTtcbiAgfVxuXG4gIHNldCB4KHYpIHtcbiAgICB0aGlzWzEyXSA9IHY7XG4gIH1cblxuICBzZXQgeSh2KSB7XG4gICAgdGhpc1sxM10gPSB2O1xuICB9XG5cbiAgc2V0IHoodikge1xuICAgIHRoaXNbMTRdID0gdjtcbiAgfVxuXG4gIHNldCB3KHYpIHtcbiAgICB0aGlzWzE1XSA9IHY7XG4gIH1cblxuICBzZXQobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gICAgaWYgKG0wMC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkobTAwKTtcbiAgICBNYXQ0RnVuYy5zZXQodGhpcywgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyYW5zbGF0ZSh2LCBtID0gdGhpcykge1xuICAgIE1hdDRGdW5jLnRyYW5zbGF0ZSh0aGlzLCBtLCB2KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZSh2LCBheGlzLCBtID0gdGhpcykge1xuICAgIE1hdDRGdW5jLnJvdGF0ZSh0aGlzLCBtLCB2LCBheGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNjYWxlKHYsIG0gPSB0aGlzKSB7XG4gICAgTWF0NEZ1bmMuc2NhbGUodGhpcywgbSwgdHlwZW9mIHYgPT09ICdudW1iZXInID8gW3YsIHYsIHZdIDogdik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWx0aXBseShtYSwgbWIpIHtcbiAgICBpZiAobWIpIHtcbiAgICAgIE1hdDRGdW5jLm11bHRpcGx5KHRoaXMsIG1hLCBtYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE1hdDRGdW5jLm11bHRpcGx5KHRoaXMsIHRoaXMsIG1hKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlkZW50aXR5KCkge1xuICAgIE1hdDRGdW5jLmlkZW50aXR5KHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29weShtKSB7XG4gICAgTWF0NEZ1bmMuY29weSh0aGlzLCBtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZyb21QZXJzcGVjdGl2ZSh7XG4gICAgZm92LFxuICAgIGFzcGVjdCxcbiAgICBuZWFyLFxuICAgIGZhclxuICB9ID0ge30pIHtcbiAgICBNYXQ0RnVuYy5wZXJzcGVjdGl2ZSh0aGlzLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZyb21PcnRob2dvbmFsKHtcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICB0b3AsXG4gICAgbmVhcixcbiAgICBmYXJcbiAgfSkge1xuICAgIE1hdDRGdW5jLm9ydGhvKHRoaXMsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZyb21RdWF0ZXJuaW9uKHEpIHtcbiAgICBNYXQ0RnVuYy5mcm9tUXVhdCh0aGlzLCBxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFBvc2l0aW9uKHYpIHtcbiAgICB0aGlzLnggPSB2WzBdO1xuICAgIHRoaXMueSA9IHZbMV07XG4gICAgdGhpcy56ID0gdlsyXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludmVyc2UobSA9IHRoaXMpIHtcbiAgICBNYXQ0RnVuYy5pbnZlcnQodGhpcywgbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb21wb3NlKHEsIHBvcywgc2NhbGUpIHtcbiAgICBNYXQ0RnVuYy5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKHRoaXMsIHEsIHBvcywgc2NhbGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Um90YXRpb24ocSkge1xuICAgIE1hdDRGdW5jLmdldFJvdGF0aW9uKHEsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0VHJhbnNsYXRpb24ocG9zKSB7XG4gICAgTWF0NEZ1bmMuZ2V0VHJhbnNsYXRpb24ocG9zLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldFNjYWxpbmcoc2NhbGUpIHtcbiAgICBNYXQ0RnVuYy5nZXRTY2FsaW5nKHNjYWxlLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldE1heFNjYWxlT25BeGlzKCkge1xuICAgIHJldHVybiBNYXQ0RnVuYy5nZXRNYXhTY2FsZU9uQXhpcyh0aGlzKTtcbiAgfVxuXG4gIGxvb2tBdChleWUsIHRhcmdldCwgdXApIHtcbiAgICBNYXQ0RnVuYy50YXJnZXRUbyh0aGlzLCBleWUsIHRhcmdldCwgdXApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGV0ZXJtaW5hbnQoKSB7XG4gICAgcmV0dXJuIE1hdDRGdW5jLmRldGVybWluYW50KHRoaXMpO1xuICB9XG5cbn0iLCIvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbk1hdHJpeChvdXQsIG0sIG9yZGVyID0gJ1lYWicpIHtcbiAgaWYgKG9yZGVyID09PSAnWFlaJykge1xuICAgIG91dFsxXSA9IE1hdGguYXNpbihNYXRoLm1pbihNYXRoLm1heChtWzhdLCAtMSksIDEpKTtcblxuICAgIGlmIChNYXRoLmFicyhtWzhdKSA8IDAuOTk5OTkpIHtcbiAgICAgIG91dFswXSA9IE1hdGguYXRhbjIoLW1bOV0sIG1bMTBdKTtcbiAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIoLW1bNF0sIG1bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRbMF0gPSBNYXRoLmF0YW4yKG1bNl0sIG1bNV0pO1xuICAgICAgb3V0WzJdID0gMDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWFonKSB7XG4gICAgb3V0WzBdID0gTWF0aC5hc2luKC1NYXRoLm1pbihNYXRoLm1heChtWzldLCAtMSksIDEpKTtcblxuICAgIGlmIChNYXRoLmFicyhtWzldKSA8IDAuOTk5OTkpIHtcbiAgICAgIG91dFsxXSA9IE1hdGguYXRhbjIobVs4XSwgbVsxMF0pO1xuICAgICAgb3V0WzJdID0gTWF0aC5hdGFuMihtWzFdLCBtWzVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0WzFdID0gTWF0aC5hdGFuMigtbVsyXSwgbVswXSk7XG4gICAgICBvdXRbMl0gPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pYWScpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmFzaW4oTWF0aC5taW4oTWF0aC5tYXgobVs2XSwgLTEpLCAxKSk7XG5cbiAgICBpZiAoTWF0aC5hYnMobVs2XSkgPCAwLjk5OTk5KSB7XG4gICAgICBvdXRbMV0gPSBNYXRoLmF0YW4yKC1tWzJdLCBtWzEwXSk7XG4gICAgICBvdXRbMl0gPSBNYXRoLmF0YW4yKC1tWzRdLCBtWzVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0WzFdID0gMDtcbiAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIobVsxXSwgbVswXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuICAgIG91dFsxXSA9IE1hdGguYXNpbigtTWF0aC5taW4oTWF0aC5tYXgobVsyXSwgLTEpLCAxKSk7XG5cbiAgICBpZiAoTWF0aC5hYnMobVsyXSkgPCAwLjk5OTk5KSB7XG4gICAgICBvdXRbMF0gPSBNYXRoLmF0YW4yKG1bNl0sIG1bMTBdKTtcbiAgICAgIG91dFsyXSA9IE1hdGguYXRhbjIobVsxXSwgbVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFswXSA9IDA7XG4gICAgICBvdXRbMl0gPSBNYXRoLmF0YW4yKC1tWzRdLCBtWzVdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7XG4gICAgb3V0WzJdID0gTWF0aC5hc2luKE1hdGgubWluKE1hdGgubWF4KG1bMV0sIC0xKSwgMSkpO1xuXG4gICAgaWYgKE1hdGguYWJzKG1bMV0pIDwgMC45OTk5OSkge1xuICAgICAgb3V0WzBdID0gTWF0aC5hdGFuMigtbVs5XSwgbVs1XSk7XG4gICAgICBvdXRbMV0gPSBNYXRoLmF0YW4yKC1tWzJdLCBtWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IE1hdGguYXRhbjIobVs4XSwgbVsxMF0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1haWScpIHtcbiAgICBvdXRbMl0gPSBNYXRoLmFzaW4oLU1hdGgubWluKE1hdGgubWF4KG1bNF0sIC0xKSwgMSkpO1xuXG4gICAgaWYgKE1hdGguYWJzKG1bNF0pIDwgMC45OTk5OSkge1xuICAgICAgb3V0WzBdID0gTWF0aC5hdGFuMihtWzZdLCBtWzVdKTtcbiAgICAgIG91dFsxXSA9IE1hdGguYXRhbjIobVs4XSwgbVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFswXSA9IE1hdGguYXRhbjIoLW1bOV0sIG1bMTBdKTtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn0iLCJpbXBvcnQgKiBhcyBFdWxlckZ1bmMgZnJvbSAnLi9mdW5jdGlvbnMvRXVsZXJGdW5jLmpzJztcbmltcG9ydCB7IE1hdDQgfSBmcm9tICcuL01hdDQuanMnO1xuY29uc3QgdG1wTWF0NCA9IG5ldyBNYXQ0KCk7XG5leHBvcnQgY2xhc3MgRXVsZXIgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0geCwgeiA9IHgsIG9yZGVyID0gJ1lYWicpIHtcbiAgICBzdXBlcih4LCB5LCB6KTtcbiAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG5cbiAgICB0aGlzLm9uQ2hhbmdlID0gKCkgPT4ge307XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzWzBdO1xuICB9XG5cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXNbMV07XG4gIH1cblxuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpc1syXTtcbiAgfVxuXG4gIHNldCB4KHYpIHtcbiAgICB0aGlzWzBdID0gdjtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gIH1cblxuICBzZXQgeSh2KSB7XG4gICAgdGhpc1sxXSA9IHY7XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICB9XG5cbiAgc2V0IHoodikge1xuICAgIHRoaXNbMl0gPSB2O1xuICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgfVxuXG4gIHNldCh4LCB5ID0geCwgeiA9IHgpIHtcbiAgICBpZiAoeC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkoeCk7XG4gICAgdGhpc1swXSA9IHg7XG4gICAgdGhpc1sxXSA9IHk7XG4gICAgdGhpc1syXSA9IHo7XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29weSh2KSB7XG4gICAgdGhpc1swXSA9IHZbMF07XG4gICAgdGhpc1sxXSA9IHZbMV07XG4gICAgdGhpc1syXSA9IHZbMl07XG4gICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVvcmRlcihvcmRlcikge1xuICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tUm90YXRpb25NYXRyaXgobSwgb3JkZXIgPSB0aGlzLm9yZGVyKSB7XG4gICAgRXVsZXJGdW5jLmZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLCBtLCBvcmRlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tUXVhdGVybmlvbihxLCBvcmRlciA9IHRoaXMub3JkZXIpIHtcbiAgICB0bXBNYXQ0LmZyb21RdWF0ZXJuaW9uKHEpO1xuICAgIHJldHVybiB0aGlzLmZyb21Sb3RhdGlvbk1hdHJpeCh0bXBNYXQ0LCBvcmRlcik7XG4gIH1cblxufSIsImltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuaW1wb3J0IHsgUXVhdCB9IGZyb20gJy4uL21hdGgvUXVhdC5qcyc7XG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSAnLi4vbWF0aC9NYXQ0LmpzJztcbmltcG9ydCB7IEV1bGVyIH0gZnJvbSAnLi4vbWF0aC9FdWxlci5qcyc7XG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdDQoKTtcbiAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdDQoKTtcbiAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0KCk7XG4gICAgdGhpcy5zY2FsZSA9IG5ldyBWZWMzKDEpO1xuICAgIHRoaXMucm90YXRpb24gPSBuZXcgRXVsZXIoKTtcbiAgICB0aGlzLnVwID0gbmV3IFZlYzMoMCwgMSwgMCk7XG5cbiAgICB0aGlzLnJvdGF0aW9uLm9uQ2hhbmdlID0gKCkgPT4gdGhpcy5xdWF0ZXJuaW9uLmZyb21FdWxlcih0aGlzLnJvdGF0aW9uKTtcblxuICAgIHRoaXMucXVhdGVybmlvbi5vbkNoYW5nZSA9ICgpID0+IHRoaXMucm90YXRpb24uZnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgfVxuXG4gIHNldFBhcmVudChwYXJlbnQsIG5vdGlmeVBhcmVudCA9IHRydWUpIHtcbiAgICBpZiAobm90aWZ5UGFyZW50ICYmIHRoaXMucGFyZW50ICYmIHBhcmVudCAhPT0gdGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAobm90aWZ5UGFyZW50ICYmIHBhcmVudCkgcGFyZW50LmFkZENoaWxkKHRoaXMsIGZhbHNlKTtcbiAgfVxuXG4gIGFkZENoaWxkKGNoaWxkLCBub3RpZnlDaGlsZCA9IHRydWUpIHtcbiAgICBpZiAoIX50aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpKSB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIGlmIChub3RpZnlDaGlsZCkgY2hpbGQuc2V0UGFyZW50KHRoaXMsIGZhbHNlKTtcbiAgfVxuXG4gIHJlbW92ZUNoaWxkKGNoaWxkLCBub3RpZnlDaGlsZCA9IHRydWUpIHtcbiAgICBpZiAoISF+dGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSkgdGhpcy5jaGlsZHJlbi5zcGxpY2UodGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSwgMSk7XG4gICAgaWYgKG5vdGlmeUNoaWxkKSBjaGlsZC5zZXRQYXJlbnQobnVsbCwgZmFsc2UpO1xuICB9XG5cbiAgdXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcbiAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgaWYgKHRoaXMud29ybGRNYXRyaXhOZWVkc1VwZGF0ZSB8fCBmb3JjZSkge1xuICAgICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB0aGlzLndvcmxkTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO2Vsc2UgdGhpcy53b3JsZE1hdHJpeC5tdWx0aXBseSh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgdGhpcy53b3JsZE1hdHJpeE5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICBmb3JjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5jaGlsZHJlbltpXS51cGRhdGVNYXRyaXhXb3JsZChmb3JjZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlTWF0cml4KCkge1xuICAgIHRoaXMubWF0cml4LmNvbXBvc2UodGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnNjYWxlKTtcbiAgICB0aGlzLndvcmxkTWF0cml4TmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgdHJhdmVyc2UoY2FsbGJhY2spIHtcbiAgICAvLyBSZXR1cm4gdHJ1ZSBpbiBjYWxsYmFjayB0byBzdG9wIHRyYXZlcnNpbmcgY2hpbGRyZW5cbiAgICBpZiAoY2FsbGJhY2sodGhpcykpIHJldHVybjtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5baV0udHJhdmVyc2UoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIGRlY29tcG9zZSgpIHtcbiAgICB0aGlzLm1hdHJpeC5nZXRUcmFuc2xhdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICB0aGlzLm1hdHJpeC5nZXRSb3RhdGlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHRoaXMubWF0cml4LmdldFNjYWxpbmcodGhpcy5zY2FsZSk7XG4gICAgdGhpcy5yb3RhdGlvbi5mcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICB9XG5cbiAgbG9va0F0KHRhcmdldCwgaW52ZXJ0ID0gZmFsc2UpIHtcbiAgICBpZiAoaW52ZXJ0KSB0aGlzLm1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB0aGlzLnVwKTtlbHNlIHRoaXMubWF0cml4Lmxvb2tBdCh0YXJnZXQsIHRoaXMucG9zaXRpb24sIHRoaXMudXApO1xuICAgIHRoaXMubWF0cml4LmdldFJvdGF0aW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgdGhpcy5yb3RhdGlvbi5mcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICB9XG5cbn0iLCJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL1RyYW5zZm9ybS5qcyc7XG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSAnLi4vbWF0aC9NYXQ0LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuY29uc3QgdGVtcE1hdDQgPSBuZXcgTWF0NCgpO1xuY29uc3QgdGVtcFZlYzNhID0gbmV3IFZlYzMoKTtcbmNvbnN0IHRlbXBWZWMzYiA9IG5ldyBWZWMzKCk7XG5leHBvcnQgY2xhc3MgQ2FtZXJhIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IoZ2wsIHtcbiAgICBuZWFyID0gMC4xLFxuICAgIGZhciA9IDEwMCxcbiAgICBmb3YgPSA0NSxcbiAgICBhc3BlY3QgPSAxLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tLFxuICAgIHRvcCxcbiAgICB6b29tID0gMVxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgbmVhcixcbiAgICAgIGZhcixcbiAgICAgIGZvdixcbiAgICAgIGFzcGVjdCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIHRvcCxcbiAgICAgIHpvb21cbiAgICB9KTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0NCgpO1xuICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBNYXQ0KCk7XG4gICAgdGhpcy5wcm9qZWN0aW9uVmlld01hdHJpeCA9IG5ldyBNYXQ0KCk7XG4gICAgdGhpcy53b3JsZFBvc2l0aW9uID0gbmV3IFZlYzMoKTsgLy8gVXNlIG9ydGhvZ3JhcGhpYyBpZiBsZWZ0L3JpZ2h0IHNldCwgZWxzZSBkZWZhdWx0IHRvIHBlcnNwZWN0aXZlIGNhbWVyYVxuXG4gICAgdGhpcy50eXBlID0gbGVmdCB8fCByaWdodCA/ICdvcnRob2dyYXBoaWMnIDogJ3BlcnNwZWN0aXZlJztcbiAgICBpZiAodGhpcy50eXBlID09PSAnb3J0aG9ncmFwaGljJykgdGhpcy5vcnRob2dyYXBoaWMoKTtlbHNlIHRoaXMucGVyc3BlY3RpdmUoKTtcbiAgfVxuXG4gIHBlcnNwZWN0aXZlKHtcbiAgICBuZWFyID0gdGhpcy5uZWFyLFxuICAgIGZhciA9IHRoaXMuZmFyLFxuICAgIGZvdiA9IHRoaXMuZm92LFxuICAgIGFzcGVjdCA9IHRoaXMuYXNwZWN0XG4gIH0gPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgbmVhcixcbiAgICAgIGZhcixcbiAgICAgIGZvdixcbiAgICAgIGFzcGVjdFxuICAgIH0pO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5mcm9tUGVyc3BlY3RpdmUoe1xuICAgICAgZm92OiBmb3YgKiAoTWF0aC5QSSAvIDE4MCksXG4gICAgICBhc3BlY3QsXG4gICAgICBuZWFyLFxuICAgICAgZmFyXG4gICAgfSk7XG4gICAgdGhpcy50eXBlID0gJ3BlcnNwZWN0aXZlJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9ydGhvZ3JhcGhpYyh7XG4gICAgbmVhciA9IHRoaXMubmVhcixcbiAgICBmYXIgPSB0aGlzLmZhcixcbiAgICBsZWZ0ID0gdGhpcy5sZWZ0LFxuICAgIHJpZ2h0ID0gdGhpcy5yaWdodCxcbiAgICBib3R0b20gPSB0aGlzLmJvdHRvbSxcbiAgICB0b3AgPSB0aGlzLnRvcCxcbiAgICB6b29tID0gdGhpcy56b29tXG4gIH0gPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgbmVhcixcbiAgICAgIGZhcixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIHRvcCxcbiAgICAgIHpvb21cbiAgICB9KTtcbiAgICBsZWZ0IC89IHpvb207XG4gICAgcmlnaHQgLz0gem9vbTtcbiAgICBib3R0b20gLz0gem9vbTtcbiAgICB0b3AgLz0gem9vbTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXguZnJvbU9ydGhvZ29uYWwoe1xuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgdG9wLFxuICAgICAgbmVhcixcbiAgICAgIGZhclxuICAgIH0pO1xuICAgIHRoaXMudHlwZSA9ICdvcnRob2dyYXBoaWMnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTWF0cml4V29ybGQoKSB7XG4gICAgc3VwZXIudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICB0aGlzLnZpZXdNYXRyaXguaW52ZXJzZSh0aGlzLndvcmxkTWF0cml4KTtcbiAgICB0aGlzLndvcmxkTWF0cml4LmdldFRyYW5zbGF0aW9uKHRoaXMud29ybGRQb3NpdGlvbik7IC8vIHVzZWQgZm9yIHNvcnRpbmdcblxuICAgIHRoaXMucHJvamVjdGlvblZpZXdNYXRyaXgubXVsdGlwbHkodGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbG9va0F0KHRhcmdldCkge1xuICAgIHN1cGVyLmxvb2tBdCh0YXJnZXQsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFByb2plY3QgM0QgY29vcmRpbmF0ZSB0byAyRCBwb2ludFxuXG5cbiAgcHJvamVjdCh2KSB7XG4gICAgdi5hcHBseU1hdHJpeDQodGhpcy52aWV3TWF0cml4KTtcbiAgICB2LmFwcGx5TWF0cml4NCh0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIFVucHJvamVjdCAyRCBwb2ludCB0byAzRCBjb29yZGluYXRlXG5cblxuICB1bnByb2plY3Qodikge1xuICAgIHYuYXBwbHlNYXRyaXg0KHRlbXBNYXQ0LmludmVyc2UodGhpcy5wcm9qZWN0aW9uTWF0cml4KSk7XG4gICAgdi5hcHBseU1hdHJpeDQodGhpcy53b3JsZE1hdHJpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVGcnVzdHVtKCkge1xuICAgIGlmICghdGhpcy5mcnVzdHVtKSB7XG4gICAgICB0aGlzLmZydXN0dW0gPSBbbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKSwgbmV3IFZlYzMoKV07XG4gICAgfVxuXG4gICAgY29uc3QgbSA9IHRoaXMucHJvamVjdGlvblZpZXdNYXRyaXg7XG4gICAgdGhpcy5mcnVzdHVtWzBdLnNldChtWzNdIC0gbVswXSwgbVs3XSAtIG1bNF0sIG1bMTFdIC0gbVs4XSkuY29uc3RhbnQgPSBtWzE1XSAtIG1bMTJdOyAvLyAteFxuXG4gICAgdGhpcy5mcnVzdHVtWzFdLnNldChtWzNdICsgbVswXSwgbVs3XSArIG1bNF0sIG1bMTFdICsgbVs4XSkuY29uc3RhbnQgPSBtWzE1XSArIG1bMTJdOyAvLyAreFxuXG4gICAgdGhpcy5mcnVzdHVtWzJdLnNldChtWzNdICsgbVsxXSwgbVs3XSArIG1bNV0sIG1bMTFdICsgbVs5XSkuY29uc3RhbnQgPSBtWzE1XSArIG1bMTNdOyAvLyAreVxuXG4gICAgdGhpcy5mcnVzdHVtWzNdLnNldChtWzNdIC0gbVsxXSwgbVs3XSAtIG1bNV0sIG1bMTFdIC0gbVs5XSkuY29uc3RhbnQgPSBtWzE1XSAtIG1bMTNdOyAvLyAteVxuXG4gICAgdGhpcy5mcnVzdHVtWzRdLnNldChtWzNdIC0gbVsyXSwgbVs3XSAtIG1bNl0sIG1bMTFdIC0gbVsxMF0pLmNvbnN0YW50ID0gbVsxNV0gLSBtWzE0XTsgLy8gK3ogKGZhcilcblxuICAgIHRoaXMuZnJ1c3R1bVs1XS5zZXQobVszXSArIG1bMl0sIG1bN10gKyBtWzZdLCBtWzExXSArIG1bMTBdKS5jb25zdGFudCA9IG1bMTVdICsgbVsxNF07IC8vIC16IChuZWFyKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIGNvbnN0IGludkxlbiA9IDEuMCAvIHRoaXMuZnJ1c3R1bVtpXS5kaXN0YW5jZSgpO1xuICAgICAgdGhpcy5mcnVzdHVtW2ldLm11bHRpcGx5KGludkxlbik7XG4gICAgICB0aGlzLmZydXN0dW1baV0uY29uc3RhbnQgKj0gaW52TGVuO1xuICAgIH1cbiAgfVxuXG4gIGZydXN0dW1JbnRlcnNlY3RzTWVzaChub2RlKSB7XG4gICAgLy8gSWYgbm8gcG9zaXRpb24gYXR0cmlidXRlLCB0cmVhdCBhcyBmcnVzdHVtQ3VsbGVkIGZhbHNlXG4gICAgaWYgKCFub2RlLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24pIHJldHVybiB0cnVlO1xuICAgIGlmICghbm9kZS5nZW9tZXRyeS5ib3VuZHMgfHwgbm9kZS5nZW9tZXRyeS5ib3VuZHMucmFkaXVzID09PSBJbmZpbml0eSkgbm9kZS5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICBpZiAoIW5vZGUuZ2VvbWV0cnkuYm91bmRzKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBjZW50ZXIgPSB0ZW1wVmVjM2E7XG4gICAgY2VudGVyLmNvcHkobm9kZS5nZW9tZXRyeS5ib3VuZHMuY2VudGVyKTtcbiAgICBjZW50ZXIuYXBwbHlNYXRyaXg0KG5vZGUud29ybGRNYXRyaXgpO1xuICAgIGNvbnN0IHJhZGl1cyA9IG5vZGUuZ2VvbWV0cnkuYm91bmRzLnJhZGl1cyAqIG5vZGUud29ybGRNYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcbiAgICByZXR1cm4gdGhpcy5mcnVzdHVtSW50ZXJzZWN0c1NwaGVyZShjZW50ZXIsIHJhZGl1cyk7XG4gIH1cblxuICBmcnVzdHVtSW50ZXJzZWN0c1NwaGVyZShjZW50ZXIsIHJhZGl1cykge1xuICAgIGNvbnN0IG5vcm1hbCA9IHRlbXBWZWMzYjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb25zdCBwbGFuZSA9IHRoaXMuZnJ1c3R1bVtpXTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gbm9ybWFsLmNvcHkocGxhbmUpLmRvdChjZW50ZXIpICsgcGxhbmUuY29uc3RhbnQ7XG4gICAgICBpZiAoZGlzdGFuY2UgPCAtcmFkaXVzKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufSIsImNvbnN0IEVQU0lMT04gPSAwLjAwMDAwMTtcbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVs0XTtcbiAgb3V0WzRdID0gYVs1XTtcbiAgb3V0WzVdID0gYVs2XTtcbiAgb3V0WzZdID0gYVs4XTtcbiAgb3V0WzddID0gYVs5XTtcbiAgb3V0WzhdID0gYVsxMF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICBsZXQgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG4gIGxldCB4eCA9IHggKiB4MjtcbiAgbGV0IHl4ID0geSAqIHgyO1xuICBsZXQgeXkgPSB5ICogeTI7XG4gIGxldCB6eCA9IHogKiB4MjtcbiAgbGV0IHp5ID0geiAqIHkyO1xuICBsZXQgenogPSB6ICogejI7XG4gIGxldCB3eCA9IHcgKiB4MjtcbiAgbGV0IHd5ID0gdyAqIHkyO1xuICBsZXQgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBsZXQgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTEyID0gYVs1XTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYTAxO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYTAyO1xuICAgIG91dFs3XSA9IGExMjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhWzFdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhWzJdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEludmVydHMgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIGxldCBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIGxldCBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIGxldCBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICBsZXQgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgbGV0IGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gIG91dFszXSA9IGIxMSAqIGRldDtcbiAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgb3V0WzZdID0gYjIxICogZGV0O1xuICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICBsZXQgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICBsZXQgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XTtcbiAgbGV0IGIwMCA9IGJbMF0sXG4gICAgICBiMDEgPSBiWzFdLFxuICAgICAgYjAyID0gYlsyXTtcbiAgbGV0IGIxMCA9IGJbM10sXG4gICAgICBiMTEgPSBiWzRdLFxuICAgICAgYjEyID0gYls1XTtcbiAgbGV0IGIyMCA9IGJbNl0sXG4gICAgICBiMjEgPSBiWzddLFxuICAgICAgYjIyID0gYls4XTtcbiAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcbiAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcbiAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBsZXQgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdLFxuICAgICAgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdLFxuICAgICAgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXTtcbiAgb3V0WzBdID0gYTAwO1xuICBvdXRbMV0gPSBhMDE7XG4gIG91dFsyXSA9IGEwMjtcbiAgb3V0WzNdID0gYTEwO1xuICBvdXRbNF0gPSBhMTE7XG4gIG91dFs1XSA9IGExMjtcbiAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIGxldCBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSB4ICogYVswXTtcbiAgb3V0WzFdID0geCAqIGFbMV07XG4gIG91dFsyXSA9IHggKiBhWzJdO1xuICBvdXRbM10gPSB5ICogYVszXTtcbiAgb3V0WzRdID0geSAqIGFbNF07XG4gIG91dFs1XSA9IHkgKiBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbEZyb21NYXQ0KG91dCwgYSkge1xuICBsZXQgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgbGV0IGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIGxldCBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgMkQgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHlvdXIgZ2wgY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZ2wgY29udGV4dFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0aW9uKG91dCwgd2lkdGgsIGhlaWdodCkge1xuICBvdXRbMF0gPSAyIC8gd2lkdGg7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IC0yIC8gaGVpZ2h0O1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAtMTtcbiAgb3V0WzddID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgb3V0WzRdID0gYVs0XSAqIGI7XG4gIG91dFs1XSA9IGFbNV0gKiBiO1xuICBvdXRbNl0gPSBhWzZdICogYjtcbiAgb3V0WzddID0gYVs3XSAqIGI7XG4gIG91dFs4XSA9IGFbOF0gKiBiO1xuICByZXR1cm4gb3V0O1xufSIsImltcG9ydCAqIGFzIE1hdDNGdW5jIGZyb20gJy4vZnVuY3Rpb25zL01hdDNGdW5jLmpzJztcbmV4cG9ydCBjbGFzcyBNYXQzIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcihtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMTAgPSAwLCBtMTEgPSAxLCBtMTIgPSAwLCBtMjAgPSAwLCBtMjEgPSAwLCBtMjIgPSAxKSB7XG4gICAgc3VwZXIobTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXQobTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIGlmIChtMDAubGVuZ3RoKSByZXR1cm4gdGhpcy5jb3B5KG0wMCk7XG4gICAgTWF0M0Z1bmMuc2V0KHRoaXMsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJhbnNsYXRlKHYsIG0gPSB0aGlzKSB7XG4gICAgTWF0M0Z1bmMudHJhbnNsYXRlKHRoaXMsIG0sIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcm90YXRlKHYsIG0gPSB0aGlzKSB7XG4gICAgTWF0M0Z1bmMucm90YXRlKHRoaXMsIG0sIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2NhbGUodiwgbSA9IHRoaXMpIHtcbiAgICBNYXQzRnVuYy5zY2FsZSh0aGlzLCBtLCB2KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG11bHRpcGx5KG1hLCBtYikge1xuICAgIGlmIChtYikge1xuICAgICAgTWF0M0Z1bmMubXVsdGlwbHkodGhpcywgbWEsIG1iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTWF0M0Z1bmMubXVsdGlwbHkodGhpcywgdGhpcywgbWEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWRlbnRpdHkoKSB7XG4gICAgTWF0M0Z1bmMuaWRlbnRpdHkodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb3B5KG0pIHtcbiAgICBNYXQzRnVuYy5jb3B5KHRoaXMsIG0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbU1hdHJpeDQobSkge1xuICAgIE1hdDNGdW5jLmZyb21NYXQ0KHRoaXMsIG0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbVF1YXRlcm5pb24ocSkge1xuICAgIE1hdDNGdW5jLmZyb21RdWF0KHRoaXMsIHEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbUJhc2lzKHZlYzNhLCB2ZWMzYiwgdmVjM2MpIHtcbiAgICB0aGlzLnNldCh2ZWMzYVswXSwgdmVjM2FbMV0sIHZlYzNhWzJdLCB2ZWMzYlswXSwgdmVjM2JbMV0sIHZlYzNiWzJdLCB2ZWMzY1swXSwgdmVjM2NbMV0sIHZlYzNjWzJdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludmVyc2UobSA9IHRoaXMpIHtcbiAgICBNYXQzRnVuYy5pbnZlcnQodGhpcywgbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXROb3JtYWxNYXRyaXgobSkge1xuICAgIE1hdDNGdW5jLm5vcm1hbEZyb21NYXQ0KHRoaXMsIG0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0iLCJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICcuL1RyYW5zZm9ybS5qcyc7XG5pbXBvcnQgeyBNYXQzIH0gZnJvbSAnLi4vbWF0aC9NYXQzLmpzJztcbmltcG9ydCB7IE1hdDQgfSBmcm9tICcuLi9tYXRoL01hdDQuanMnO1xubGV0IElEID0gMDtcbmV4cG9ydCBjbGFzcyBNZXNoIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IoZ2wsIHtcbiAgICBnZW9tZXRyeSxcbiAgICBwcm9ncmFtLFxuICAgIG1vZGUgPSBnbC5UUklBTkdMRVMsXG4gICAgZnJ1c3R1bUN1bGxlZCA9IHRydWUsXG4gICAgcmVuZGVyT3JkZXIgPSAwXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFnbC5jYW52YXMpIGNvbnNvbGUuZXJyb3IoJ2dsIG5vdCBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQgdG8gTWVzaCcpO1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmlkID0gSUQrKztcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB0aGlzLm1vZGUgPSBtb2RlOyAvLyBVc2VkIHRvIHNraXAgZnJ1c3R1bSBjdWxsaW5nXG5cbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmcnVzdHVtQ3VsbGVkOyAvLyBPdmVycmlkZSBzb3J0aW5nIHRvIGZvcmNlIGFuIG9yZGVyXG5cbiAgICB0aGlzLnJlbmRlck9yZGVyID0gcmVuZGVyT3JkZXI7XG4gICAgdGhpcy5tb2RlbFZpZXdNYXRyaXggPSBuZXcgTWF0NCgpO1xuICAgIHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IE1hdDMoKTtcbiAgICB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuYWZ0ZXJSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgfVxuXG4gIG9uQmVmb3JlUmVuZGVyKGYpIHtcbiAgICB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcy5wdXNoKGYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25BZnRlclJlbmRlcihmKSB7XG4gICAgdGhpcy5hZnRlclJlbmRlckNhbGxiYWNrcy5wdXNoKGYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZHJhdyh7XG4gICAgY2FtZXJhXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goZiA9PiBmICYmIGYoe1xuICAgICAgbWVzaDogdGhpcyxcbiAgICAgIGNhbWVyYVxuICAgIH0pKTtcblxuICAgIGlmIChjYW1lcmEpIHtcbiAgICAgIC8vIEFkZCBlbXB0eSBtYXRyaXggdW5pZm9ybXMgdG8gcHJvZ3JhbSBpZiB1bnNldFxuICAgICAgaWYgKCF0aGlzLnByb2dyYW0udW5pZm9ybXMubW9kZWxNYXRyaXgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnByb2dyYW0udW5pZm9ybXMsIHtcbiAgICAgICAgICBtb2RlbE1hdHJpeDoge1xuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZpZXdNYXRyaXg6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2RlbFZpZXdNYXRyaXg6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBub3JtYWxNYXRyaXg6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9qZWN0aW9uTWF0cml4OiB7XG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FtZXJhUG9zaXRpb246IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU2V0IHRoZSBtYXRyaXggdW5pZm9ybXNcblxuXG4gICAgICB0aGlzLnByb2dyYW0udW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeC52YWx1ZSA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgdGhpcy5wcm9ncmFtLnVuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLnZhbHVlID0gY2FtZXJhLndvcmxkUG9zaXRpb247XG4gICAgICB0aGlzLnByb2dyYW0udW5pZm9ybXMudmlld01hdHJpeC52YWx1ZSA9IGNhbWVyYS52aWV3TWF0cml4O1xuICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHkoY2FtZXJhLnZpZXdNYXRyaXgsIHRoaXMud29ybGRNYXRyaXgpO1xuICAgICAgdGhpcy5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KHRoaXMubW9kZWxWaWV3TWF0cml4KTtcbiAgICAgIHRoaXMucHJvZ3JhbS51bmlmb3Jtcy5tb2RlbE1hdHJpeC52YWx1ZSA9IHRoaXMud29ybGRNYXRyaXg7XG4gICAgICB0aGlzLnByb2dyYW0udW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LnZhbHVlID0gdGhpcy5tb2RlbFZpZXdNYXRyaXg7XG4gICAgICB0aGlzLnByb2dyYW0udW5pZm9ybXMubm9ybWFsTWF0cml4LnZhbHVlID0gdGhpcy5ub3JtYWxNYXRyaXg7XG4gICAgfSAvLyBkZXRlcm1pbmUgaWYgZmFjZXMgbmVlZCB0byBiZSBmbGlwcGVkIC0gd2hlbiBtZXNoIHNjYWxlZCBuZWdhdGl2ZWx5XG5cblxuICAgIGxldCBmbGlwRmFjZXMgPSB0aGlzLnByb2dyYW0uY3VsbEZhY2UgJiYgdGhpcy53b3JsZE1hdHJpeC5kZXRlcm1pbmFudCgpIDwgMDtcbiAgICB0aGlzLnByb2dyYW0udXNlKHtcbiAgICAgIGZsaXBGYWNlc1xuICAgIH0pO1xuICAgIHRoaXMuZ2VvbWV0cnkuZHJhdyh7XG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBwcm9ncmFtOiB0aGlzLnByb2dyYW1cbiAgICB9KTtcbiAgICB0aGlzLmFmdGVyUmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goZiA9PiBmICYmIGYoe1xuICAgICAgbWVzaDogdGhpcyxcbiAgICAgIGNhbWVyYVxuICAgIH0pKTtcbiAgfVxuXG59IiwiLy8gVE9ETzogZGVsZXRlIHRleHR1cmVcbi8vIFRPRE86IHVzZSB0ZXhTdWJJbWFnZTJEIGZvciB1cGRhdGVzICh2aWRlbyBvciB3aGVuIGxvYWRlZClcbi8vIFRPRE86IG5lZWQ/IGVuY29kaW5nID0gbGluZWFyRW5jb2Rpbmdcbi8vIFRPRE86IHN1cHBvcnQgbm9uLWNvbXByZXNzZWQgbWlwbWFwcyB1cGxvYWRzXG5jb25zdCBlbXB0eVBpeGVsID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZjIodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmIHZhbHVlIC0gMSkgPT09IDA7XG59XG5cbmxldCBJRCA9IDE7XG5leHBvcnQgY2xhc3MgVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgaW1hZ2UsXG4gICAgdGFyZ2V0ID0gZ2wuVEVYVFVSRV8yRCxcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURSxcbiAgICBmb3JtYXQgPSBnbC5SR0JBLFxuICAgIGludGVybmFsRm9ybWF0ID0gZm9ybWF0LFxuICAgIHdyYXBTID0gZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICB3cmFwVCA9IGdsLkNMQU1QX1RPX0VER0UsXG4gICAgZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZSxcbiAgICBtaW5GaWx0ZXIgPSBnZW5lcmF0ZU1pcG1hcHMgPyBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIgOiBnbC5MSU5FQVIsXG4gICAgbWFnRmlsdGVyID0gZ2wuTElORUFSLFxuICAgIHByZW11bHRpcGx5QWxwaGEgPSBmYWxzZSxcbiAgICB1bnBhY2tBbGlnbm1lbnQgPSA0LFxuICAgIGZsaXBZID0gdGFyZ2V0ID09IGdsLlRFWFRVUkVfMkQgPyB0cnVlIDogZmFsc2UsXG4gICAgYW5pc290cm9weSA9IDAsXG4gICAgbGV2ZWwgPSAwLFxuICAgIHdpZHRoLFxuICAgIC8vIHVzZWQgZm9yIFJlbmRlclRhcmdldHMgb3IgRGF0YSBUZXh0dXJlc1xuICAgIGhlaWdodCA9IHdpZHRoXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmlkID0gSUQrKztcbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gaW50ZXJuYWxGb3JtYXQ7XG4gICAgdGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG4gICAgdGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXI7XG4gICAgdGhpcy53cmFwUyA9IHdyYXBTO1xuICAgIHRoaXMud3JhcFQgPSB3cmFwVDtcbiAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcbiAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBwcmVtdWx0aXBseUFscGhhO1xuICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gdW5wYWNrQWxpZ25tZW50O1xuICAgIHRoaXMuZmxpcFkgPSBmbGlwWTtcbiAgICB0aGlzLmFuaXNvdHJvcHkgPSBNYXRoLm1pbihhbmlzb3Ryb3B5LCB0aGlzLmdsLnJlbmRlcmVyLnBhcmFtZXRlcnMubWF4QW5pc290cm9weSk7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLnN0b3JlID0ge1xuICAgICAgaW1hZ2U6IG51bGxcbiAgICB9OyAvLyBBbGlhcyBmb3Igc3RhdGUgc3RvcmUgdG8gYXZvaWQgcmVkdW5kYW50IGNhbGxzIGZvciBnbG9iYWwgc3RhdGVcblxuICAgIHRoaXMuZ2xTdGF0ZSA9IHRoaXMuZ2wucmVuZGVyZXIuc3RhdGU7IC8vIFN0YXRlIHN0b3JlIHRvIGF2b2lkIHJlZHVuZGFudCBjYWxscyBmb3IgcGVyLXRleHR1cmUgc3RhdGVcblxuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLnN0YXRlLm1pbkZpbHRlciA9IHRoaXMuZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuICAgIHRoaXMuc3RhdGUubWFnRmlsdGVyID0gdGhpcy5nbC5MSU5FQVI7XG4gICAgdGhpcy5zdGF0ZS53cmFwUyA9IHRoaXMuZ2wuUkVQRUFUO1xuICAgIHRoaXMuc3RhdGUud3JhcFQgPSB0aGlzLmdsLlJFUEVBVDtcbiAgICB0aGlzLnN0YXRlLmFuaXNvdHJvcHkgPSAwO1xuICB9XG5cbiAgYmluZCgpIHtcbiAgICAvLyBBbHJlYWR5IGJvdW5kIHRvIGFjdGl2ZSB0ZXh0dXJlIHVuaXRcbiAgICBpZiAodGhpcy5nbFN0YXRlLnRleHR1cmVVbml0c1t0aGlzLmdsU3RhdGUuYWN0aXZlVGV4dHVyZVVuaXRdID09PSB0aGlzLmlkKSByZXR1cm47XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLnRhcmdldCwgdGhpcy50ZXh0dXJlKTtcbiAgICB0aGlzLmdsU3RhdGUudGV4dHVyZVVuaXRzW3RoaXMuZ2xTdGF0ZS5hY3RpdmVUZXh0dXJlVW5pdF0gPSB0aGlzLmlkO1xuICB9XG5cbiAgdXBkYXRlKHRleHR1cmVVbml0ID0gMCkge1xuICAgIGNvbnN0IG5lZWRzVXBkYXRlID0gISh0aGlzLmltYWdlID09PSB0aGlzLnN0b3JlLmltYWdlICYmICF0aGlzLm5lZWRzVXBkYXRlKTsgLy8gTWFrZSBzdXJlIHRoYXQgdGV4dHVyZSBpcyBib3VuZCB0byBpdHMgdGV4dHVyZSB1bml0XG5cbiAgICBpZiAobmVlZHNVcGRhdGUgfHwgdGhpcy5nbFN0YXRlLnRleHR1cmVVbml0c1t0ZXh0dXJlVW5pdF0gIT09IHRoaXMuaWQpIHtcbiAgICAgIC8vIHNldCBhY3RpdmUgdGV4dHVyZSB1bml0IHRvIHBlcmZvcm0gdGV4dHVyZSBmdW5jdGlvbnNcbiAgICAgIHRoaXMuZ2wucmVuZGVyZXIuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgICB0aGlzLmJpbmQoKTtcbiAgICB9XG5cbiAgICBpZiAoIW5lZWRzVXBkYXRlKSByZXR1cm47XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuZmxpcFkgIT09IHRoaXMuZ2xTdGF0ZS5mbGlwWSkge1xuICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuZmxpcFkpO1xuICAgICAgdGhpcy5nbFN0YXRlLmZsaXBZID0gdGhpcy5mbGlwWTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcmVtdWx0aXBseUFscGhhICE9PSB0aGlzLmdsU3RhdGUucHJlbXVsdGlwbHlBbHBoYSkge1xuICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGhpcy5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgIHRoaXMuZ2xTdGF0ZS5wcmVtdWx0aXBseUFscGhhID0gdGhpcy5wcmVtdWx0aXBseUFscGhhO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVucGFja0FsaWdubWVudCAhPT0gdGhpcy5nbFN0YXRlLnVucGFja0FsaWdubWVudCkge1xuICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19BTElHTk1FTlQsIHRoaXMudW5wYWNrQWxpZ25tZW50KTtcbiAgICAgIHRoaXMuZ2xTdGF0ZS51bnBhY2tBbGlnbm1lbnQgPSB0aGlzLnVucGFja0FsaWdubWVudDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5GaWx0ZXIgIT09IHRoaXMuc3RhdGUubWluRmlsdGVyKSB7XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy50YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLm1pbkZpbHRlcik7XG4gICAgICB0aGlzLnN0YXRlLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hZ0ZpbHRlciAhPT0gdGhpcy5zdGF0ZS5tYWdGaWx0ZXIpIHtcbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRhcmdldCwgdGhpcy5nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcbiAgICAgIHRoaXMuc3RhdGUubWFnRmlsdGVyID0gdGhpcy5tYWdGaWx0ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JhcFMgIT09IHRoaXMuc3RhdGUud3JhcFMpIHtcbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRhcmdldCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy53cmFwUyk7XG4gICAgICB0aGlzLnN0YXRlLndyYXBTID0gdGhpcy53cmFwUztcbiAgICB9XG5cbiAgICBpZiAodGhpcy53cmFwVCAhPT0gdGhpcy5zdGF0ZS53cmFwVCkge1xuICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcbiAgICAgIHRoaXMuc3RhdGUud3JhcFQgPSB0aGlzLndyYXBUO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFuaXNvdHJvcHkgJiYgdGhpcy5hbmlzb3Ryb3B5ICE9PSB0aGlzLnN0YXRlLmFuaXNvdHJvcHkpIHtcbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyZih0aGlzLnRhcmdldCwgdGhpcy5nbC5yZW5kZXJlci5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCB0aGlzLmFuaXNvdHJvcHkpO1xuICAgICAgdGhpcy5zdGF0ZS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICBpZiAodGhpcy5pbWFnZS53aWR0aCkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSB0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAgICAgLy8gRm9yIGN1YmUgbWFwc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIHRoaXMubGV2ZWwsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHRoaXMuaW1hZ2VbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLmltYWdlKSkge1xuICAgICAgICAvLyBEYXRhIHRleHR1cmVcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMudGFyZ2V0LCB0aGlzLmxldmVsLCB0aGlzLmludGVybmFsRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgdGhpcy5pbWFnZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW1hZ2UuaXNDb21wcmVzc2VkVGV4dHVyZSkge1xuICAgICAgICAvLyBDb21wcmVzc2VkIHRleHR1cmVcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuaW1hZ2UubGVuZ3RoOyBsZXZlbCsrKSB7XG4gICAgICAgICAgdGhpcy5nbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCh0aGlzLnRhcmdldCwgbGV2ZWwsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHRoaXMuaW1hZ2VbbGV2ZWxdLndpZHRoLCB0aGlzLmltYWdlW2xldmVsXS5oZWlnaHQsIDAsIHRoaXMuaW1hZ2VbbGV2ZWxdLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWd1bGFyIHRleHR1cmVcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMudGFyZ2V0LCB0aGlzLmxldmVsLCB0aGlzLmludGVybmFsRm9ybWF0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLmltYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVNaXBtYXBzKSB7XG4gICAgICAgIC8vIEZvciBXZWJHTDEsIGlmIG5vdCBhIHBvd2VyIG9mIDIsIHR1cm4gb2ZmIG1pcHMsIHNldCB3cmFwcGluZyB0byBjbGFtcCB0byBlZGdlIGFuZCBtaW5GaWx0ZXIgdG8gbGluZWFyXG4gICAgICAgIGlmICghdGhpcy5nbC5yZW5kZXJlci5pc1dlYmdsMiAmJiAoIWlzUG93ZXJPZjIodGhpcy5pbWFnZS53aWR0aCkgfHwgIWlzUG93ZXJPZjIodGhpcy5pbWFnZS5oZWlnaHQpKSkge1xuICAgICAgICAgIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy53cmFwUyA9IHRoaXMud3JhcFQgPSB0aGlzLmdsLkNMQU1QX1RPX0VER0U7XG4gICAgICAgICAgdGhpcy5taW5GaWx0ZXIgPSB0aGlzLmdsLkxJTkVBUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDYWxsYmFjayBmb3Igd2hlbiBkYXRhIGlzIHB1c2hlZCB0byBHUFVcblxuXG4gICAgICB0aGlzLm9uVXBkYXRlICYmIHRoaXMub25VcGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSB0aGlzLmdsLlRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAgICAgLy8gVXBsb2FkIGVtcHR5IHBpeGVsIGZvciBlYWNoIHNpZGUgd2hpbGUgbm8gaW1hZ2UgdG8gYXZvaWQgZXJyb3JzIHdoaWxlIGltYWdlIG9yIHZpZGVvIGxvYWRpbmdcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCB0aGlzLmdsLlJHQkEsIDEsIDEsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBlbXB0eVBpeGVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICAgIC8vIGltYWdlIGludGVudGlvbmFsbHkgbGVmdCBudWxsIGZvciBSZW5kZXJUYXJnZXRcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMudGFyZ2V0LCB0aGlzLmxldmVsLCB0aGlzLmludGVybmFsRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGxvYWQgZW1wdHkgcGl4ZWwgaWYgbm8gaW1hZ2UgdG8gYXZvaWQgZXJyb3JzIHdoaWxlIGltYWdlIG9yIHZpZGVvIGxvYWRpbmdcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMudGFyZ2V0LCAwLCB0aGlzLmdsLlJHQkEsIDEsIDEsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBlbXB0eVBpeGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0b3JlLmltYWdlID0gdGhpcy5pbWFnZTtcbiAgfVxuXG59IiwiLy8gVE9ETzogbXVsdGkgdGFyZ2V0IHJlbmRlcmluZ1xuLy8gVE9ETzogdGVzdCBzdGVuY2lsIGFuZCBkZXB0aFxuLy8gVE9ETzogZGVzdHJveVxuLy8gVE9ETzogYmxpdCBvbiByZXNpemU/XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi9UZXh0dXJlLmpzJztcbmV4cG9ydCBjbGFzcyBSZW5kZXJUYXJnZXQge1xuICBjb25zdHJ1Y3RvcihnbCwge1xuICAgIHdpZHRoID0gZ2wuY2FudmFzLndpZHRoLFxuICAgIGhlaWdodCA9IGdsLmNhbnZhcy5oZWlnaHQsXG4gICAgdGFyZ2V0ID0gZ2wuRlJBTUVCVUZGRVIsXG4gICAgY29sb3IgPSAxLFxuICAgIC8vIG51bWJlciBvZiBjb2xvciBhdHRhY2htZW50c1xuICAgIGRlcHRoID0gdHJ1ZSxcbiAgICBzdGVuY2lsID0gZmFsc2UsXG4gICAgZGVwdGhUZXh0dXJlID0gZmFsc2UsXG4gICAgLy8gbm90ZSAtIHN0ZW5jaWwgYnJlYWtzXG4gICAgd3JhcFMgPSBnbC5DTEFNUF9UT19FREdFLFxuICAgIHdyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICBtaW5GaWx0ZXIgPSBnbC5MSU5FQVIsXG4gICAgbWFnRmlsdGVyID0gbWluRmlsdGVyLFxuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFLFxuICAgIGZvcm1hdCA9IGdsLlJHQkEsXG4gICAgaW50ZXJuYWxGb3JtYXQgPSBmb3JtYXQsXG4gICAgdW5wYWNrQWxpZ25tZW50LFxuICAgIHByZW11bHRpcGx5QWxwaGFcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy50YXJnZXQsIHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgY29uc3QgZHJhd0J1ZmZlcnMgPSBbXTsgLy8gY3JlYXRlIGFuZCBhdHRhY2ggcmVxdWlyZWQgbnVtIG9mIGNvbG9yIHRleHR1cmVzXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9yOyBpKyspIHtcbiAgICAgIHRoaXMudGV4dHVyZXMucHVzaChuZXcgVGV4dHVyZShnbCwge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3cmFwUyxcbiAgICAgICAgd3JhcFQsXG4gICAgICAgIG1pbkZpbHRlcixcbiAgICAgICAgbWFnRmlsdGVyLFxuICAgICAgICB0eXBlLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIGludGVybmFsRm9ybWF0LFxuICAgICAgICB1bnBhY2tBbGlnbm1lbnQsXG4gICAgICAgIHByZW11bHRpcGx5QWxwaGEsXG4gICAgICAgIGZsaXBZOiBmYWxzZSxcbiAgICAgICAgZ2VuZXJhdGVNaXBtYXBzOiBmYWxzZVxuICAgICAgfSkpO1xuICAgICAgdGhpcy50ZXh0dXJlc1tpXS51cGRhdGUoKTtcbiAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy50YXJnZXQsIHRoaXMuZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCB0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZXNbaV0udGV4dHVyZSwgMFxuICAgICAgLyogbGV2ZWwgKi9cbiAgICAgICk7XG4gICAgICBkcmF3QnVmZmVycy5wdXNoKHRoaXMuZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpKTtcbiAgICB9IC8vIEZvciBtdWx0aS1yZW5kZXIgdGFyZ2V0cyBzaGFkZXIgYWNjZXNzXG5cblxuICAgIGlmIChkcmF3QnVmZmVycy5sZW5ndGggPiAxKSB0aGlzLmdsLnJlbmRlcmVyLmRyYXdCdWZmZXJzKGRyYXdCdWZmZXJzKTsgLy8gYWxpYXMgZm9yIG1ham9yaXR5IG9mIHVzZSBjYXNlc1xuXG4gICAgdGhpcy50ZXh0dXJlID0gdGhpcy50ZXh0dXJlc1swXTsgLy8gbm90ZSBkZXB0aCB0ZXh0dXJlcyBicmVhayBzdGVuY2lsIC0gc28gY2FuJ3QgdXNlIHRvZ2V0aGVyXG5cbiAgICBpZiAoZGVwdGhUZXh0dXJlICYmICh0aGlzLmdsLnJlbmRlcmVyLmlzV2ViZ2wyIHx8IHRoaXMuZ2wucmVuZGVyZXIuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kZXB0aF90ZXh0dXJlJykpKSB7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsLCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIG1pbkZpbHRlcjogdGhpcy5nbC5ORUFSRVNULFxuICAgICAgICBtYWdGaWx0ZXI6IHRoaXMuZ2wuTkVBUkVTVCxcbiAgICAgICAgZm9ybWF0OiB0aGlzLmdsLkRFUFRIX0NPTVBPTkVOVCxcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQ6IGdsLnJlbmRlcmVyLmlzV2ViZ2wyID8gdGhpcy5nbC5ERVBUSF9DT01QT05FTlQxNiA6IHRoaXMuZ2wuREVQVEhfQ09NUE9ORU5ULFxuICAgICAgICB0eXBlOiB0aGlzLmdsLlVOU0lHTkVEX0lOVFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRlcHRoVGV4dHVyZS51cGRhdGUoKTtcbiAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy50YXJnZXQsIHRoaXMuZ2wuREVQVEhfQVRUQUNITUVOVCwgdGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmRlcHRoVGV4dHVyZS50ZXh0dXJlLCAwXG4gICAgICAvKiBsZXZlbCAqL1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVuZGVyIGJ1ZmZlcnNcbiAgICAgIGlmIChkZXB0aCAmJiAhc3RlbmNpbCkge1xuICAgICAgICB0aGlzLmRlcHRoQnVmZmVyID0gdGhpcy5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLmRlcHRoQnVmZmVyKTtcbiAgICAgICAgdGhpcy5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLmdsLkRFUFRIX0NPTVBPTkVOVDE2LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLnRhcmdldCwgdGhpcy5nbC5ERVBUSF9BVFRBQ0hNRU5ULCB0aGlzLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5kZXB0aEJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVuY2lsICYmICFkZXB0aCkge1xuICAgICAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuc3RlbmNpbEJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5nbC5TVEVOQ0lMX0lOREVYOCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodGhpcy50YXJnZXQsIHRoaXMuZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCB0aGlzLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5zdGVuY2lsQnVmZmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlcHRoICYmIHN0ZW5jaWwpIHtcbiAgICAgICAgdGhpcy5kZXB0aFN0ZW5jaWxCdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuZGVwdGhTdGVuY2lsQnVmZmVyKTtcbiAgICAgICAgdGhpcy5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLmdsLkRFUFRIX1NURU5DSUwsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgdGhpcy5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuZGVwdGhTdGVuY2lsQnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLnRhcmdldCwgbnVsbCk7XG4gIH1cblxufSIsImNvbnN0IE5BTUVTID0ge1xuICBibGFjazogJyMwMDAwMDAnLFxuICB3aGl0ZTogJyNmZmZmZmYnLFxuICByZWQ6ICcjZmYwMDAwJyxcbiAgZ3JlZW46ICcjMDBmZjAwJyxcbiAgYmx1ZTogJyMwMDAwZmYnLFxuICBmdWNoc2lhOiAnI2ZmMDBmZicsXG4gIGN5YW46ICcjMDBmZmZmJyxcbiAgeWVsbG93OiAnI2ZmZmYwMCcsXG4gIG9yYW5nZTogJyNmZjgwMDAnXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUkdCKGhleCkge1xuICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkgaGV4ID0gaGV4WzBdICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdICsgaGV4WzNdICsgaGV4WzNdO1xuICBjb25zdCByZ2IgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgaWYgKCFyZ2IpIGNvbnNvbGUud2FybihgVW5hYmxlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyAke2hleH0gdG8gcmdiIHZhbHVlc2ApO1xuICByZXR1cm4gW3BhcnNlSW50KHJnYlsxXSwgMTYpIC8gMjU1LCBwYXJzZUludChyZ2JbMl0sIDE2KSAvIDI1NSwgcGFyc2VJbnQocmdiWzNdLCAxNikgLyAyNTVdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvUkdCKG51bSkge1xuICBudW0gPSBwYXJzZUludChudW0pO1xuICByZXR1cm4gWyhudW0gPj4gMTYgJiAyNTUpIC8gMjU1LCAobnVtID4+IDggJiAyNTUpIC8gMjU1LCAobnVtICYgMjU1KSAvIDI1NV07XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb2xvcihjb2xvcikge1xuICAvLyBFbXB0eVxuICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFswLCAwLCAwXTsgLy8gRGVjaW1hbFxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSByZXR1cm4gYXJndW1lbnRzOyAvLyBOdW1iZXJcblxuICBpZiAoIWlzTmFOKGNvbG9yKSkgcmV0dXJuIG51bWJlclRvUkdCKGNvbG9yKTsgLy8gSGV4XG5cbiAgaWYgKGNvbG9yWzBdID09PSAnIycpIHJldHVybiBoZXhUb1JHQihjb2xvcik7IC8vIE5hbWVzXG5cbiAgaWYgKE5BTUVTW2NvbG9yLnRvTG93ZXJDYXNlKCldKSByZXR1cm4gaGV4VG9SR0IoTkFNRVNbY29sb3IudG9Mb3dlckNhc2UoKV0pO1xuICBjb25zb2xlLndhcm4oJ0NvbG9yIGZvcm1hdCBub3QgcmVjb2duaXNlZCcpO1xuICByZXR1cm4gWzAsIDAsIDBdO1xufSIsImltcG9ydCAqIGFzIENvbG9yRnVuYyBmcm9tICcuL2Z1bmN0aW9ucy9Db2xvckZ1bmMuanMnOyAvLyBDb2xvciBzdG9yZWQgYXMgYW4gYXJyYXkgb2YgUkdCIGRlY2ltYWwgdmFsdWVzIChiZXR3ZWVuIDAgPiAxKVxuLy8gQ29uc3RydWN0b3IgYW5kIHNldCBtZXRob2QgYWNjZXB0IGZvbGxvd2luZyBmb3JtYXRzOlxuLy8gbmV3IENvbG9yKCkgLSBFbXB0eSAoZGVmYXVsdHMgdG8gYmxhY2spXG4vLyBuZXcgQ29sb3IoWzAuMiwgMC40LCAxLjBdKSAtIERlY2ltYWwgQXJyYXkgKG9yIGFub3RoZXIgQ29sb3IgaW5zdGFuY2UpXG4vLyBuZXcgQ29sb3IoMC43LCAwLjAsIDAuMSkgLSBEZWNpbWFsIFJHQiB2YWx1ZXNcbi8vIG5ldyBDb2xvcignI2ZmMDAwMCcpIC0gSGV4IHN0cmluZ1xuLy8gbmV3IENvbG9yKCcjY2NjJykgLSBTaG9ydC1oYW5kIEhleCBzdHJpbmdcbi8vIG5ldyBDb2xvcigweDRmMjdlOCkgLSBOdW1iZXJcbi8vIG5ldyBDb2xvcigncmVkJykgLSBDb2xvciBuYW1lIHN0cmluZyAoc2hvcnQgbGlzdCBpbiBDb2xvckZ1bmMuanMpXG5cbmV4cG9ydCBjbGFzcyBDb2xvciBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHJldHVybiBzdXBlciguLi5jb2xvcik7XG4gICAgcmV0dXJuIHN1cGVyKC4uLkNvbG9yRnVuYy5wYXJzZUNvbG9yKC4uLmFyZ3VtZW50cykpO1xuICB9XG5cbiAgZ2V0IHIoKSB7XG4gICAgcmV0dXJuIHRoaXNbMF07XG4gIH1cblxuICBnZXQgZygpIHtcbiAgICByZXR1cm4gdGhpc1sxXTtcbiAgfVxuXG4gIGdldCBiKCkge1xuICAgIHJldHVybiB0aGlzWzJdO1xuICB9XG5cbiAgc2V0IHIodikge1xuICAgIHRoaXNbMF0gPSB2O1xuICB9XG5cbiAgc2V0IGcodikge1xuICAgIHRoaXNbMV0gPSB2O1xuICB9XG5cbiAgc2V0IGIodikge1xuICAgIHRoaXNbMl0gPSB2O1xuICB9XG5cbiAgc2V0KGNvbG9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSByZXR1cm4gdGhpcy5jb3B5KGNvbG9yKTtcbiAgICByZXR1cm4gdGhpcy5jb3B5KENvbG9yRnVuYy5wYXJzZUNvbG9yKC4uLmFyZ3VtZW50cykpO1xuICB9XG5cbiAgY29weSh2KSB7XG4gICAgdGhpc1swXSA9IHZbMF07XG4gICAgdGhpc1sxXSA9IHZbMV07XG4gICAgdGhpc1syXSA9IHZbMl07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSIsImNvbnN0IEVQU0lMT04gPSAwLjAwMDAwMTtcbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHk7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCByZXR1cm5zIGEgc2NhbGFyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBjcm9zcyBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3MoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufSIsImltcG9ydCAqIGFzIFZlYzJGdW5jIGZyb20gJy4vZnVuY3Rpb25zL1ZlYzJGdW5jLmpzJztcbmV4cG9ydCBjbGFzcyBWZWMyIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IHgpIHtcbiAgICBzdXBlcih4LCB5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzWzBdO1xuICB9XG5cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXNbMV07XG4gIH1cblxuICBzZXQgeCh2KSB7XG4gICAgdGhpc1swXSA9IHY7XG4gIH1cblxuICBzZXQgeSh2KSB7XG4gICAgdGhpc1sxXSA9IHY7XG4gIH1cblxuICBzZXQoeCwgeSA9IHgpIHtcbiAgICBpZiAoeC5sZW5ndGgpIHJldHVybiB0aGlzLmNvcHkoeCk7XG4gICAgVmVjMkZ1bmMuc2V0KHRoaXMsIHgsIHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29weSh2KSB7XG4gICAgVmVjMkZ1bmMuY29weSh0aGlzLCB2KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZCh2YSwgdmIpIHtcbiAgICBpZiAodmIpIFZlYzJGdW5jLmFkZCh0aGlzLCB2YSwgdmIpO2Vsc2UgVmVjMkZ1bmMuYWRkKHRoaXMsIHRoaXMsIHZhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN1Yih2YSwgdmIpIHtcbiAgICBpZiAodmIpIFZlYzJGdW5jLnN1YnRyYWN0KHRoaXMsIHZhLCB2Yik7ZWxzZSBWZWMyRnVuYy5zdWJ0cmFjdCh0aGlzLCB0aGlzLCB2YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWx0aXBseSh2KSB7XG4gICAgaWYgKHYubGVuZ3RoKSBWZWMyRnVuYy5tdWx0aXBseSh0aGlzLCB0aGlzLCB2KTtlbHNlIFZlYzJGdW5jLnNjYWxlKHRoaXMsIHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGl2aWRlKHYpIHtcbiAgICBpZiAodi5sZW5ndGgpIFZlYzJGdW5jLmRpdmlkZSh0aGlzLCB0aGlzLCB2KTtlbHNlIFZlYzJGdW5jLnNjYWxlKHRoaXMsIHRoaXMsIDEgLyB2KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGludmVyc2UodiA9IHRoaXMpIHtcbiAgICBWZWMyRnVuYy5pbnZlcnNlKHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIENhbid0IHVzZSAnbGVuZ3RoJyBhcyBBcnJheS5wcm90b3R5cGUgdXNlcyBpdFxuXG5cbiAgbGVuKCkge1xuICAgIHJldHVybiBWZWMyRnVuYy5sZW5ndGgodGhpcyk7XG4gIH1cblxuICBkaXN0YW5jZSh2KSB7XG4gICAgaWYgKHYpIHJldHVybiBWZWMyRnVuYy5kaXN0YW5jZSh0aGlzLCB2KTtlbHNlIHJldHVybiBWZWMyRnVuYy5sZW5ndGgodGhpcyk7XG4gIH1cblxuICBzcXVhcmVkTGVuKCkge1xuICAgIHJldHVybiB0aGlzLnNxdWFyZWREaXN0YW5jZSgpO1xuICB9XG5cbiAgc3F1YXJlZERpc3RhbmNlKHYpIHtcbiAgICBpZiAodikgcmV0dXJuIFZlYzJGdW5jLnNxdWFyZWREaXN0YW5jZSh0aGlzLCB2KTtlbHNlIHJldHVybiBWZWMyRnVuYy5zcXVhcmVkTGVuZ3RoKHRoaXMpO1xuICB9XG5cbiAgbmVnYXRlKHYgPSB0aGlzKSB7XG4gICAgVmVjMkZ1bmMubmVnYXRlKHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY3Jvc3ModmEsIHZiKSB7XG4gICAgaWYgKHZiKSByZXR1cm4gVmVjMkZ1bmMuY3Jvc3ModmEsIHZiKTtcbiAgICByZXR1cm4gVmVjMkZ1bmMuY3Jvc3ModGhpcywgdmEpO1xuICB9XG5cbiAgc2NhbGUodikge1xuICAgIFZlYzJGdW5jLnNjYWxlKHRoaXMsIHRoaXMsIHYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbm9ybWFsaXplKCkge1xuICAgIFZlYzJGdW5jLm5vcm1hbGl6ZSh0aGlzLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRvdCh2KSB7XG4gICAgcmV0dXJuIFZlYzJGdW5jLmRvdCh0aGlzLCB2KTtcbiAgfVxuXG4gIGVxdWFscyh2KSB7XG4gICAgcmV0dXJuIFZlYzJGdW5jLmV4YWN0RXF1YWxzKHRoaXMsIHYpO1xuICB9XG5cbiAgYXBwbHlNYXRyaXgzKG1hdDMpIHtcbiAgICBWZWMyRnVuYy50cmFuc2Zvcm1NYXQzKHRoaXMsIHRoaXMsIG1hdDMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXBwbHlNYXRyaXg0KG1hdDQpIHtcbiAgICBWZWMyRnVuYy50cmFuc2Zvcm1NYXQ0KHRoaXMsIHRoaXMsIG1hdDQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGVycCh2LCBhKSB7XG4gICAgVmVjMkZ1bmMubGVycCh0aGlzLCB0aGlzLCB2LCBhKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgVmVjMih0aGlzWzBdLCB0aGlzWzFdKTtcbiAgfVxuXG4gIGZyb21BcnJheShhLCBvID0gMCkge1xuICAgIHRoaXNbMF0gPSBhW29dO1xuICAgIHRoaXNbMV0gPSBhW28gKyAxXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvQXJyYXkoYSA9IFtdLCBvID0gMCkge1xuICAgIGFbb10gPSB0aGlzWzBdO1xuICAgIGFbbyArIDFdID0gdGhpc1sxXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG59IiwiaW1wb3J0ICogYXMgVmVjNEZ1bmMgZnJvbSAnLi9mdW5jdGlvbnMvVmVjNEZ1bmMuanMnO1xuZXhwb3J0IGNsYXNzIFZlYzQgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0geCwgeiA9IHgsIHcgPSB4KSB7XG4gICAgc3VwZXIoeCwgeSwgeiwgdyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpc1swXTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzWzFdO1xuICB9XG5cbiAgZ2V0IHooKSB7XG4gICAgcmV0dXJuIHRoaXNbMl07XG4gIH1cblxuICBnZXQgdygpIHtcbiAgICByZXR1cm4gdGhpc1szXTtcbiAgfVxuXG4gIHNldCB4KHYpIHtcbiAgICB0aGlzWzBdID0gdjtcbiAgfVxuXG4gIHNldCB5KHYpIHtcbiAgICB0aGlzWzFdID0gdjtcbiAgfVxuXG4gIHNldCB6KHYpIHtcbiAgICB0aGlzWzJdID0gdjtcbiAgfVxuXG4gIHNldCB3KHYpIHtcbiAgICB0aGlzWzNdID0gdjtcbiAgfVxuXG4gIHNldCh4LCB5LCB6LCB3KSB7XG4gICAgaWYgKHgubGVuZ3RoKSByZXR1cm4gdGhpcy5jb3B5KHgpO1xuICAgIFZlYzRGdW5jLnNldCh0aGlzLCB4LCB5LCB6LCB3KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvcHkodikge1xuICAgIFZlYzRGdW5jLmNvcHkodGhpcywgdik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBub3JtYWxpemUoKSB7XG4gICAgVmVjNEZ1bmMubm9ybWFsaXplKHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbUFycmF5KGEsIG8gPSAwKSB7XG4gICAgdGhpc1swXSA9IGFbb107XG4gICAgdGhpc1sxXSA9IGFbbyArIDFdO1xuICAgIHRoaXNbMl0gPSBhW28gKyAyXTtcbiAgICB0aGlzWzNdID0gYVtvICsgM107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0FycmF5KGEgPSBbXSwgbyA9IDApIHtcbiAgICBhW29dID0gdGhpc1swXTtcbiAgICBhW28gKyAxXSA9IHRoaXNbMV07XG4gICAgYVtvICsgMl0gPSB0aGlzWzJdO1xuICAgIGFbbyArIDNdID0gdGhpc1szXTtcbiAgICByZXR1cm4gYTtcbiAgfVxuXG59IiwiaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0dlb21ldHJ5LmpzJztcbmV4cG9ydCBjbGFzcyBQbGFuZSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoZ2wsIHtcbiAgICB3aWR0aCA9IDEsXG4gICAgaGVpZ2h0ID0gMSxcbiAgICB3aWR0aFNlZ21lbnRzID0gMSxcbiAgICBoZWlnaHRTZWdtZW50cyA9IDEsXG4gICAgYXR0cmlidXRlcyA9IHt9XG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHdTZWdzID0gd2lkdGhTZWdtZW50cztcbiAgICBjb25zdCBoU2VncyA9IGhlaWdodFNlZ21lbnRzOyAvLyBEZXRlcm1pbmUgbGVuZ3RoIG9mIGFycmF5c1xuXG4gICAgY29uc3QgbnVtID0gKHdTZWdzICsgMSkgKiAoaFNlZ3MgKyAxKTtcbiAgICBjb25zdCBudW1JbmRpY2VzID0gd1NlZ3MgKiBoU2VncyAqIDY7IC8vIEdlbmVyYXRlIGVtcHR5IGFycmF5cyBvbmNlXG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkobnVtICogMyk7XG4gICAgY29uc3Qgbm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShudW0gKiAzKTtcbiAgICBjb25zdCB1diA9IG5ldyBGbG9hdDMyQXJyYXkobnVtICogMik7XG4gICAgY29uc3QgaW5kZXggPSBudW0gPiA2NTUzNiA/IG5ldyBVaW50MzJBcnJheShudW1JbmRpY2VzKSA6IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcbiAgICBQbGFuZS5idWlsZFBsYW5lKHBvc2l0aW9uLCBub3JtYWwsIHV2LCBpbmRleCwgd2lkdGgsIGhlaWdodCwgMCwgd1NlZ3MsIGhTZWdzKTtcbiAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIGRhdGE6IHBvc2l0aW9uXG4gICAgICB9LFxuICAgICAgbm9ybWFsOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIGRhdGE6IG5vcm1hbFxuICAgICAgfSxcbiAgICAgIHV2OiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIGRhdGE6IHV2XG4gICAgICB9LFxuICAgICAgaW5kZXg6IHtcbiAgICAgICAgZGF0YTogaW5kZXhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdXBlcihnbCwgYXR0cmlidXRlcyk7XG4gIH1cblxuICBzdGF0aWMgYnVpbGRQbGFuZShwb3NpdGlvbiwgbm9ybWFsLCB1diwgaW5kZXgsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3U2VncywgaFNlZ3MsIHUgPSAwLCB2ID0gMSwgdyA9IDIsIHVEaXIgPSAxLCB2RGlyID0gLTEsIGkgPSAwLCBpaSA9IDApIHtcbiAgICBjb25zdCBpbyA9IGk7XG4gICAgY29uc3Qgc2VnVyA9IHdpZHRoIC8gd1NlZ3M7XG4gICAgY29uc3Qgc2VnSCA9IGhlaWdodCAvIGhTZWdzO1xuXG4gICAgZm9yIChsZXQgaXkgPSAwOyBpeSA8PSBoU2VnczsgaXkrKykge1xuICAgICAgbGV0IHkgPSBpeSAqIHNlZ0ggLSBoZWlnaHQgLyAyO1xuXG4gICAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDw9IHdTZWdzOyBpeCsrLCBpKyspIHtcbiAgICAgICAgbGV0IHggPSBpeCAqIHNlZ1cgLSB3aWR0aCAvIDI7XG4gICAgICAgIHBvc2l0aW9uW2kgKiAzICsgdV0gPSB4ICogdURpcjtcbiAgICAgICAgcG9zaXRpb25baSAqIDMgKyB2XSA9IHkgKiB2RGlyO1xuICAgICAgICBwb3NpdGlvbltpICogMyArIHddID0gZGVwdGggLyAyO1xuICAgICAgICBub3JtYWxbaSAqIDMgKyB1XSA9IDA7XG4gICAgICAgIG5vcm1hbFtpICogMyArIHZdID0gMDtcbiAgICAgICAgbm9ybWFsW2kgKiAzICsgd10gPSBkZXB0aCA+PSAwID8gMSA6IC0xO1xuICAgICAgICB1dltpICogMl0gPSBpeCAvIHdTZWdzO1xuICAgICAgICB1dltpICogMiArIDFdID0gMSAtIGl5IC8gaFNlZ3M7XG4gICAgICAgIGlmIChpeSA9PT0gaFNlZ3MgfHwgaXggPT09IHdTZWdzKSBjb250aW51ZTtcbiAgICAgICAgbGV0IGEgPSBpbyArIGl4ICsgaXkgKiAod1NlZ3MgKyAxKTtcbiAgICAgICAgbGV0IGIgPSBpbyArIGl4ICsgKGl5ICsgMSkgKiAod1NlZ3MgKyAxKTtcbiAgICAgICAgbGV0IGMgPSBpbyArIGl4ICsgKGl5ICsgMSkgKiAod1NlZ3MgKyAxKSArIDE7XG4gICAgICAgIGxldCBkID0gaW8gKyBpeCArIGl5ICogKHdTZWdzICsgMSkgKyAxO1xuICAgICAgICBpbmRleFtpaSAqIDZdID0gYTtcbiAgICAgICAgaW5kZXhbaWkgKiA2ICsgMV0gPSBiO1xuICAgICAgICBpbmRleFtpaSAqIDYgKyAyXSA9IGQ7XG4gICAgICAgIGluZGV4W2lpICogNiArIDNdID0gYjtcbiAgICAgICAgaW5kZXhbaWkgKiA2ICsgNF0gPSBjO1xuICAgICAgICBpbmRleFtpaSAqIDYgKyA1XSA9IGQ7XG4gICAgICAgIGlpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0iLCJpbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgUGxhbmUgfSBmcm9tICcuL1BsYW5lLmpzJztcbmV4cG9ydCBjbGFzcyBCb3ggZXh0ZW5kcyBHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgd2lkdGggPSAxLFxuICAgIGhlaWdodCA9IDEsXG4gICAgZGVwdGggPSAxLFxuICAgIHdpZHRoU2VnbWVudHMgPSAxLFxuICAgIGhlaWdodFNlZ21lbnRzID0gMSxcbiAgICBkZXB0aFNlZ21lbnRzID0gMSxcbiAgICBhdHRyaWJ1dGVzID0ge31cbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qgd1NlZ3MgPSB3aWR0aFNlZ21lbnRzO1xuICAgIGNvbnN0IGhTZWdzID0gaGVpZ2h0U2VnbWVudHM7XG4gICAgY29uc3QgZFNlZ3MgPSBkZXB0aFNlZ21lbnRzO1xuICAgIGNvbnN0IG51bSA9ICh3U2VncyArIDEpICogKGhTZWdzICsgMSkgKiAyICsgKHdTZWdzICsgMSkgKiAoZFNlZ3MgKyAxKSAqIDIgKyAoaFNlZ3MgKyAxKSAqIChkU2VncyArIDEpICogMjtcbiAgICBjb25zdCBudW1JbmRpY2VzID0gKHdTZWdzICogaFNlZ3MgKiAyICsgd1NlZ3MgKiBkU2VncyAqIDIgKyBoU2VncyAqIGRTZWdzICogMikgKiA2O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShudW0gKiAzKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG51bSAqIDMpO1xuICAgIGNvbnN0IHV2ID0gbmV3IEZsb2F0MzJBcnJheShudW0gKiAyKTtcbiAgICBjb25zdCBpbmRleCA9IG51bSA+IDY1NTM2ID8gbmV3IFVpbnQzMkFycmF5KG51bUluZGljZXMpIDogbmV3IFVpbnQxNkFycmF5KG51bUluZGljZXMpO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaWkgPSAwOyAvLyBsZWZ0LCByaWdodFxuXG4gICAgUGxhbmUuYnVpbGRQbGFuZShwb3NpdGlvbiwgbm9ybWFsLCB1diwgaW5kZXgsIGRlcHRoLCBoZWlnaHQsIHdpZHRoLCBkU2VncywgaFNlZ3MsIDIsIDEsIDAsIC0xLCAtMSwgaSwgaWkpO1xuICAgIFBsYW5lLmJ1aWxkUGxhbmUocG9zaXRpb24sIG5vcm1hbCwgdXYsIGluZGV4LCBkZXB0aCwgaGVpZ2h0LCAtd2lkdGgsIGRTZWdzLCBoU2VncywgMiwgMSwgMCwgMSwgLTEsIGkgKz0gKGRTZWdzICsgMSkgKiAoaFNlZ3MgKyAxKSwgaWkgKz0gZFNlZ3MgKiBoU2Vncyk7IC8vIHRvcCwgYm90dG9tXG5cbiAgICBQbGFuZS5idWlsZFBsYW5lKHBvc2l0aW9uLCBub3JtYWwsIHV2LCBpbmRleCwgd2lkdGgsIGRlcHRoLCBoZWlnaHQsIGRTZWdzLCBoU2VncywgMCwgMiwgMSwgMSwgMSwgaSArPSAoZFNlZ3MgKyAxKSAqIChoU2VncyArIDEpLCBpaSArPSBkU2VncyAqIGhTZWdzKTtcbiAgICBQbGFuZS5idWlsZFBsYW5lKHBvc2l0aW9uLCBub3JtYWwsIHV2LCBpbmRleCwgd2lkdGgsIGRlcHRoLCAtaGVpZ2h0LCBkU2VncywgaFNlZ3MsIDAsIDIsIDEsIDEsIC0xLCBpICs9ICh3U2VncyArIDEpICogKGRTZWdzICsgMSksIGlpICs9IHdTZWdzICogZFNlZ3MpOyAvLyBmcm9udCwgYmFja1xuXG4gICAgUGxhbmUuYnVpbGRQbGFuZShwb3NpdGlvbiwgbm9ybWFsLCB1diwgaW5kZXgsIHdpZHRoLCBoZWlnaHQsIC1kZXB0aCwgd1NlZ3MsIGhTZWdzLCAwLCAxLCAyLCAtMSwgLTEsIGkgKz0gKHdTZWdzICsgMSkgKiAoZFNlZ3MgKyAxKSwgaWkgKz0gd1NlZ3MgKiBkU2Vncyk7XG4gICAgUGxhbmUuYnVpbGRQbGFuZShwb3NpdGlvbiwgbm9ybWFsLCB1diwgaW5kZXgsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3U2VncywgaFNlZ3MsIDAsIDEsIDIsIDEsIC0xLCBpICs9ICh3U2VncyArIDEpICogKGhTZWdzICsgMSksIGlpICs9IHdTZWdzICogaFNlZ3MpO1xuICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgZGF0YTogcG9zaXRpb25cbiAgICAgIH0sXG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgZGF0YTogbm9ybWFsXG4gICAgICB9LFxuICAgICAgdXY6IHtcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgZGF0YTogdXZcbiAgICAgIH0sXG4gICAgICBpbmRleDoge1xuICAgICAgICBkYXRhOiBpbmRleFxuICAgICAgfVxuICAgIH0pO1xuICAgIHN1cGVyKGdsLCBhdHRyaWJ1dGVzKTtcbiAgfVxuXG59IiwiaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0dlb21ldHJ5LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuZXhwb3J0IGNsYXNzIFNwaGVyZSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoZ2wsIHtcbiAgICByYWRpdXMgPSAwLjUsXG4gICAgd2lkdGhTZWdtZW50cyA9IDE2LFxuICAgIGhlaWdodFNlZ21lbnRzID0gTWF0aC5jZWlsKHdpZHRoU2VnbWVudHMgKiAwLjUpLFxuICAgIHBoaVN0YXJ0ID0gMCxcbiAgICBwaGlMZW5ndGggPSBNYXRoLlBJICogMixcbiAgICB0aGV0YVN0YXJ0ID0gMCxcbiAgICB0aGV0YUxlbmd0aCA9IE1hdGguUEksXG4gICAgYXR0cmlidXRlcyA9IHt9XG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHdTZWdzID0gd2lkdGhTZWdtZW50cztcbiAgICBjb25zdCBoU2VncyA9IGhlaWdodFNlZ21lbnRzO1xuICAgIGNvbnN0IHBTdGFydCA9IHBoaVN0YXJ0O1xuICAgIGNvbnN0IHBMZW5ndGggPSBwaGlMZW5ndGg7XG4gICAgY29uc3QgdFN0YXJ0ID0gdGhldGFTdGFydDtcbiAgICBjb25zdCB0TGVuZ3RoID0gdGhldGFMZW5ndGg7XG4gICAgY29uc3QgbnVtID0gKHdTZWdzICsgMSkgKiAoaFNlZ3MgKyAxKTtcbiAgICBjb25zdCBudW1JbmRpY2VzID0gd1NlZ3MgKiBoU2VncyAqIDY7XG4gICAgY29uc3QgcG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KG51bSAqIDMpO1xuICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobnVtICogMyk7XG4gICAgY29uc3QgdXYgPSBuZXcgRmxvYXQzMkFycmF5KG51bSAqIDIpO1xuICAgIGNvbnN0IGluZGV4ID0gbnVtID4gNjU1MzYgPyBuZXcgVWludDMyQXJyYXkobnVtSW5kaWNlcykgOiBuZXcgVWludDE2QXJyYXkobnVtSW5kaWNlcyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBpdiA9IDA7XG4gICAgbGV0IGlpID0gMDtcbiAgICBsZXQgdGUgPSB0U3RhcnQgKyB0TGVuZ3RoO1xuICAgIGNvbnN0IGdyaWQgPSBbXTtcbiAgICBsZXQgbiA9IG5ldyBWZWMzKCk7XG5cbiAgICBmb3IgKGxldCBpeSA9IDA7IGl5IDw9IGhTZWdzOyBpeSsrKSB7XG4gICAgICBsZXQgdlJvdyA9IFtdO1xuICAgICAgbGV0IHYgPSBpeSAvIGhTZWdzO1xuXG4gICAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDw9IHdTZWdzOyBpeCsrLCBpKyspIHtcbiAgICAgICAgbGV0IHUgPSBpeCAvIHdTZWdzO1xuICAgICAgICBsZXQgeCA9IC1yYWRpdXMgKiBNYXRoLmNvcyhwU3RhcnQgKyB1ICogcExlbmd0aCkgKiBNYXRoLnNpbih0U3RhcnQgKyB2ICogdExlbmd0aCk7XG4gICAgICAgIGxldCB5ID0gcmFkaXVzICogTWF0aC5jb3ModFN0YXJ0ICsgdiAqIHRMZW5ndGgpO1xuICAgICAgICBsZXQgeiA9IHJhZGl1cyAqIE1hdGguc2luKHBTdGFydCArIHUgKiBwTGVuZ3RoKSAqIE1hdGguc2luKHRTdGFydCArIHYgKiB0TGVuZ3RoKTtcbiAgICAgICAgcG9zaXRpb25baSAqIDNdID0geDtcbiAgICAgICAgcG9zaXRpb25baSAqIDMgKyAxXSA9IHk7XG4gICAgICAgIHBvc2l0aW9uW2kgKiAzICsgMl0gPSB6O1xuICAgICAgICBuLnNldCh4LCB5LCB6KS5ub3JtYWxpemUoKTtcbiAgICAgICAgbm9ybWFsW2kgKiAzXSA9IG4ueDtcbiAgICAgICAgbm9ybWFsW2kgKiAzICsgMV0gPSBuLnk7XG4gICAgICAgIG5vcm1hbFtpICogMyArIDJdID0gbi56O1xuICAgICAgICB1dltpICogMl0gPSB1O1xuICAgICAgICB1dltpICogMiArIDFdID0gMSAtIHY7XG4gICAgICAgIHZSb3cucHVzaChpdisrKTtcbiAgICAgIH1cblxuICAgICAgZ3JpZC5wdXNoKHZSb3cpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGl5ID0gMDsgaXkgPCBoU2VnczsgaXkrKykge1xuICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IHdTZWdzOyBpeCsrKSB7XG4gICAgICAgIGxldCBhID0gZ3JpZFtpeV1baXggKyAxXTtcbiAgICAgICAgbGV0IGIgPSBncmlkW2l5XVtpeF07XG4gICAgICAgIGxldCBjID0gZ3JpZFtpeSArIDFdW2l4XTtcbiAgICAgICAgbGV0IGQgPSBncmlkW2l5ICsgMV1baXggKyAxXTtcblxuICAgICAgICBpZiAoaXkgIT09IDAgfHwgdFN0YXJ0ID4gMCkge1xuICAgICAgICAgIGluZGV4W2lpICogM10gPSBhO1xuICAgICAgICAgIGluZGV4W2lpICogMyArIDFdID0gYjtcbiAgICAgICAgICBpbmRleFtpaSAqIDMgKyAyXSA9IGQ7XG4gICAgICAgICAgaWkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpeSAhPT0gaFNlZ3MgLSAxIHx8IHRlIDwgTWF0aC5QSSkge1xuICAgICAgICAgIGluZGV4W2lpICogM10gPSBiO1xuICAgICAgICAgIGluZGV4W2lpICogMyArIDFdID0gYztcbiAgICAgICAgICBpbmRleFtpaSAqIDMgKyAyXSA9IGQ7XG4gICAgICAgICAgaWkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgZGF0YTogcG9zaXRpb25cbiAgICAgIH0sXG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgZGF0YTogbm9ybWFsXG4gICAgICB9LFxuICAgICAgdXY6IHtcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgZGF0YTogdXZcbiAgICAgIH0sXG4gICAgICBpbmRleDoge1xuICAgICAgICBkYXRhOiBpbmRleFxuICAgICAgfVxuICAgIH0pO1xuICAgIHN1cGVyKGdsLCBhdHRyaWJ1dGVzKTtcbiAgfVxuXG59IiwiaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0dlb21ldHJ5LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuZXhwb3J0IGNsYXNzIEN5bGluZGVyIGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihnbCwge1xuICAgIHJhZGl1c1RvcCA9IDAuNSxcbiAgICByYWRpdXNCb3R0b20gPSAwLjUsXG4gICAgaGVpZ2h0ID0gMSxcbiAgICByYWRpYWxTZWdtZW50cyA9IDgsXG4gICAgaGVpZ2h0U2VnbWVudHMgPSAxLFxuICAgIG9wZW5FbmRlZCA9IGZhbHNlLFxuICAgIHRoZXRhU3RhcnQgPSAwLFxuICAgIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIsXG4gICAgYXR0cmlidXRlcyA9IHt9XG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHJTZWdzID0gcmFkaWFsU2VnbWVudHM7XG4gICAgY29uc3QgaFNlZ3MgPSBoZWlnaHRTZWdtZW50cztcbiAgICBjb25zdCB0U3RhcnQgPSB0aGV0YVN0YXJ0O1xuICAgIGNvbnN0IHRMZW5ndGggPSB0aGV0YUxlbmd0aDtcbiAgICBjb25zdCBudW1DYXBzID0gb3BlbkVuZGVkID8gMCA6IHJhZGl1c0JvdHRvbSAmJiByYWRpdXNUb3AgPyAyIDogMTtcbiAgICBjb25zdCBudW0gPSAoclNlZ3MgKyAxKSAqIChoU2VncyArIDEgKyBudW1DYXBzKSArIG51bUNhcHM7XG4gICAgY29uc3QgbnVtSW5kaWNlcyA9IHJTZWdzICogaFNlZ3MgKiA2ICsgbnVtQ2FwcyAqIHJTZWdzICogMztcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkobnVtICogMyk7XG4gICAgY29uc3Qgbm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheShudW0gKiAzKTtcbiAgICBjb25zdCB1diA9IG5ldyBGbG9hdDMyQXJyYXkobnVtICogMik7XG4gICAgY29uc3QgaW5kZXggPSBudW0gPiA2NTUzNiA/IG5ldyBVaW50MzJBcnJheShudW1JbmRpY2VzKSA6IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGlpID0gMDtcbiAgICBjb25zdCBpbmRleEFycmF5ID0gW107XG4gICAgYWRkSGVpZ2h0KCk7XG5cbiAgICBpZiAoIW9wZW5FbmRlZCkge1xuICAgICAgaWYgKHJhZGl1c1RvcCkgYWRkQ2FwKHRydWUpO1xuICAgICAgaWYgKHJhZGl1c0JvdHRvbSkgYWRkQ2FwKGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRIZWlnaHQoKSB7XG4gICAgICBsZXQgeCwgeTtcbiAgICAgIGNvbnN0IG4gPSBuZXcgVmVjMygpO1xuICAgICAgY29uc3Qgc2xvcGUgPSAocmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wKSAvIGhlaWdodDtcblxuICAgICAgZm9yICh5ID0gMDsgeSA8PSBoU2VnczsgeSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4Um93ID0gW107XG4gICAgICAgIGNvbnN0IHYgPSB5IC8gaFNlZ3M7XG4gICAgICAgIGNvbnN0IHIgPSB2ICogKHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCkgKyByYWRpdXNUb3A7XG5cbiAgICAgICAgZm9yICh4ID0gMDsgeCA8PSByU2VnczsgeCsrKSB7XG4gICAgICAgICAgY29uc3QgdSA9IHggLyByU2VncztcbiAgICAgICAgICBjb25zdCB0aGV0YSA9IHUgKiB0TGVuZ3RoICsgdFN0YXJ0O1xuICAgICAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICAgIGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uLnNldChbciAqIHNpblRoZXRhLCAoMC41IC0gdikgKiBoZWlnaHQsIHIgKiBjb3NUaGV0YV0sIGkgKiAzKTtcbiAgICAgICAgICBuLnNldChzaW5UaGV0YSwgc2xvcGUsIGNvc1RoZXRhKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICBub3JtYWwuc2V0KFtuLngsIG4ueSwgbi56XSwgaSAqIDMpO1xuICAgICAgICAgIHV2LnNldChbdSwgMSAtIHZdLCBpICogMik7XG4gICAgICAgICAgaW5kZXhSb3cucHVzaChpKyspO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhBcnJheS5wdXNoKGluZGV4Um93KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh4ID0gMDsgeCA8IHJTZWdzOyB4KyspIHtcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhTZWdzOyB5KyspIHtcbiAgICAgICAgICBjb25zdCBhID0gaW5kZXhBcnJheVt5XVt4XTtcbiAgICAgICAgICBjb25zdCBiID0gaW5kZXhBcnJheVt5ICsgMV1beF07XG4gICAgICAgICAgY29uc3QgYyA9IGluZGV4QXJyYXlbeSArIDFdW3ggKyAxXTtcbiAgICAgICAgICBjb25zdCBkID0gaW5kZXhBcnJheVt5XVt4ICsgMV07XG4gICAgICAgICAgaW5kZXguc2V0KFthLCBiLCBkLCBiLCBjLCBkXSwgaWkgKiAzKTtcbiAgICAgICAgICBpaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ2FwKGlzVG9wKSB7XG4gICAgICBsZXQgeDtcbiAgICAgIGNvbnN0IHIgPSBpc1RvcCA9PT0gdHJ1ZSA/IHJhZGl1c1RvcCA6IHJhZGl1c0JvdHRvbTtcbiAgICAgIGNvbnN0IHNpZ24gPSBpc1RvcCA9PT0gdHJ1ZSA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IGNlbnRlckluZGV4ID0gaTtcbiAgICAgIHBvc2l0aW9uLnNldChbMCwgMC41ICogaGVpZ2h0ICogc2lnbiwgMF0sIGkgKiAzKTtcbiAgICAgIG5vcm1hbC5zZXQoWzAsIHNpZ24sIDBdLCBpICogMyk7XG4gICAgICB1di5zZXQoWzAuNSwgMC41XSwgaSAqIDIpO1xuICAgICAgaSsrO1xuXG4gICAgICBmb3IgKHggPSAwOyB4IDw9IHJTZWdzOyB4KyspIHtcbiAgICAgICAgY29uc3QgdSA9IHggLyByU2VncztcbiAgICAgICAgY29uc3QgdGhldGEgPSB1ICogdExlbmd0aCArIHRTdGFydDtcbiAgICAgICAgY29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICBwb3NpdGlvbi5zZXQoW3IgKiBzaW5UaGV0YSwgMC41ICogaGVpZ2h0ICogc2lnbiwgciAqIGNvc1RoZXRhXSwgaSAqIDMpO1xuICAgICAgICBub3JtYWwuc2V0KFswLCBzaWduLCAwXSwgaSAqIDMpO1xuICAgICAgICB1di5zZXQoW2Nvc1RoZXRhICogMC41ICsgMC41LCBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKyAwLjVdLCBpICogMik7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgZm9yICh4ID0gMDsgeCA8IHJTZWdzOyB4KyspIHtcbiAgICAgICAgY29uc3QgaiA9IGNlbnRlckluZGV4ICsgeCArIDE7XG5cbiAgICAgICAgaWYgKGlzVG9wKSB7XG4gICAgICAgICAgaW5kZXguc2V0KFtqLCBqICsgMSwgY2VudGVySW5kZXhdLCBpaSAqIDMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4LnNldChbaiArIDEsIGosIGNlbnRlckluZGV4XSwgaWkgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBkYXRhOiBwb3NpdGlvblxuICAgICAgfSxcbiAgICAgIG5vcm1hbDoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBkYXRhOiBub3JtYWxcbiAgICAgIH0sXG4gICAgICB1djoge1xuICAgICAgICBzaXplOiAyLFxuICAgICAgICBkYXRhOiB1dlxuICAgICAgfSxcbiAgICAgIGluZGV4OiB7XG4gICAgICAgIGRhdGE6IGluZGV4XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3VwZXIoZ2wsIGF0dHJpYnV0ZXMpO1xuICB9XG5cbn0iLCJpbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvR2VvbWV0cnkuanMnO1xuZXhwb3J0IGNsYXNzIFRyaWFuZ2xlIGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihnbCwge1xuICAgIGF0dHJpYnV0ZXMgPSB7fVxuICB9ID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgMywgLTEsIC0xLCAzXSlcbiAgICAgIH0sXG4gICAgICB1djoge1xuICAgICAgICBzaXplOiAyLFxuICAgICAgICBkYXRhOiBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdXBlcihnbCwgYXR0cmlidXRlcyk7XG4gIH1cblxufSIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9tYXN0ZXIvc3JjL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeS5qc1xuaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0dlb21ldHJ5LmpzJztcbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuZXhwb3J0IGNsYXNzIFRvcnVzIGV4dGVuZHMgR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcihnbCwge1xuICAgIHJhZGl1cyA9IDAuNSxcbiAgICB0dWJlID0gMC4yLFxuICAgIHJhZGlhbFNlZ21lbnRzID0gOCxcbiAgICB0dWJ1bGFyU2VnbWVudHMgPSA2LFxuICAgIGFyYyA9IE1hdGguUEkgKiAyLFxuICAgIGF0dHJpYnV0ZXMgPSB7fVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBudW0gPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqICh0dWJ1bGFyU2VnbWVudHMgKyAxKTtcbiAgICBjb25zdCBudW1JbmRpY2VzID0gcmFkaWFsU2VnbWVudHMgKiB0dWJ1bGFyU2VnbWVudHMgKiA2O1xuICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW0gKiAzKTtcbiAgICBjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShudW0gKiAzKTtcbiAgICBjb25zdCB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KG51bSAqIDIpO1xuICAgIGNvbnN0IGluZGljZXMgPSBudW0gPiA2NTUzNiA/IG5ldyBVaW50MzJBcnJheShudW1JbmRpY2VzKSA6IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKTtcbiAgICBjb25zdCBjZW50ZXIgPSBuZXcgVmVjMygpO1xuICAgIGNvbnN0IHZlcnRleCA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3Qgbm9ybWFsID0gbmV3IFZlYzMoKTsgLy8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgbGV0IGlkeCA9IDA7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKywgaWR4KyspIHtcbiAgICAgICAgY29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG4gICAgICAgIGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjsgLy8gdmVydGV4XG5cbiAgICAgICAgdmVydGV4LnggPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguY29zKHUpO1xuICAgICAgICB2ZXJ0ZXgueSA9IChyYWRpdXMgKyB0dWJlICogTWF0aC5jb3ModikpICogTWF0aC5zaW4odSk7XG4gICAgICAgIHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKHYpO1xuICAgICAgICB2ZXJ0aWNlcy5zZXQoW3ZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnpdLCBpZHggKiAzKTsgLy8gbm9ybWFsXG5cbiAgICAgICAgY2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyh1KTtcbiAgICAgICAgY2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbih1KTtcbiAgICAgICAgbm9ybWFsLnN1Yih2ZXJ0ZXgsIGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIG5vcm1hbHMuc2V0KFtub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56XSwgaWR4ICogMyk7IC8vIHV2XG5cbiAgICAgICAgdXZzLnNldChbaSAvIHR1YnVsYXJTZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzXSwgaWR4ICogMik7XG4gICAgICB9XG4gICAgfSAvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblxuICAgIGlkeCA9IDA7XG5cbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkrKywgaWR4KyspIHtcbiAgICAgICAgLy8gaW5kaWNlc1xuICAgICAgICBjb25zdCBhID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogaiArIGkgLSAxO1xuICAgICAgICBjb25zdCBiID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogKGogLSAxKSArIGkgLSAxO1xuICAgICAgICBjb25zdCBjID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogKGogLSAxKSArIGk7XG4gICAgICAgIGNvbnN0IGQgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaTsgLy8gZmFjZXNcblxuICAgICAgICBpbmRpY2VzLnNldChbYSwgYiwgZCwgYiwgYywgZF0sIGlkeCAqIDYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgZGF0YTogdmVydGljZXNcbiAgICAgIH0sXG4gICAgICBub3JtYWw6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgZGF0YTogbm9ybWFsc1xuICAgICAgfSxcbiAgICAgIHV2OiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIGRhdGE6IHV2c1xuICAgICAgfSxcbiAgICAgIGluZGV4OiB7XG4gICAgICAgIGRhdGE6IGluZGljZXNcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdXBlcihnbCwgYXR0cmlidXRlcyk7XG4gIH1cblxufSIsIi8vIEJhc2VkIGZyb20gVGhyZWVKUycgT3JiaXRDb250cm9scyBjbGFzcywgcmV3cml0dGVuIHVzaW5nIGVzNiB3aXRoIHNvbWUgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMuXG4vLyBUT0RPOiBhYnN0cmFjdCBldmVudCBoYW5kbGVycyBzbyBjYW4gYmUgZmVkIGZyb20gb3RoZXIgc291cmNlc1xuLy8gVE9ETzogbWFrZSBzY3JvbGwgem9vbSBtb3JlIGFjY3VyYXRlIHRoYW4ganVzdCA+LzwgemVyb1xuLy8gVE9ETzogYmUgYWJsZSB0byBwYXNzIGluIG5ldyBjYW1lcmEgcG9zaXRpb25cbmltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuaW1wb3J0IHsgVmVjMiB9IGZyb20gJy4uL21hdGgvVmVjMi5qcyc7XG5jb25zdCBTVEFURSA9IHtcbiAgTk9ORTogLTEsXG4gIFJPVEFURTogMCxcbiAgRE9MTFk6IDEsXG4gIFBBTjogMixcbiAgRE9MTFlfUEFOOiAzXG59O1xuY29uc3QgdGVtcFZlYzMgPSBuZXcgVmVjMygpO1xuY29uc3QgdGVtcFZlYzJhID0gbmV3IFZlYzIoKTtcbmNvbnN0IHRlbXBWZWMyYiA9IG5ldyBWZWMyKCk7XG5leHBvcnQgZnVuY3Rpb24gT3JiaXQob2JqZWN0LCB7XG4gIGVsZW1lbnQgPSBkb2N1bWVudCxcbiAgZW5hYmxlZCA9IHRydWUsXG4gIHRhcmdldCA9IG5ldyBWZWMzKCksXG4gIGVhc2UgPSAwLjI1LFxuICBpbmVydGlhID0gMC44NSxcbiAgZW5hYmxlUm90YXRlID0gdHJ1ZSxcbiAgcm90YXRlU3BlZWQgPSAwLjEsXG4gIGF1dG9Sb3RhdGUgPSBmYWxzZSxcbiAgYXV0b1JvdGF0ZVNwZWVkID0gMS4wLFxuICBlbmFibGVab29tID0gdHJ1ZSxcbiAgem9vbVNwZWVkID0gMSxcbiAgZW5hYmxlUGFuID0gdHJ1ZSxcbiAgcGFuU3BlZWQgPSAwLjEsXG4gIG1pblBvbGFyQW5nbGUgPSAwLFxuICBtYXhQb2xhckFuZ2xlID0gTWF0aC5QSSxcbiAgbWluQXppbXV0aEFuZ2xlID0gLUluZmluaXR5LFxuICBtYXhBemltdXRoQW5nbGUgPSBJbmZpbml0eSxcbiAgbWluRGlzdGFuY2UgPSAwLFxuICBtYXhEaXN0YW5jZSA9IEluZmluaXR5XG59ID0ge30pIHtcbiAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7IC8vIENhdGNoIGF0dGVtcHRzIHRvIGRpc2FibGUgLSBzZXQgdG8gMSBzbyBoYXMgbm8gZWZmZWN0XG5cbiAgZWFzZSA9IGVhc2UgfHwgMTtcbiAgaW5lcnRpYSA9IGluZXJ0aWEgfHwgMTtcbiAgdGhpcy5taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuICB0aGlzLm1heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7IC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsVGFyZ2V0IGNvb3JkaW5hdGVzXG5cbiAgY29uc3Qgc3BoZXJpY2FsRGVsdGEgPSB7XG4gICAgcmFkaXVzOiAxLFxuICAgIHBoaTogMCxcbiAgICB0aGV0YTogMFxuICB9O1xuICBjb25zdCBzcGhlcmljYWxUYXJnZXQgPSB7XG4gICAgcmFkaXVzOiAxLFxuICAgIHBoaTogMCxcbiAgICB0aGV0YTogMFxuICB9O1xuICBjb25zdCBzcGhlcmljYWwgPSB7XG4gICAgcmFkaXVzOiAxLFxuICAgIHBoaTogMCxcbiAgICB0aGV0YTogMFxuICB9O1xuICBjb25zdCBwYW5EZWx0YSA9IG5ldyBWZWMzKCk7IC8vIEdyYWIgaW5pdGlhbCBwb3NpdGlvbiB2YWx1ZXNcblxuICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjMygpO1xuICBvZmZzZXQuY29weShvYmplY3QucG9zaXRpb24pLnN1Yih0aGlzLnRhcmdldCk7XG4gIHNwaGVyaWNhbC5yYWRpdXMgPSBzcGhlcmljYWxUYXJnZXQucmFkaXVzID0gb2Zmc2V0LmRpc3RhbmNlKCk7XG4gIHNwaGVyaWNhbC50aGV0YSA9IHNwaGVyaWNhbFRhcmdldC50aGV0YSA9IE1hdGguYXRhbjIob2Zmc2V0LngsIG9mZnNldC56KTtcbiAgc3BoZXJpY2FsLnBoaSA9IHNwaGVyaWNhbFRhcmdldC5waGkgPSBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgob2Zmc2V0LnkgLyBzcGhlcmljYWxUYXJnZXQucmFkaXVzLCAtMSksIDEpKTtcblxuICB0aGlzLnVwZGF0ZSA9ICgpID0+IHtcbiAgICBpZiAoYXV0b1JvdGF0ZSkge1xuICAgICAgaGFuZGxlQXV0b1JvdGF0ZSgpO1xuICAgIH0gLy8gYXBwbHkgZGVsdGFcblxuXG4gICAgc3BoZXJpY2FsVGFyZ2V0LnJhZGl1cyAqPSBzcGhlcmljYWxEZWx0YS5yYWRpdXM7XG4gICAgc3BoZXJpY2FsVGFyZ2V0LnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhO1xuICAgIHNwaGVyaWNhbFRhcmdldC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpOyAvLyBhcHBseSBib3VuZGFyaWVzXG5cbiAgICBzcGhlcmljYWxUYXJnZXQudGhldGEgPSBNYXRoLm1heChtaW5BemltdXRoQW5nbGUsIE1hdGgubWluKG1heEF6aW11dGhBbmdsZSwgc3BoZXJpY2FsVGFyZ2V0LnRoZXRhKSk7XG4gICAgc3BoZXJpY2FsVGFyZ2V0LnBoaSA9IE1hdGgubWF4KG1pblBvbGFyQW5nbGUsIE1hdGgubWluKG1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbFRhcmdldC5waGkpKTtcbiAgICBzcGhlcmljYWxUYXJnZXQucmFkaXVzID0gTWF0aC5tYXgodGhpcy5taW5EaXN0YW5jZSwgTWF0aC5taW4odGhpcy5tYXhEaXN0YW5jZSwgc3BoZXJpY2FsVGFyZ2V0LnJhZGl1cykpOyAvLyBlYXNlIHZhbHVlc1xuXG4gICAgc3BoZXJpY2FsLnBoaSArPSAoc3BoZXJpY2FsVGFyZ2V0LnBoaSAtIHNwaGVyaWNhbC5waGkpICogZWFzZTtcbiAgICBzcGhlcmljYWwudGhldGEgKz0gKHNwaGVyaWNhbFRhcmdldC50aGV0YSAtIHNwaGVyaWNhbC50aGV0YSkgKiBlYXNlO1xuICAgIHNwaGVyaWNhbC5yYWRpdXMgKz0gKHNwaGVyaWNhbFRhcmdldC5yYWRpdXMgLSBzcGhlcmljYWwucmFkaXVzKSAqIGVhc2U7IC8vIGFwcGx5IHBhbiB0byB0YXJnZXQuIEFzIG9mZnNldCBpcyByZWxhdGl2ZSB0byB0YXJnZXQsIGl0IGFsc28gc2hpZnRzXG5cbiAgICB0aGlzLnRhcmdldC5hZGQocGFuRGVsdGEpOyAvLyBhcHBseSByb3RhdGlvbiB0byBvZmZzZXRcblxuICAgIGxldCBzaW5QaGlSYWRpdXMgPSBzcGhlcmljYWwucmFkaXVzICogTWF0aC5zaW4oTWF0aC5tYXgoMC4wMDAwMDEsIHNwaGVyaWNhbC5waGkpKTtcbiAgICBvZmZzZXQueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKHNwaGVyaWNhbC50aGV0YSk7XG4gICAgb2Zmc2V0LnkgPSBzcGhlcmljYWwucmFkaXVzICogTWF0aC5jb3Moc3BoZXJpY2FsLnBoaSk7XG4gICAgb2Zmc2V0LnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyhzcGhlcmljYWwudGhldGEpOyAvLyBBcHBseSB1cGRhdGVkIHZhbHVlcyB0byBvYmplY3RcblxuICAgIG9iamVjdC5wb3NpdGlvbi5jb3B5KHRoaXMudGFyZ2V0KS5hZGQob2Zmc2V0KTtcbiAgICBvYmplY3QubG9va0F0KHRoaXMudGFyZ2V0KTsgLy8gQXBwbHkgaW5lcnRpYSB0byB2YWx1ZXNcblxuICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhICo9IGluZXJ0aWE7XG4gICAgc3BoZXJpY2FsRGVsdGEucGhpICo9IGluZXJ0aWE7XG4gICAgcGFuRGVsdGEubXVsdGlwbHkoaW5lcnRpYSk7IC8vIFJlc2V0IHNjYWxlIGV2ZXJ5IGZyYW1lIHRvIGF2b2lkIGFwcGx5aW5nIHNjYWxlIG11bHRpcGxlIHRpbWVzXG5cbiAgICBzcGhlcmljYWxEZWx0YS5yYWRpdXMgPSAxO1xuICB9OyAvLyBFdmVyeXRoaW5nIGJlbG93IGhlcmUganVzdCB1cGRhdGVzIHBhbkRlbHRhIGFuZCBzcGhlcmljYWxEZWx0YVxuICAvLyBVc2luZyB0aG9zZSB0d28gb2JqZWN0cycgdmFsdWVzLCB0aGUgb3JiaXQgaXMgY2FsY3VsYXRlZFxuXG5cbiAgY29uc3Qgcm90YXRlU3RhcnQgPSBuZXcgVmVjMigpO1xuICBjb25zdCBwYW5TdGFydCA9IG5ldyBWZWMyKCk7XG4gIGNvbnN0IGRvbGx5U3RhcnQgPSBuZXcgVmVjMigpO1xuICBsZXQgc3RhdGUgPSBTVEFURS5OT05FO1xuICB0aGlzLm1vdXNlQnV0dG9ucyA9IHtcbiAgICBPUkJJVDogMCxcbiAgICBaT09NOiAxLFxuICAgIFBBTjogMlxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMC45NSwgem9vbVNwZWVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhbkxlZnQoZGlzdGFuY2UsIG0pIHtcbiAgICB0ZW1wVmVjMy5zZXQobVswXSwgbVsxXSwgbVsyXSk7XG4gICAgdGVtcFZlYzMubXVsdGlwbHkoLWRpc3RhbmNlKTtcbiAgICBwYW5EZWx0YS5hZGQodGVtcFZlYzMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFuVXAoZGlzdGFuY2UsIG0pIHtcbiAgICB0ZW1wVmVjMy5zZXQobVs0XSwgbVs1XSwgbVs2XSk7XG4gICAgdGVtcFZlYzMubXVsdGlwbHkoZGlzdGFuY2UpO1xuICAgIHBhbkRlbHRhLmFkZCh0ZW1wVmVjMyk7XG4gIH1cblxuICBjb25zdCBwYW4gPSAoZGVsdGFYLCBkZWx0YVkpID0+IHtcbiAgICBsZXQgZWwgPSBlbGVtZW50ID09PSBkb2N1bWVudCA/IGRvY3VtZW50LmJvZHkgOiBlbGVtZW50O1xuICAgIHRlbXBWZWMzLmNvcHkob2JqZWN0LnBvc2l0aW9uKS5zdWIodGhpcy50YXJnZXQpO1xuICAgIGxldCB0YXJnZXREaXN0YW5jZSA9IHRlbXBWZWMzLmRpc3RhbmNlKCk7XG4gICAgdGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oKG9iamVjdC5mb3YgfHwgNDUpIC8gMiAqIE1hdGguUEkgLyAxODAuMCk7XG4gICAgcGFuTGVmdCgyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbC5jbGllbnRIZWlnaHQsIG9iamVjdC5tYXRyaXgpO1xuICAgIHBhblVwKDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsLmNsaWVudEhlaWdodCwgb2JqZWN0Lm1hdHJpeCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZG9sbHkoZG9sbHlTY2FsZSkge1xuICAgIHNwaGVyaWNhbERlbHRhLnJhZGl1cyAvPSBkb2xseVNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXV0b1JvdGF0ZSgpIHtcbiAgICBjb25zdCBhbmdsZSA9IDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIGF1dG9Sb3RhdGVTcGVlZDtcbiAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAtPSBhbmdsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdmVSb3RhdGUoeCwgeSkge1xuICAgIHRlbXBWZWMyYS5zZXQoeCwgeSk7XG4gICAgdGVtcFZlYzJiLnN1Yih0ZW1wVmVjMmEsIHJvdGF0ZVN0YXJ0KS5tdWx0aXBseShyb3RhdGVTcGVlZCk7XG4gICAgbGV0IGVsID0gZWxlbWVudCA9PT0gZG9jdW1lbnQgPyBkb2N1bWVudC5ib2R5IDogZWxlbWVudDtcbiAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAtPSAyICogTWF0aC5QSSAqIHRlbXBWZWMyYi54IC8gZWwuY2xpZW50SGVpZ2h0O1xuICAgIHNwaGVyaWNhbERlbHRhLnBoaSAtPSAyICogTWF0aC5QSSAqIHRlbXBWZWMyYi55IC8gZWwuY2xpZW50SGVpZ2h0O1xuICAgIHJvdGF0ZVN0YXJ0LmNvcHkodGVtcFZlYzJhKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KGUpIHtcbiAgICB0ZW1wVmVjMmEuc2V0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB0ZW1wVmVjMmIuc3ViKHRlbXBWZWMyYSwgZG9sbHlTdGFydCk7XG5cbiAgICBpZiAodGVtcFZlYzJiLnkgPiAwKSB7XG4gICAgICBkb2xseShnZXRab29tU2NhbGUoKSk7XG4gICAgfSBlbHNlIGlmICh0ZW1wVmVjMmIueSA8IDApIHtcbiAgICAgIGRvbGx5KDEgLyBnZXRab29tU2NhbGUoKSk7XG4gICAgfVxuXG4gICAgZG9sbHlTdGFydC5jb3B5KHRlbXBWZWMyYSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNb3ZlUGFuKHgsIHkpIHtcbiAgICB0ZW1wVmVjMmEuc2V0KHgsIHkpO1xuICAgIHRlbXBWZWMyYi5zdWIodGVtcFZlYzJhLCBwYW5TdGFydCkubXVsdGlwbHkocGFuU3BlZWQpO1xuICAgIHBhbih0ZW1wVmVjMmIueCwgdGVtcFZlYzJiLnkpO1xuICAgIHBhblN0YXJ0LmNvcHkodGVtcFZlYzJhKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbihlKSB7XG4gICAgaWYgKGVuYWJsZVpvb20pIHtcbiAgICAgIGxldCBkeCA9IGUudG91Y2hlc1swXS5wYWdlWCAtIGUudG91Y2hlc1sxXS5wYWdlWDtcbiAgICAgIGxldCBkeSA9IGUudG91Y2hlc1swXS5wYWdlWSAtIGUudG91Y2hlc1sxXS5wYWdlWTtcbiAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkb2xseVN0YXJ0LnNldCgwLCBkaXN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZVBhbikge1xuICAgICAgbGV0IHggPSAwLjUgKiAoZS50b3VjaGVzWzBdLnBhZ2VYICsgZS50b3VjaGVzWzFdLnBhZ2VYKTtcbiAgICAgIGxldCB5ID0gMC41ICogKGUudG91Y2hlc1swXS5wYWdlWSArIGUudG91Y2hlc1sxXS5wYWdlWSk7XG4gICAgICBwYW5TdGFydC5zZXQoeCwgeSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4oZSkge1xuICAgIGlmIChlbmFibGVab29tKSB7XG4gICAgICBsZXQgZHggPSBlLnRvdWNoZXNbMF0ucGFnZVggLSBlLnRvdWNoZXNbMV0ucGFnZVg7XG4gICAgICBsZXQgZHkgPSBlLnRvdWNoZXNbMF0ucGFnZVkgLSBlLnRvdWNoZXNbMV0ucGFnZVk7XG4gICAgICBsZXQgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgdGVtcFZlYzJhLnNldCgwLCBkaXN0YW5jZSk7XG4gICAgICB0ZW1wVmVjMmIuc2V0KDAsIE1hdGgucG93KHRlbXBWZWMyYS55IC8gZG9sbHlTdGFydC55LCB6b29tU3BlZWQpKTtcbiAgICAgIGRvbGx5KHRlbXBWZWMyYi55KTtcbiAgICAgIGRvbGx5U3RhcnQuY29weSh0ZW1wVmVjMmEpO1xuICAgIH1cblxuICAgIGlmIChlbmFibGVQYW4pIHtcbiAgICAgIGxldCB4ID0gMC41ICogKGUudG91Y2hlc1swXS5wYWdlWCArIGUudG91Y2hlc1sxXS5wYWdlWCk7XG4gICAgICBsZXQgeSA9IDAuNSAqIChlLnRvdWNoZXNbMF0ucGFnZVkgKyBlLnRvdWNoZXNbMV0ucGFnZVkpO1xuICAgICAgaGFuZGxlTW92ZVBhbih4LCB5KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBvbk1vdXNlRG93biA9IGUgPT4ge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG5cbiAgICBzd2l0Y2ggKGUuYnV0dG9uKSB7XG4gICAgICBjYXNlIHRoaXMubW91c2VCdXR0b25zLk9SQklUOlxuICAgICAgICBpZiAoZW5hYmxlUm90YXRlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICByb3RhdGVTdGFydC5zZXQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICBzdGF0ZSA9IFNUQVRFLlJPVEFURTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdGhpcy5tb3VzZUJ1dHRvbnMuWk9PTTpcbiAgICAgICAgaWYgKGVuYWJsZVpvb20gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGRvbGx5U3RhcnQuc2V0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgc3RhdGUgPSBTVEFURS5ET0xMWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdGhpcy5tb3VzZUJ1dHRvbnMuUEFOOlxuICAgICAgICBpZiAoZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBwYW5TdGFydC5zZXQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICBzdGF0ZSA9IFNUQVRFLlBBTjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSBTVEFURS5OT05FKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uTW91c2VNb3ZlID0gZSA9PiB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgU1RBVEUuUk9UQVRFOlxuICAgICAgICBpZiAoZW5hYmxlUm90YXRlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBoYW5kbGVNb3ZlUm90YXRlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1RBVEUuRE9MTFk6XG4gICAgICAgIGlmIChlbmFibGVab29tID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBoYW5kbGVNb3VzZU1vdmVEb2xseShlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1RBVEUuUEFOOlxuICAgICAgICBpZiAoZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBoYW5kbGVNb3ZlUGFuKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgfTtcblxuICBjb25zdCBvbk1vdXNlV2hlZWwgPSBlID0+IHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhZW5hYmxlWm9vbSB8fCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSAmJiBzdGF0ZSAhPT0gU1RBVEUuUk9UQVRFKSByZXR1cm47XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoZS5kZWx0YVkgPCAwKSB7XG4gICAgICBkb2xseSgxIC8gZ2V0Wm9vbVNjYWxlKCkpO1xuICAgIH0gZWxzZSBpZiAoZS5kZWx0YVkgPiAwKSB7XG4gICAgICBkb2xseShnZXRab29tU2NhbGUoKSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9uVG91Y2hTdGFydCA9IGUgPT4ge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgc3dpdGNoIChlLnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChlbmFibGVSb3RhdGUgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHJvdGF0ZVN0YXJ0LnNldChlLnRvdWNoZXNbMF0ucGFnZVgsIGUudG91Y2hlc1swXS5wYWdlWSk7XG4gICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBpZiAoZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0RG9sbHlQYW4oZSk7XG4gICAgICAgIHN0YXRlID0gU1RBVEUuRE9MTFlfUEFOO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvblRvdWNoTW92ZSA9IGUgPT4ge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBzd2l0Y2ggKGUudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKGVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgaGFuZGxlTW92ZVJvdGF0ZShlLnRvdWNoZXNbMF0ucGFnZVgsIGUudG91Y2hlc1swXS5wYWdlWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIGlmIChlbmFibGVab29tID09PSBmYWxzZSAmJiBlbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5UGFuKGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBvblRvdWNoRW5kID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICB9O1xuXG4gIGNvbnN0IG9uQ29udGV4dE1lbnUgPSBlID0+IHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGRIYW5kbGVycygpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25Nb3VzZVdoZWVsLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uTW91c2VXaGVlbCk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gIH07XG5cbiAgYWRkSGFuZGxlcnMoKTtcbn0iLCIvLyBUT0RPOiBhZGQgYmFyeWNlbnRyaWMgP1xuaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4uL21hdGgvVmVjMy5qcyc7XG5pbXBvcnQgeyBNYXQ0IH0gZnJvbSAnLi4vbWF0aC9NYXQ0LmpzJztcbmNvbnN0IHRlbXBWZWMzYSA9IG5ldyBWZWMzKCk7XG5jb25zdCB0ZW1wVmVjM2IgPSBuZXcgVmVjMygpO1xuY29uc3QgdGVtcFZlYzNjID0gbmV3IFZlYzMoKTtcbmNvbnN0IHRlbXBNYXQ0ID0gbmV3IE1hdDQoKTtcbmV4cG9ydCBjbGFzcyBSYXljYXN0IHtcbiAgY29uc3RydWN0b3IoZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5vcmlnaW4gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcbiAgfSAvLyBTZXQgcmF5IGZyb20gbW91c2UgdW5wcm9qZWN0aW9uXG5cblxuICBjYXN0TW91c2UoY2FtZXJhLCBtb3VzZSA9IFswLCAwXSkge1xuICAgIGlmIChjYW1lcmEudHlwZSA9PT0gJ29ydGhvZ3JhcGhpYycpIHtcbiAgICAgIC8vIFNldCBvcmlnaW5cbiAgICAgIC8vIFNpbmNlIGNhbWVyYSBpcyBvcnRob2dyYXBoaWMsIG9yaWdpbiBpcyBub3QgdGhlIGNhbWVyYSBwb3NpdGlvblxuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICB0b3AsXG4gICAgICAgIHpvb21cbiAgICAgIH0gPSBjYW1lcmE7XG4gICAgICBjb25zdCB4ID0gbGVmdCAvIHpvb20gKyAocmlnaHQgLSBsZWZ0KSAvIHpvb20gKiAobW91c2VbMF0gKiAwLjUgKyAwLjUpO1xuICAgICAgY29uc3QgeSA9IGJvdHRvbSAvIHpvb20gKyAodG9wIC0gYm90dG9tKSAvIHpvb20gKiAobW91c2VbMV0gKiAwLjUgKyAwLjUpO1xuICAgICAgdGhpcy5vcmlnaW4uc2V0KHgsIHksIDApO1xuICAgICAgdGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KGNhbWVyYS53b3JsZE1hdHJpeCk7IC8vIFNldCBkaXJlY3Rpb25cbiAgICAgIC8vIGh0dHBzOi8vY29tbXVuaXR5Lmtocm9ub3Mub3JnL3QvZ2V0LWRpcmVjdGlvbi1mcm9tLXRyYW5zZm9ybWF0aW9uLW1hdHJpeC1vci1xdWF0LzY1NTAyLzJcblxuICAgICAgdGhpcy5kaXJlY3Rpb24ueCA9IC1jYW1lcmEud29ybGRNYXRyaXhbOF07XG4gICAgICB0aGlzLmRpcmVjdGlvbi55ID0gLWNhbWVyYS53b3JsZE1hdHJpeFs5XTtcbiAgICAgIHRoaXMuZGlyZWN0aW9uLnogPSAtY2FtZXJhLndvcmxkTWF0cml4WzEwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IG9yaWdpblxuICAgICAgY2FtZXJhLndvcmxkTWF0cml4LmdldFRyYW5zbGF0aW9uKHRoaXMub3JpZ2luKTsgLy8gU2V0IGRpcmVjdGlvblxuXG4gICAgICB0aGlzLmRpcmVjdGlvbi5zZXQobW91c2VbMF0sIG1vdXNlWzFdLCAwLjUpO1xuICAgICAgY2FtZXJhLnVucHJvamVjdCh0aGlzLmRpcmVjdGlvbik7XG4gICAgICB0aGlzLmRpcmVjdGlvbi5zdWIodGhpcy5vcmlnaW4pLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGludGVyc2VjdEJvdW5kcyhtZXNoZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzaGVzKSkgbWVzaGVzID0gW21lc2hlc107XG4gICAgY29uc3QgaW52V29ybGRNYXQ0ID0gdGVtcE1hdDQ7XG4gICAgY29uc3Qgb3JpZ2luID0gdGVtcFZlYzNhO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRlbXBWZWMzYjtcbiAgICBjb25zdCBoaXRzID0gW107XG4gICAgbWVzaGVzLmZvckVhY2gobWVzaCA9PiB7XG4gICAgICAvLyBDcmVhdGUgYm91bmRzXG4gICAgICBpZiAoIW1lc2guZ2VvbWV0cnkuYm91bmRzKSBtZXNoLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgaWYgKG1lc2guZ2VvbWV0cnkucmF5Y2FzdCA9PT0gJ3NwaGVyZScgJiYgbWVzaC5nZW9tZXRyeS5ib3VuZHMucmFkaXVzID09PSBJbmZpbml0eSkgbWVzaC5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTsgLy8gVGFrZSB3b3JsZCBzcGFjZSByYXkgYW5kIG1ha2UgaXQgb2JqZWN0IHNwYWNlIHRvIGFsaWduIHdpdGggYm91bmRpbmcgYm94XG5cbiAgICAgIGludldvcmxkTWF0NC5pbnZlcnNlKG1lc2gud29ybGRNYXRyaXgpO1xuICAgICAgb3JpZ2luLmNvcHkodGhpcy5vcmlnaW4pLmFwcGx5TWF0cml4NChpbnZXb3JsZE1hdDQpO1xuICAgICAgZGlyZWN0aW9uLmNvcHkodGhpcy5kaXJlY3Rpb24pLnRyYW5zZm9ybURpcmVjdGlvbihpbnZXb3JsZE1hdDQpO1xuICAgICAgbGV0IGxvY2FsRGlzdGFuY2UgPSAwO1xuXG4gICAgICBpZiAobWVzaC5nZW9tZXRyeS5yYXljYXN0ID09PSAnc3BoZXJlJykge1xuICAgICAgICBsb2NhbERpc3RhbmNlID0gdGhpcy5pbnRlcnNlY3RTcGhlcmUobWVzaC5nZW9tZXRyeS5ib3VuZHMsIG9yaWdpbiwgZGlyZWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2FsRGlzdGFuY2UgPSB0aGlzLmludGVyc2VjdEJveChtZXNoLmdlb21ldHJ5LmJvdW5kcywgb3JpZ2luLCBkaXJlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxvY2FsRGlzdGFuY2UpIHJldHVybjsgLy8gQ3JlYXRlIG9iamVjdCBvbiBtZXNoIHRvIGF2b2lkIGdlbmVyYXRpbmcgbG90cyBvZiBvYmplY3RzXG5cbiAgICAgIGlmICghbWVzaC5oaXQpIG1lc2guaGl0ID0ge1xuICAgICAgICBsb2NhbFBvaW50OiBuZXcgVmVjMygpLFxuICAgICAgICBwb2ludDogbmV3IFZlYzMoKVxuICAgICAgfTtcbiAgICAgIG1lc2guaGl0LmxvY2FsUG9pbnQuY29weShkaXJlY3Rpb24pLm11bHRpcGx5KGxvY2FsRGlzdGFuY2UpLmFkZChvcmlnaW4pO1xuICAgICAgbWVzaC5oaXQucG9pbnQuY29weShtZXNoLmhpdC5sb2NhbFBvaW50KS5hcHBseU1hdHJpeDQobWVzaC53b3JsZE1hdHJpeCk7XG4gICAgICBtZXNoLmhpdC5kaXN0YW5jZSA9IG1lc2guaGl0LnBvaW50LmRpc3RhbmNlKHRoaXMub3JpZ2luKTtcbiAgICAgIGhpdHMucHVzaChtZXNoKTtcbiAgICB9KTtcbiAgICBoaXRzLnNvcnQoKGEsIGIpID0+IGEuaGl0LmRpc3RhbmNlIC0gYi5oaXQuZGlzdGFuY2UpO1xuICAgIHJldHVybiBoaXRzO1xuICB9XG5cbiAgaW50ZXJzZWN0U3BoZXJlKHNwaGVyZSwgb3JpZ2luID0gdGhpcy5vcmlnaW4sIGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgcmF5ID0gdGVtcFZlYzNjO1xuICAgIHJheS5zdWIoc3BoZXJlLmNlbnRlciwgb3JpZ2luKTtcbiAgICBjb25zdCB0Y2EgPSByYXkuZG90KGRpcmVjdGlvbik7XG4gICAgY29uc3QgZDIgPSByYXkuZG90KHJheSkgLSB0Y2EgKiB0Y2E7XG4gICAgY29uc3QgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuICAgIGlmIChkMiA+IHJhZGl1czIpIHJldHVybiAwO1xuICAgIGNvbnN0IHRoYyA9IE1hdGguc3FydChyYWRpdXMyIC0gZDIpO1xuICAgIGNvbnN0IHQwID0gdGNhIC0gdGhjO1xuICAgIGNvbnN0IHQxID0gdGNhICsgdGhjO1xuICAgIGlmICh0MCA8IDAgJiYgdDEgPCAwKSByZXR1cm4gMDtcbiAgICBpZiAodDAgPCAwKSByZXR1cm4gdDE7XG4gICAgcmV0dXJuIHQwO1xuICB9IC8vIFJheSBBQUJCIC0gUmF5IEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggdGVzdGluZ1xuXG5cbiAgaW50ZXJzZWN0Qm94KGJveCwgb3JpZ2luID0gdGhpcy5vcmlnaW4sIGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgbGV0IHRtaW4sIHRtYXgsIHRZbWluLCB0WW1heCwgdFptaW4sIHRabWF4O1xuICAgIGNvbnN0IGludmRpcnggPSAxIC8gZGlyZWN0aW9uLng7XG4gICAgY29uc3QgaW52ZGlyeSA9IDEgLyBkaXJlY3Rpb24ueTtcbiAgICBjb25zdCBpbnZkaXJ6ID0gMSAvIGRpcmVjdGlvbi56O1xuICAgIGNvbnN0IG1pbiA9IGJveC5taW47XG4gICAgY29uc3QgbWF4ID0gYm94Lm1heDtcbiAgICB0bWluID0gKChpbnZkaXJ4ID49IDAgPyBtaW4ueCA6IG1heC54KSAtIG9yaWdpbi54KSAqIGludmRpcng7XG4gICAgdG1heCA9ICgoaW52ZGlyeCA+PSAwID8gbWF4LnggOiBtaW4ueCkgLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuICAgIHRZbWluID0gKChpbnZkaXJ5ID49IDAgPyBtaW4ueSA6IG1heC55KSAtIG9yaWdpbi55KSAqIGludmRpcnk7XG4gICAgdFltYXggPSAoKGludmRpcnkgPj0gMCA/IG1heC55IDogbWluLnkpIC0gb3JpZ2luLnkpICogaW52ZGlyeTtcbiAgICBpZiAodG1pbiA+IHRZbWF4IHx8IHRZbWluID4gdG1heCkgcmV0dXJuIDA7XG4gICAgaWYgKHRZbWluID4gdG1pbikgdG1pbiA9IHRZbWluO1xuICAgIGlmICh0WW1heCA8IHRtYXgpIHRtYXggPSB0WW1heDtcbiAgICB0Wm1pbiA9ICgoaW52ZGlyeiA+PSAwID8gbWluLnogOiBtYXgueikgLSBvcmlnaW4ueikgKiBpbnZkaXJ6O1xuICAgIHRabWF4ID0gKChpbnZkaXJ6ID49IDAgPyBtYXgueiA6IG1pbi56KSAtIG9yaWdpbi56KSAqIGludmRpcno7XG4gICAgaWYgKHRtaW4gPiB0Wm1heCB8fCB0Wm1pbiA+IHRtYXgpIHJldHVybiAwO1xuICAgIGlmICh0Wm1pbiA+IHRtaW4pIHRtaW4gPSB0Wm1pbjtcbiAgICBpZiAodFptYXggPCB0bWF4KSB0bWF4ID0gdFptYXg7XG4gICAgaWYgKHRtYXggPCAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gdG1pbiA+PSAwID8gdG1pbiA6IHRtYXg7XG4gIH1cblxufSIsImltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuY29uc3QgQ0FUTVVMTFJPTSA9ICdjYXRtdWxscm9tJztcbmNvbnN0IENVQklDQkVaSUVSID0gJ2N1YmljYmV6aWVyJztcbmNvbnN0IFFVQURSQVRJQ0JFWklFUiA9ICdxdWFkcmF0aWNiZXppZXInOyAvLyB0ZW1wXG5cbmNvbnN0IF9hMCA9IG5ldyBWZWMzKCksXG4gICAgICBfYTEgPSBuZXcgVmVjMygpLFxuICAgICAgX2EyID0gbmV3IFZlYzMoKSxcbiAgICAgIF9hMyA9IG5ldyBWZWMzKCk7XG4vKipcbiAqIEdldCB0aGUgY29udHJvbCBwb2ludHMgb2YgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICogQHBhcmFtIHsqfSBpXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q3RybFBvaW50KHBvaW50cywgaSwgYSA9IDAuMTY4LCBiID0gMC4xNjgpIHtcbiAgaWYgKGkgPCAxKSB7XG4gICAgX2EwLnN1Yihwb2ludHNbMV0sIHBvaW50c1swXSkuc2NhbGUoYSkuYWRkKHBvaW50c1swXSk7XG4gIH0gZWxzZSB7XG4gICAgX2EwLnN1Yihwb2ludHNbaSArIDFdLCBwb2ludHNbaSAtIDFdKS5zY2FsZShhKS5hZGQocG9pbnRzW2ldKTtcbiAgfVxuXG4gIGlmIChpID4gcG9pbnRzLmxlbmd0aCAtIDMpIHtcbiAgICBjb25zdCBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICBfYTEuc3ViKHBvaW50c1tsYXN0IC0gMV0sIHBvaW50c1tsYXN0XSkuc2NhbGUoYikuYWRkKHBvaW50c1tsYXN0XSk7XG4gIH0gZWxzZSB7XG4gICAgX2ExLnN1Yihwb2ludHNbaV0sIHBvaW50c1tpICsgMl0pLnNjYWxlKGIpLmFkZChwb2ludHNbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBbX2EwLmNsb25lKCksIF9hMS5jbG9uZSgpXTtcbn1cblxuZnVuY3Rpb24gZ2V0UXVhZHJhdGljQmV6aWVyUG9pbnQodCwgcDAsIGMwLCBwMSkge1xuICBjb25zdCBrID0gMSAtIHQ7XG5cbiAgX2EwLmNvcHkocDApLnNjYWxlKGsgKiogMik7XG5cbiAgX2ExLmNvcHkoYzApLnNjYWxlKDIgKiBrICogdCk7XG5cbiAgX2EyLmNvcHkocDEpLnNjYWxlKHQgKiogMik7XG5cbiAgY29uc3QgcmV0ID0gbmV3IFZlYzMoKTtcbiAgcmV0LmFkZChfYTAsIF9hMSkuYWRkKF9hMik7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldEN1YmljQmV6aWVyUG9pbnQodCwgcDAsIGMwLCBjMSwgcDEpIHtcbiAgY29uc3QgayA9IDEgLSB0O1xuXG4gIF9hMC5jb3B5KHAwKS5zY2FsZShrICoqIDMpO1xuXG4gIF9hMS5jb3B5KGMwKS5zY2FsZSgzICogayAqKiAyICogdCk7XG5cbiAgX2EyLmNvcHkoYzEpLnNjYWxlKDMgKiBrICogdCAqKiAyKTtcblxuICBfYTMuY29weShwMSkuc2NhbGUodCAqKiAzKTtcblxuICBjb25zdCByZXQgPSBuZXcgVmVjMygpO1xuICByZXQuYWRkKF9hMCwgX2ExKS5hZGQoX2EyKS5hZGQoX2EzKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGNsYXNzIEN1cnZlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvaW50cyA9IFtuZXcgVmVjMygwLCAwLCAwKSwgbmV3IFZlYzMoMCwgMSwgMCksIG5ldyBWZWMzKDEsIDEsIDApLCBuZXcgVmVjMygxLCAwLCAwKV0sXG4gICAgZGl2aXNpb25zID0gMTIsXG4gICAgdHlwZSA9IENBVE1VTExST01cbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy5kaXZpc2lvbnMgPSBkaXZpc2lvbnM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIF9nZXRRdWFkcmF0aWNCZXppZXJQb2ludHMoZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnMpIHtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMucG9pbnRzLmxlbmd0aDtcblxuICAgIGlmIChjb3VudCA8IDMpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm90IGVub3VnaCBwb2ludHMgcHJvdmlkZWQuJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgcDAgPSB0aGlzLnBvaW50c1swXTtcbiAgICBsZXQgYzAgPSB0aGlzLnBvaW50c1sxXSxcbiAgICAgICAgcDEgPSB0aGlzLnBvaW50c1syXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSsrKSB7XG4gICAgICBjb25zdCBwID0gZ2V0UXVhZHJhdGljQmV6aWVyUG9pbnQoaSAvIGRpdmlzaW9ucywgcDAsIGMwLCBwMSk7XG4gICAgICBwb2ludHMucHVzaChwKTtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0ID0gMztcblxuICAgIHdoaWxlIChjb3VudCAtIG9mZnNldCA+IDApIHtcbiAgICAgIHAwLmNvcHkocDEpO1xuICAgICAgYzAgPSBwMS5zY2FsZSgyKS5zdWIoYzApO1xuICAgICAgcDEgPSB0aGlzLnBvaW50c1tvZmZzZXRdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBkaXZpc2lvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gZ2V0UXVhZHJhdGljQmV6aWVyUG9pbnQoaSAvIGRpdmlzaW9ucywgcDAsIGMwLCBwMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHApO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgX2dldEN1YmljQmV6aWVyUG9pbnRzKGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zKSB7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnBvaW50cy5sZW5ndGg7XG5cbiAgICBpZiAoY291bnQgPCA0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vdCBlbm91Z2ggcG9pbnRzIHByb3ZpZGVkLicpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCBwMCA9IHRoaXMucG9pbnRzWzBdLFxuICAgICAgICBjMCA9IHRoaXMucG9pbnRzWzFdLFxuICAgICAgICBjMSA9IHRoaXMucG9pbnRzWzJdLFxuICAgICAgICBwMSA9IHRoaXMucG9pbnRzWzNdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZGl2aXNpb25zOyBpKyspIHtcbiAgICAgIGNvbnN0IHAgPSBnZXRDdWJpY0JlemllclBvaW50KGkgLyBkaXZpc2lvbnMsIHAwLCBjMCwgYzEsIHAxKTtcbiAgICAgIHBvaW50cy5wdXNoKHApO1xuICAgIH1cblxuICAgIGxldCBvZmZzZXQgPSA0O1xuXG4gICAgd2hpbGUgKGNvdW50IC0gb2Zmc2V0ID4gMSkge1xuICAgICAgcDAuY29weShwMSk7XG4gICAgICBjMCA9IHAxLnNjYWxlKDIpLnN1YihjMSk7XG4gICAgICBjMSA9IHRoaXMucG9pbnRzW29mZnNldF07XG4gICAgICBwMSA9IHRoaXMucG9pbnRzW29mZnNldCArIDFdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBkaXZpc2lvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gZ2V0Q3ViaWNCZXppZXJQb2ludChpIC8gZGl2aXNpb25zLCBwMCwgYzAsIGMxLCBwMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKHApO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgX2dldENhdG11bGxSb21Qb2ludHMoZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnMsIGEgPSAwLjE2OCwgYiA9IDAuMTY4KSB7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnBvaW50cy5sZW5ndGg7XG5cbiAgICBpZiAoY291bnQgPD0gMikge1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRzO1xuICAgIH1cblxuICAgIGxldCBwMDtcbiAgICB0aGlzLnBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBwMCA9IHA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbYzAsIGMxXSA9IGdldEN0cmxQb2ludCh0aGlzLnBvaW50cywgaSAtIDEsIGEsIGIpO1xuICAgICAgICBjb25zdCBjID0gbmV3IEN1cnZlKHtcbiAgICAgICAgICBwb2ludHM6IFtwMCwgYzAsIGMxLCBwXSxcbiAgICAgICAgICB0eXBlOiBDVUJJQ0JFWklFUlxuICAgICAgICB9KTtcbiAgICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgICBwb2ludHMucHVzaCguLi5jLmdldFBvaW50cyhkaXZpc2lvbnMpKTtcbiAgICAgICAgcDAgPSBwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICBnZXRQb2ludHMoZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnMsIGEgPSAwLjE2OCwgYiA9IDAuMTY4KSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBRVUFEUkFUSUNCRVpJRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRRdWFkcmF0aWNCZXppZXJQb2ludHMoZGl2aXNpb25zKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gQ1VCSUNCRVpJRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDdWJpY0JlemllclBvaW50cyhkaXZpc2lvbnMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBDQVRNVUxMUk9NKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2F0bXVsbFJvbVBvaW50cyhkaXZpc2lvbnMsIGEsIGIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgfVxuXG59XG5DdXJ2ZS5DQVRNVUxMUk9NID0gQ0FUTVVMTFJPTTtcbkN1cnZlLkNVQklDQkVaSUVSID0gQ1VCSUNCRVpJRVI7XG5DdXJ2ZS5RVUFEUkFUSUNCRVpJRVIgPSBRVUFEUkFUSUNCRVpJRVI7IiwiLy8gVE9ETzogRGVzdHJveSByZW5kZXIgdGFyZ2V0cyBpZiBzaXplIGNoYW5nZWQgYW5kIGV4aXN0c1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gJy4uL2NvcmUvUHJvZ3JhbS5qcyc7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vY29yZS9NZXNoLmpzJztcbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4uL2NvcmUvUmVuZGVyVGFyZ2V0LmpzJztcbmltcG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi9UcmlhbmdsZS5qcyc7XG5leHBvcnQgY2xhc3MgUG9zdCB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGRwcixcbiAgICB3cmFwUyA9IGdsLkNMQU1QX1RPX0VER0UsXG4gICAgd3JhcFQgPSBnbC5DTEFNUF9UT19FREdFLFxuICAgIG1pbkZpbHRlciA9IGdsLkxJTkVBUixcbiAgICBtYWdGaWx0ZXIgPSBnbC5MSU5FQVIsXG4gICAgZ2VvbWV0cnkgPSBuZXcgVHJpYW5nbGUoZ2wpLFxuICAgIHRhcmdldE9ubHkgPSBudWxsXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB3cmFwUyxcbiAgICAgIHdyYXBULFxuICAgICAgbWluRmlsdGVyLFxuICAgICAgbWFnRmlsdGVyXG4gICAgfTtcbiAgICB0aGlzLnBhc3NlcyA9IFtdO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICB0aGlzLnVuaWZvcm0gPSB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gICAgdGhpcy50YXJnZXRPbmx5ID0gdGFyZ2V0T25seTtcbiAgICBjb25zdCBmYm8gPSB0aGlzLmZibyA9IHtcbiAgICAgIHJlYWQ6IG51bGwsXG4gICAgICB3cml0ZTogbnVsbCxcbiAgICAgIHN3YXA6ICgpID0+IHtcbiAgICAgICAgbGV0IHRlbXAgPSBmYm8ucmVhZDtcbiAgICAgICAgZmJvLnJlYWQgPSBmYm8ud3JpdGU7XG4gICAgICAgIGZiby53cml0ZSA9IHRlbXA7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlc2l6ZSh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGRwclxuICAgIH0pO1xuICB9XG5cbiAgYWRkUGFzcyh7XG4gICAgdmVydGV4ID0gZGVmYXVsdFZlcnRleCxcbiAgICBmcmFnbWVudCA9IGRlZmF1bHRGcmFnbWVudCxcbiAgICB1bmlmb3JtcyA9IHt9LFxuICAgIHRleHR1cmVVbmlmb3JtID0gJ3RNYXAnLFxuICAgIGVuYWJsZWQgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIHVuaWZvcm1zW3RleHR1cmVVbmlmb3JtXSA9IHtcbiAgICAgIHZhbHVlOiB0aGlzLmZiby5yZWFkLnRleHR1cmVcbiAgICB9O1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbSh0aGlzLmdsLCB7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIHVuaWZvcm1zXG4gICAgfSk7XG4gICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKHRoaXMuZ2wsIHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmdlb21ldHJ5LFxuICAgICAgcHJvZ3JhbVxuICAgIH0pO1xuICAgIGNvbnN0IHBhc3MgPSB7XG4gICAgICBtZXNoLFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgZW5hYmxlZCxcbiAgICAgIHRleHR1cmVVbmlmb3JtXG4gICAgfTtcbiAgICB0aGlzLnBhc3Nlcy5wdXNoKHBhc3MpO1xuICAgIHJldHVybiBwYXNzO1xuICB9XG5cbiAgcmVzaXplKHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZHByXG4gIH0gPSB7fSkge1xuICAgIGlmIChkcHIpIHRoaXMuZHByID0gZHByO1xuXG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCB3aWR0aDtcbiAgICB9XG5cbiAgICBkcHIgPSB0aGlzLmRwciB8fCB0aGlzLmdsLnJlbmRlcmVyLmRwcjtcbiAgICB3aWR0aCA9ICh0aGlzLndpZHRoIHx8IHRoaXMuZ2wucmVuZGVyZXIud2lkdGgpICogZHByO1xuICAgIGhlaWdodCA9ICh0aGlzLmhlaWdodCB8fCB0aGlzLmdsLnJlbmRlcmVyLmhlaWdodCkgKiBkcHI7XG4gICAgdGhpcy5vcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmZiby5yZWFkID0gbmV3IFJlbmRlclRhcmdldCh0aGlzLmdsLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuZmJvLndyaXRlID0gbmV3IFJlbmRlclRhcmdldCh0aGlzLmdsLCB0aGlzLm9wdGlvbnMpO1xuICB9IC8vIFVzZXMgc2FtZSBhcmd1bWVudHMgYXMgcmVuZGVyZXIucmVuZGVyXG5cblxuICByZW5kZXIoe1xuICAgIHNjZW5lLFxuICAgIGNhbWVyYSxcbiAgICB0YXJnZXQgPSBudWxsLFxuICAgIHVwZGF0ZSA9IHRydWUsXG4gICAgc29ydCA9IHRydWUsXG4gICAgZnJ1c3R1bUN1bGwgPSB0cnVlXG4gIH0pIHtcbiAgICBjb25zdCBlbmFibGVkUGFzc2VzID0gdGhpcy5wYXNzZXMuZmlsdGVyKHBhc3MgPT4gcGFzcy5lbmFibGVkKTtcbiAgICB0aGlzLmdsLnJlbmRlcmVyLnJlbmRlcih7XG4gICAgICBzY2VuZSxcbiAgICAgIGNhbWVyYSxcbiAgICAgIHRhcmdldDogZW5hYmxlZFBhc3Nlcy5sZW5ndGggfHwgIXRhcmdldCAmJiB0aGlzLnRhcmdldE9ubHkgPyB0aGlzLmZiby53cml0ZSA6IHRhcmdldCxcbiAgICAgIHVwZGF0ZSxcbiAgICAgIHNvcnQsXG4gICAgICBmcnVzdHVtQ3VsbFxuICAgIH0pO1xuICAgIHRoaXMuZmJvLnN3YXAoKTtcbiAgICBlbmFibGVkUGFzc2VzLmZvckVhY2goKHBhc3MsIGkpID0+IHtcbiAgICAgIHBhc3MubWVzaC5wcm9ncmFtLnVuaWZvcm1zW3Bhc3MudGV4dHVyZVVuaWZvcm1dLnZhbHVlID0gdGhpcy5mYm8ucmVhZC50ZXh0dXJlO1xuICAgICAgdGhpcy5nbC5yZW5kZXJlci5yZW5kZXIoe1xuICAgICAgICBzY2VuZTogcGFzcy5tZXNoLFxuICAgICAgICB0YXJnZXQ6IGkgPT09IGVuYWJsZWRQYXNzZXMubGVuZ3RoIC0gMSAmJiAodGFyZ2V0IHx8ICF0aGlzLnRhcmdldE9ubHkpID8gdGFyZ2V0IDogdGhpcy5mYm8ud3JpdGUsXG4gICAgICAgIGNsZWFyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmJvLnN3YXAoKTtcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm0udmFsdWUgPSB0aGlzLmZiby5yZWFkLnRleHR1cmU7XG4gIH1cblxufVxuY29uc3QgZGVmYXVsdFZlcnRleCA9XG4vKiBnbHNsICovXG5gXG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XG4gICAgYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2VXYgPSB1djtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcbiAgICB9XG5gO1xuY29uc3QgZGVmYXVsdEZyYWdtZW50ID1cbi8qIGdsc2wgKi9cbmBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB0TWFwO1xuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0TWFwLCB2VXYpO1xuICAgIH1cbmA7IiwiaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4uL21hdGgvVmVjMy5qcyc7XG5pbXBvcnQgeyBRdWF0IH0gZnJvbSAnLi4vbWF0aC9RdWF0LmpzJztcbmNvbnN0IHByZXZQb3MgPSBuZXcgVmVjMygpO1xuY29uc3QgcHJldlJvdCA9IG5ldyBRdWF0KCk7XG5jb25zdCBwcmV2U2NsID0gbmV3IFZlYzMoKTtcbmNvbnN0IG5leHRQb3MgPSBuZXcgVmVjMygpO1xuY29uc3QgbmV4dFJvdCA9IG5ldyBRdWF0KCk7XG5jb25zdCBuZXh0U2NsID0gbmV3IFZlYzMoKTtcbmV4cG9ydCBjbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb2JqZWN0cyxcbiAgICBkYXRhXG4gIH0pIHtcbiAgICB0aGlzLm9iamVjdHMgPSBvYmplY3RzO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5lbGFwc2VkID0gMDtcbiAgICB0aGlzLndlaWdodCA9IDE7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGRhdGEuZnJhbWVzLmxlbmd0aCAtIDE7XG4gIH1cblxuICB1cGRhdGUodG90YWxXZWlnaHQgPSAxLCBpc1NldCkge1xuICAgIGNvbnN0IHdlaWdodCA9IGlzU2V0ID8gMSA6IHRoaXMud2VpZ2h0IC8gdG90YWxXZWlnaHQ7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuZWxhcHNlZCAlIHRoaXMuZHVyYXRpb247XG4gICAgY29uc3QgZmxvb3JGcmFtZSA9IE1hdGguZmxvb3IoZWxhcHNlZCk7XG4gICAgY29uc3QgYmxlbmQgPSBlbGFwc2VkIC0gZmxvb3JGcmFtZTtcbiAgICBjb25zdCBwcmV2S2V5ID0gdGhpcy5kYXRhLmZyYW1lc1tmbG9vckZyYW1lXTtcbiAgICBjb25zdCBuZXh0S2V5ID0gdGhpcy5kYXRhLmZyYW1lc1soZmxvb3JGcmFtZSArIDEpICUgdGhpcy5kdXJhdGlvbl07XG4gICAgdGhpcy5vYmplY3RzLmZvckVhY2goKG9iamVjdCwgaSkgPT4ge1xuICAgICAgcHJldlBvcy5mcm9tQXJyYXkocHJldktleS5wb3NpdGlvbiwgaSAqIDMpO1xuICAgICAgcHJldlJvdC5mcm9tQXJyYXkocHJldktleS5xdWF0ZXJuaW9uLCBpICogNCk7XG4gICAgICBwcmV2U2NsLmZyb21BcnJheShwcmV2S2V5LnNjYWxlLCBpICogMyk7XG4gICAgICBuZXh0UG9zLmZyb21BcnJheShuZXh0S2V5LnBvc2l0aW9uLCBpICogMyk7XG4gICAgICBuZXh0Um90LmZyb21BcnJheShuZXh0S2V5LnF1YXRlcm5pb24sIGkgKiA0KTtcbiAgICAgIG5leHRTY2wuZnJvbUFycmF5KG5leHRLZXkuc2NhbGUsIGkgKiAzKTtcbiAgICAgIHByZXZQb3MubGVycChuZXh0UG9zLCBibGVuZCk7XG4gICAgICBwcmV2Um90LnNsZXJwKG5leHRSb3QsIGJsZW5kKTtcbiAgICAgIHByZXZTY2wubGVycChuZXh0U2NsLCBibGVuZCk7XG4gICAgICBvYmplY3QucG9zaXRpb24ubGVycChwcmV2UG9zLCB3ZWlnaHQpO1xuICAgICAgb2JqZWN0LnF1YXRlcm5pb24uc2xlcnAocHJldlJvdCwgd2VpZ2h0KTtcbiAgICAgIG9iamVjdC5zY2FsZS5sZXJwKHByZXZTY2wsIHdlaWdodCk7XG4gICAgfSk7XG4gIH1cblxufSIsImltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9jb3JlL01lc2guanMnO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnLi4vY29yZS9UcmFuc2Zvcm0uanMnO1xuaW1wb3J0IHsgTWF0NCB9IGZyb20gJy4uL21hdGgvTWF0NC5qcyc7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vY29yZS9UZXh0dXJlLmpzJztcbmltcG9ydCB7IEFuaW1hdGlvbiB9IGZyb20gJy4vQW5pbWF0aW9uLmpzJztcbmNvbnN0IHRlbXBNYXQ0ID0gbmV3IE1hdDQoKTtcbmV4cG9ydCBjbGFzcyBTa2luIGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgcmlnLFxuICAgIGdlb21ldHJ5LFxuICAgIHByb2dyYW0sXG4gICAgbW9kZSA9IGdsLlRSSUFOR0xFU1xuICB9ID0ge30pIHtcbiAgICBzdXBlcihnbCwge1xuICAgICAgZ2VvbWV0cnksXG4gICAgICBwcm9ncmFtLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICAgIHRoaXMuY3JlYXRlQm9uZXMocmlnKTtcbiAgICB0aGlzLmNyZWF0ZUJvbmVUZXh0dXJlKCk7XG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnByb2dyYW0udW5pZm9ybXMsIHtcbiAgICAgIGJvbmVUZXh0dXJlOiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmJvbmVUZXh0dXJlXG4gICAgICB9LFxuICAgICAgYm9uZVRleHR1cmVTaXplOiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmJvbmVUZXh0dXJlU2l6ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlQm9uZXMocmlnKSB7XG4gICAgLy8gQ3JlYXRlIHJvb3Qgc28gdGhhdCBjYW4gc2ltcGx5IHVwZGF0ZSB3b3JsZCBtYXRyaXggb2Ygd2hvbGUgc2tlbGV0b25cbiAgICB0aGlzLnJvb3QgPSBuZXcgVHJhbnNmb3JtKCk7IC8vIENyZWF0ZSBib25lc1xuXG4gICAgdGhpcy5ib25lcyA9IFtdO1xuICAgIGlmICghcmlnLmJvbmVzIHx8ICFyaWcuYm9uZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJpZy5ib25lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYm9uZSA9IG5ldyBUcmFuc2Zvcm0oKTsgLy8gU2V0IGluaXRpYWwgdmFsdWVzIChiaW5kIHBvc2UpXG5cbiAgICAgIGJvbmUucG9zaXRpb24uZnJvbUFycmF5KHJpZy5iaW5kUG9zZS5wb3NpdGlvbiwgaSAqIDMpO1xuICAgICAgYm9uZS5xdWF0ZXJuaW9uLmZyb21BcnJheShyaWcuYmluZFBvc2UucXVhdGVybmlvbiwgaSAqIDQpO1xuICAgICAgYm9uZS5zY2FsZS5mcm9tQXJyYXkocmlnLmJpbmRQb3NlLnNjYWxlLCBpICogMyk7XG4gICAgICB0aGlzLmJvbmVzLnB1c2goYm9uZSk7XG4gICAgfSAvLyBPbmNlIGNyZWF0ZWQsIHNldCB0aGUgaGllcmFyY2h5XG5cblxuICAgIHJpZy5ib25lcy5mb3JFYWNoKChkYXRhLCBpKSA9PiB7XG4gICAgICB0aGlzLmJvbmVzW2ldLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICBpZiAoZGF0YS5wYXJlbnQgPT09IC0xKSByZXR1cm4gdGhpcy5ib25lc1tpXS5zZXRQYXJlbnQodGhpcy5yb290KTtcbiAgICAgIHRoaXMuYm9uZXNbaV0uc2V0UGFyZW50KHRoaXMuYm9uZXNbZGF0YS5wYXJlbnRdKTtcbiAgICB9KTsgLy8gVGhlbiB1cGRhdGUgdG8gY2FsY3VsYXRlIHdvcmxkIG1hdHJpY2VzXG5cbiAgICB0aGlzLnJvb3QudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7IC8vIFN0b3JlIGludmVyc2Ugb2YgYmluZCBwb3NlIHRvIGNhbGN1bGF0ZSBkaWZmZXJlbmNlc1xuXG4gICAgdGhpcy5ib25lcy5mb3JFYWNoKGJvbmUgPT4ge1xuICAgICAgYm9uZS5iaW5kSW52ZXJzZSA9IG5ldyBNYXQ0KC4uLmJvbmUud29ybGRNYXRyaXgpLmludmVyc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNyZWF0ZUJvbmVUZXh0dXJlKCkge1xuICAgIGlmICghdGhpcy5ib25lcy5sZW5ndGgpIHJldHVybjtcbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgoNCwgTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKE1hdGguc3FydCh0aGlzLmJvbmVzLmxlbmd0aCAqIDQpKSAvIE1hdGguTE4yKSkpO1xuICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogc2l6ZSAqIDQpO1xuICAgIHRoaXMuYm9uZVRleHR1cmVTaXplID0gc2l6ZTtcbiAgICB0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwge1xuICAgICAgaW1hZ2U6IHRoaXMuYm9uZU1hdHJpY2VzLFxuICAgICAgZ2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcbiAgICAgIHR5cGU6IHRoaXMuZ2wuRkxPQVQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nbC5yZW5kZXJlci5pc1dlYmdsMiA/IHRoaXMuZ2wuUkdCQTE2RiA6IHRoaXMuZ2wuUkdCQSxcbiAgICAgIGZsaXBZOiBmYWxzZSxcbiAgICAgIHdpZHRoOiBzaXplXG4gICAgfSk7XG4gIH1cblxuICBhZGRBbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgICAgb2JqZWN0czogdGhpcy5ib25lcyxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICB0aGlzLmFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgLy8gQ2FsY3VsYXRlIGNvbWJpbmVkIGFuaW1hdGlvbiB3ZWlnaHRcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKGFuaW1hdGlvbiA9PiB0b3RhbCArPSBhbmltYXRpb24ud2VpZ2h0KTtcbiAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uLCBpKSA9PiB7XG4gICAgICAvLyBmb3JjZSBmaXJzdCBhbmltYXRpb24gdG8gc2V0IGluIG9yZGVyIHRvIHJlc2V0IGZyYW1lXG4gICAgICBhbmltYXRpb24udXBkYXRlKHRvdGFsLCBpID09PSAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoe1xuICAgIGNhbWVyYVxuICB9ID0ge30pIHtcbiAgICAvLyBVcGRhdGUgd29ybGQgbWF0cmljZXMgbWFudWFsbHksIGFzIG5vdCBwYXJ0IG9mIHNjZW5lIGdyYXBoXG4gICAgdGhpcy5yb290LnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpOyAvLyBVcGRhdGUgYm9uZSB0ZXh0dXJlXG5cbiAgICB0aGlzLmJvbmVzLmZvckVhY2goKGJvbmUsIGkpID0+IHtcbiAgICAgIC8vIEZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIGJpbmQgcG9zZVxuICAgICAgdGVtcE1hdDQubXVsdGlwbHkoYm9uZS53b3JsZE1hdHJpeCwgYm9uZS5iaW5kSW52ZXJzZSk7XG4gICAgICB0aGlzLmJvbmVNYXRyaWNlcy5zZXQodGVtcE1hdDQsIGkgKiAxNik7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuYm9uZVRleHR1cmUpIHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHN1cGVyLmRyYXcoe1xuICAgICAgY2FtZXJhXG4gICAgfSk7XG4gIH1cblxufSIsImV4cG9ydCBmdW5jdGlvbiBUZXh0KHtcbiAgZm9udCxcbiAgdGV4dCxcbiAgd2lkdGggPSBJbmZpbml0eSxcbiAgYWxpZ24gPSAnbGVmdCcsXG4gIHNpemUgPSAxLFxuICBsZXR0ZXJTcGFjaW5nID0gMCxcbiAgbGluZUhlaWdodCA9IDEuNCxcbiAgd29yZFNwYWNpbmcgPSAwLFxuICB3b3JkQnJlYWsgPSBmYWxzZVxufSkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgbGV0IGdseXBocywgYnVmZmVycztcbiAgbGV0IGZvbnRIZWlnaHQsIGJhc2VsaW5lLCBzY2FsZTtcbiAgY29uc3QgbmV3bGluZSA9IC9cXG4vO1xuICBjb25zdCB3aGl0ZXNwYWNlID0gL1xccy87XG4gIHtcbiAgICBwYXJzZUZvbnQoKTtcbiAgICBjcmVhdGVHZW9tZXRyeSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGb250KCkge1xuICAgIGdseXBocyA9IHt9O1xuICAgIGZvbnQuY2hhcnMuZm9yRWFjaChkID0+IGdseXBoc1tkLmNoYXJdID0gZCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVHZW9tZXRyeSgpIHtcbiAgICBmb250SGVpZ2h0ID0gZm9udC5jb21tb24ubGluZUhlaWdodDtcbiAgICBiYXNlbGluZSA9IGZvbnQuY29tbW9uLmJhc2U7IC8vIFVzZSBiYXNlbGluZSBzbyB0aGF0IGFjdHVhbCB0ZXh0IGhlaWdodCBpcyBhcyBjbG9zZSB0byAnc2l6ZScgdmFsdWUgYXMgcG9zc2libGVcblxuICAgIHNjYWxlID0gc2l6ZSAvIGJhc2VsaW5lOyAvLyBTdHJpcCBzcGFjZXMgYW5kIG5ld2xpbmVzIHRvIGdldCBhY3R1YWwgY2hhcmFjdGVyIGxlbmd0aCBmb3IgYnVmZmVyc1xuXG4gICAgbGV0IGNoYXJzID0gdGV4dC5yZXBsYWNlKC9bIFxcbl0vZywgJycpO1xuICAgIGxldCBudW1DaGFycyA9IGNoYXJzLmxlbmd0aDsgLy8gQ3JlYXRlIG91dHB1dCBidWZmZXJzXG5cbiAgICBidWZmZXJzID0ge1xuICAgICAgcG9zaXRpb246IG5ldyBGbG9hdDMyQXJyYXkobnVtQ2hhcnMgKiA0ICogMyksXG4gICAgICB1djogbmV3IEZsb2F0MzJBcnJheShudW1DaGFycyAqIDQgKiAyKSxcbiAgICAgIGlkOiBuZXcgRmxvYXQzMkFycmF5KG51bUNoYXJzICogNCksXG4gICAgICBpbmRleDogbmV3IFVpbnQxNkFycmF5KG51bUNoYXJzICogNilcbiAgICB9OyAvLyBTZXQgdmFsdWVzIGZvciBidWZmZXJzIHRoYXQgZG9uJ3QgcmVxdWlyZSBjYWxjdWxhdGlvblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaGFyczsgaSsrKSB7XG4gICAgICBidWZmZXJzLmlkW2ldID0gaTtcbiAgICAgIGJ1ZmZlcnMuaW5kZXguc2V0KFtpICogNCwgaSAqIDQgKyAyLCBpICogNCArIDEsIGkgKiA0ICsgMSwgaSAqIDQgKyAyLCBpICogNCArIDNdLCBpICogNik7XG4gICAgfVxuXG4gICAgbGF5b3V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBsYXlvdXQoKSB7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBsZXQgY3Vyc29yID0gMDtcbiAgICBsZXQgd29yZEN1cnNvciA9IDA7XG4gICAgbGV0IHdvcmRXaWR0aCA9IDA7XG4gICAgbGV0IGxpbmUgPSBuZXdMaW5lKCk7XG5cbiAgICBmdW5jdGlvbiBuZXdMaW5lKCkge1xuICAgICAgY29uc3QgbGluZSA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGdseXBoczogW11cbiAgICAgIH07XG4gICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgd29yZEN1cnNvciA9IGN1cnNvcjtcbiAgICAgIHdvcmRXaWR0aCA9IDA7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICBsZXQgbWF4VGltZXMgPSAxMDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIHdoaWxlIChjdXJzb3IgPCB0ZXh0Lmxlbmd0aCAmJiBjb3VudCA8IG1heFRpbWVzKSB7XG4gICAgICBjb3VudCsrO1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbY3Vyc29yXTsgLy8gU2tpcCB3aGl0ZXNwYWNlIGF0IHN0YXJ0IG9mIGxpbmVcblxuICAgICAgaWYgKCFsaW5lLndpZHRoICYmIHdoaXRlc3BhY2UudGVzdChjaGFyKSkge1xuICAgICAgICBjdXJzb3IrKztcbiAgICAgICAgd29yZEN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgd29yZFdpZHRoID0gMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIG5ld2xpbmUgY2hhciwgc2tpcCB0byBuZXh0IGxpbmVcblxuXG4gICAgICBpZiAobmV3bGluZS50ZXN0KGNoYXIpKSB7XG4gICAgICAgIGN1cnNvcisrO1xuICAgICAgICBsaW5lID0gbmV3TGluZSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHNbY2hhcl07IC8vIEZpbmQgYW55IGFwcGxpY2FibGUga2VybiBwYWlyc1xuXG4gICAgICBpZiAobGluZS5nbHlwaHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHByZXZHbHlwaCA9IGxpbmUuZ2x5cGhzW2xpbmUuZ2x5cGhzLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICBsZXQga2VybiA9IGdldEtlcm5QYWlyT2Zmc2V0KGdseXBoLmlkLCBwcmV2R2x5cGguaWQpICogc2NhbGU7XG4gICAgICAgIGxpbmUud2lkdGggKz0ga2VybjtcbiAgICAgICAgd29yZFdpZHRoICs9IGtlcm47XG4gICAgICB9IC8vIGFkZCBjaGFyIHRvIGxpbmVcblxuXG4gICAgICBsaW5lLmdseXBocy5wdXNoKFtnbHlwaCwgbGluZS53aWR0aF0pOyAvLyBjYWxjdWxhdGUgYWR2YW5jZSBmb3IgbmV4dCBnbHlwaFxuXG4gICAgICBsZXQgYWR2YW5jZSA9IDA7IC8vIElmIHdoaXRlc3BhY2UsIHVwZGF0ZSBsb2NhdGlvbiBvZiBjdXJyZW50IHdvcmQgZm9yIGxpbmUgYnJlYWtzXG5cbiAgICAgIGlmICh3aGl0ZXNwYWNlLnRlc3QoY2hhcikpIHtcbiAgICAgICAgd29yZEN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgd29yZFdpZHRoID0gMDsgLy8gQWRkIHdvcmRzcGFjaW5nXG5cbiAgICAgICAgYWR2YW5jZSArPSB3b3JkU3BhY2luZyAqIHNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgbGV0dGVyc3BhY2luZ1xuICAgICAgICBhZHZhbmNlICs9IGxldHRlclNwYWNpbmcgKiBzaXplO1xuICAgICAgfVxuXG4gICAgICBhZHZhbmNlICs9IGdseXBoLnhhZHZhbmNlICogc2NhbGU7XG4gICAgICBsaW5lLndpZHRoICs9IGFkdmFuY2U7XG4gICAgICB3b3JkV2lkdGggKz0gYWR2YW5jZTsgLy8gSWYgd2lkdGggZGVmaW5lZFxuXG4gICAgICBpZiAobGluZS53aWR0aCA+IHdpZHRoKSB7XG4gICAgICAgIC8vIElmIGNhbiBicmVhayB3b3JkcywgdW5kbyBsYXRlc3QgZ2x5cGggaWYgbGluZSBub3QgZW1wdHkgYW5kIGNyZWF0ZSBuZXcgbGluZVxuICAgICAgICBpZiAod29yZEJyZWFrICYmIGxpbmUuZ2x5cGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBsaW5lLndpZHRoIC09IGFkdmFuY2U7XG4gICAgICAgICAgbGluZS5nbHlwaHMucG9wKCk7XG4gICAgICAgICAgbGluZSA9IG5ld0xpbmUoKTtcbiAgICAgICAgICBjb250aW51ZTsgLy8gSWYgbm90IGZpcnN0IHdvcmQsIHVuZG8gY3VycmVudCB3b3JkIGFuZCBjdXJzb3IgYW5kIGNyZWF0ZSBuZXcgbGluZVxuICAgICAgICB9IGVsc2UgaWYgKCF3b3JkQnJlYWsgJiYgd29yZFdpZHRoICE9PSBsaW5lLndpZHRoKSB7XG4gICAgICAgICAgbGV0IG51bUdseXBocyA9IGN1cnNvciAtIHdvcmRDdXJzb3IgKyAxO1xuICAgICAgICAgIGxpbmUuZ2x5cGhzLnNwbGljZSgtbnVtR2x5cGhzLCBudW1HbHlwaHMpO1xuICAgICAgICAgIGN1cnNvciA9IHdvcmRDdXJzb3I7XG4gICAgICAgICAgbGluZS53aWR0aCAtPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZSA9IG5ld0xpbmUoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJzb3IrKztcbiAgICB9IC8vIFJlbW92ZSBsYXN0IGxpbmUgaWYgZW1wdHlcblxuXG4gICAgaWYgKCFsaW5lLndpZHRoKSBsaW5lcy5wb3AoKTtcbiAgICBwb3B1bGF0ZUJ1ZmZlcnMobGluZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wdWxhdGVCdWZmZXJzKGxpbmVzKSB7XG4gICAgY29uc3QgdGV4VyA9IGZvbnQuY29tbW9uLnNjYWxlVztcbiAgICBjb25zdCB0ZXhIID0gZm9udC5jb21tb24uc2NhbGVIOyAvLyBGb3IgYWxsIGZvbnRzIHRlc3RlZCwgYSBsaXR0bGUgb2Zmc2V0IHdhcyBuZWVkZWQgdG8gYmUgcmlnaHQgb24gdGhlIGJhc2VsaW5lLCBoZW5jZSAwLjA3LlxuXG4gICAgbGV0IHkgPSAwLjA3ICogc2l6ZTtcbiAgICBsZXQgaiA9IDA7XG5cbiAgICBmb3IgKGxldCBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCBsaW5lcy5sZW5ndGg7IGxpbmVJbmRleCsrKSB7XG4gICAgICBsZXQgbGluZSA9IGxpbmVzW2xpbmVJbmRleF07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5nbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ2x5cGggPSBsaW5lLmdseXBoc1tpXVswXTtcbiAgICAgICAgbGV0IHggPSBsaW5lLmdseXBoc1tpXVsxXTtcblxuICAgICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgeCAtPSBsaW5lLndpZHRoICogMC41O1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgeCAtPSBsaW5lLndpZHRoO1xuICAgICAgICB9IC8vIElmIHNwYWNlLCBkb24ndCBhZGQgdG8gZ2VvbWV0cnlcblxuXG4gICAgICAgIGlmICh3aGl0ZXNwYWNlLnRlc3QoZ2x5cGguY2hhcikpIGNvbnRpbnVlOyAvLyBBcHBseSBjaGFyIHNwcml0ZSBvZmZzZXRzXG5cbiAgICAgICAgeCArPSBnbHlwaC54b2Zmc2V0ICogc2NhbGU7XG4gICAgICAgIHkgLT0gZ2x5cGgueW9mZnNldCAqIHNjYWxlOyAvLyBlYWNoIGxldHRlciBpcyBhIHF1YWQuIGF4aXMgYm90dG9tIGxlZnRcblxuICAgICAgICBsZXQgdyA9IGdseXBoLndpZHRoICogc2NhbGU7XG4gICAgICAgIGxldCBoID0gZ2x5cGguaGVpZ2h0ICogc2NhbGU7XG4gICAgICAgIGJ1ZmZlcnMucG9zaXRpb24uc2V0KFt4LCB5IC0gaCwgMCwgeCwgeSwgMCwgeCArIHcsIHkgLSBoLCAwLCB4ICsgdywgeSwgMF0sIGogKiA0ICogMyk7XG4gICAgICAgIGxldCB1ID0gZ2x5cGgueCAvIHRleFc7XG4gICAgICAgIGxldCB1dyA9IGdseXBoLndpZHRoIC8gdGV4VztcbiAgICAgICAgbGV0IHYgPSAxLjAgLSBnbHlwaC55IC8gdGV4SDtcbiAgICAgICAgbGV0IHZoID0gZ2x5cGguaGVpZ2h0IC8gdGV4SDtcbiAgICAgICAgYnVmZmVycy51di5zZXQoW3UsIHYgLSB2aCwgdSwgdiwgdSArIHV3LCB2IC0gdmgsIHUgKyB1dywgdl0sIGogKiA0ICogMik7IC8vIFJlc2V0IGN1cnNvciB0byBiYXNlbGluZVxuXG4gICAgICAgIHkgKz0gZ2x5cGgueW9mZnNldCAqIHNjYWxlO1xuICAgICAgICBqKys7XG4gICAgICB9XG5cbiAgICAgIHkgLT0gc2l6ZSAqIGxpbmVIZWlnaHQ7XG4gICAgfVxuXG4gICAgX3RoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XG4gICAgX3RoaXMubnVtTGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgX3RoaXMuaGVpZ2h0ID0gX3RoaXMubnVtTGluZXMgKiBzaXplICogbGluZUhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtlcm5QYWlyT2Zmc2V0KGlkMSwgaWQyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb250Lmtlcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgayA9IGZvbnQua2VybmluZ3NbaV07XG4gICAgICBpZiAoay5maXJzdCA8IGlkMSkgY29udGludWU7XG4gICAgICBpZiAoay5zZWNvbmQgPCBpZDIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGsuZmlyc3QgPiBpZDEpIHJldHVybiAwO1xuICAgICAgaWYgKGsuZmlyc3QgPT09IGlkMSAmJiBrLnNlY29uZCA+IGlkMikgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gay5hbW91bnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gVXBkYXRlIGJ1ZmZlcnMgdG8gbGF5b3V0IHdpdGggbmV3IGxheW91dFxuXG5cbiAgdGhpcy5yZXNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICh7XG4gICAgICB3aWR0aFxuICAgIH0gPSBvcHRpb25zKTtcbiAgICBsYXlvdXQoKTtcbiAgfTsgLy8gQ29tcGxldGVseSBjaGFuZ2UgdGV4dCAobGlrZSBjcmVhdGluZyBuZXcgVGV4dClcblxuXG4gIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAoe1xuICAgICAgdGV4dFxuICAgIH0gPSBvcHRpb25zKTtcbiAgICBjcmVhdGVHZW9tZXRyeSgpO1xuICB9O1xufSIsImltcG9ydCB7IFByb2dyYW0gfSBmcm9tICcuLi9jb3JlL1Byb2dyYW0uanMnO1xuY29uc3QgdmVydGV4ID1cbi8qIGdsc2wgKi9cbmBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcblxuICAgIGF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcblxuICAgIHVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XG4gICAgdW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcbiAgICB1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2Tm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbE1hdHJpeCAqIG5vcm1hbCk7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgfVxuYDtcbmNvbnN0IGZyYWdtZW50ID1cbi8qIGdsc2wgKi9cbmBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcblxuICAgIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IucmdiID0gbm9ybWFsaXplKHZOb3JtYWwpO1xuICAgICAgICBnbF9GcmFnQ29sb3IuYSA9IDEuMDtcbiAgICB9XG5gO1xuZXhwb3J0IGZ1bmN0aW9uIE5vcm1hbFByb2dyYW0oZ2wpIHtcbiAgcmV0dXJuIG5ldyBQcm9ncmFtKGdsLCB7XG4gICAgdmVydGV4OiB2ZXJ0ZXgsXG4gICAgZnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgIGN1bGxGYWNlOiBudWxsXG4gIH0pO1xufSIsImltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4uL2NvcmUvUmVuZGVyVGFyZ2V0LmpzJztcbmltcG9ydCB7IFByb2dyYW0gfSBmcm9tICcuLi9jb3JlL1Byb2dyYW0uanMnO1xuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL2NvcmUvTWVzaC5qcyc7XG5pbXBvcnQgeyBWZWMyIH0gZnJvbSAnLi4vbWF0aC9WZWMyLmpzJztcbmltcG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi9UcmlhbmdsZS5qcyc7XG5leHBvcnQgY2xhc3MgRmxvd21hcCB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgc2l6ZSA9IDEyOCxcbiAgICAvLyBkZWZhdWx0IHNpemUgb2YgdGhlIHJlbmRlciB0YXJnZXRzXG4gICAgZmFsbG9mZiA9IDAuMyxcbiAgICAvLyBzaXplIG9mIHRoZSBzdGFtcCwgcGVyY2VudGFnZSBvZiB0aGUgc2l6ZVxuICAgIGFscGhhID0gMSxcbiAgICAvLyBvcGFjaXR5IG9mIHRoZSBzdGFtcFxuICAgIGRpc3NpcGF0aW9uID0gMC45OCxcbiAgICAvLyBhZmZlY3RzIHRoZSBzcGVlZCB0aGF0IHRoZSBzdGFtcCBmYWRlcy4gQ2xvc2VyIHRvIDEgaXMgc2xvd2VyXG4gICAgdHlwZSAvLyBQYXNzIGluIGdsLkZMT0FUIHRvIGZvcmNlIGl0LCBkZWZhdWx0cyB0byBnbC5IQUxGX0ZMT0FUXG5cbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5nbCA9IGdsOyAvLyBvdXRwdXQgdW5pZm9ybSBjb250YWluaW5nIHJlbmRlciB0YXJnZXQgdGV4dHVyZXNcblxuICAgIHRoaXMudW5pZm9ybSA9IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm1hc2sgPSB7XG4gICAgICByZWFkOiBudWxsLFxuICAgICAgd3JpdGU6IG51bGwsXG4gICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGluZyBwb25nIHRoZSByZW5kZXIgdGFyZ2V0cyBhbmQgdXBkYXRlIHRoZSB1bmlmb3JtXG4gICAgICBzd2FwOiAoKSA9PiB7XG4gICAgICAgIGxldCB0ZW1wID0gX3RoaXMubWFzay5yZWFkO1xuICAgICAgICBfdGhpcy5tYXNrLnJlYWQgPSBfdGhpcy5tYXNrLndyaXRlO1xuICAgICAgICBfdGhpcy5tYXNrLndyaXRlID0gdGVtcDtcbiAgICAgICAgX3RoaXMudW5pZm9ybS52YWx1ZSA9IF90aGlzLm1hc2sucmVhZC50ZXh0dXJlO1xuICAgICAgfVxuICAgIH07XG4gICAge1xuICAgICAgY3JlYXRlRkJPcygpO1xuICAgICAgdGhpcy5hc3BlY3QgPSAxO1xuICAgICAgdGhpcy5tb3VzZSA9IG5ldyBWZWMyKCk7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlYzIoKTtcbiAgICAgIHRoaXMubWVzaCA9IGluaXRQcm9ncmFtKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRkJPcygpIHtcbiAgICAgIC8vIFJlcXVlc3RlZCB0eXBlIG5vdCBzdXBwb3J0ZWQsIGZhbGwgYmFjayB0byBoYWxmIGZsb2F0XG4gICAgICBpZiAoIXR5cGUpIHR5cGUgPSBnbC5IQUxGX0ZMT0FUIHx8IGdsLnJlbmRlcmVyLmV4dGVuc2lvbnNbJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnXS5IQUxGX0ZMT0FUX09FUztcblxuICAgICAgbGV0IG1pbkZpbHRlciA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChnbC5yZW5kZXJlci5pc1dlYmdsMikgcmV0dXJuIGdsLkxJTkVBUjtcbiAgICAgICAgaWYgKGdsLnJlbmRlcmVyLmV4dGVuc2lvbnNbYE9FU190ZXh0dXJlXyR7dHlwZSA9PT0gZ2wuRkxPQVQgPyAnJyA6ICdoYWxmXyd9ZmxvYXRfbGluZWFyYF0pIHJldHVybiBnbC5MSU5FQVI7XG4gICAgICAgIHJldHVybiBnbC5ORUFSRVNUO1xuICAgICAgfSkoKTtcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZm9ybWF0OiBnbC5SR0JBLFxuICAgICAgICBpbnRlcm5hbEZvcm1hdDogZ2wucmVuZGVyZXIuaXNXZWJnbDIgPyB0eXBlID09PSBnbC5GTE9BVCA/IGdsLlJHQkEzMkYgOiBnbC5SR0JBMTZGIDogZ2wuUkdCQSxcbiAgICAgICAgbWluRmlsdGVyLFxuICAgICAgICBkZXB0aDogZmFsc2VcbiAgICAgIH07XG4gICAgICBfdGhpcy5tYXNrLnJlYWQgPSBuZXcgUmVuZGVyVGFyZ2V0KGdsLCBvcHRpb25zKTtcbiAgICAgIF90aGlzLm1hc2sud3JpdGUgPSBuZXcgUmVuZGVyVGFyZ2V0KGdsLCBvcHRpb25zKTtcblxuICAgICAgX3RoaXMubWFzay5zd2FwKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdFByb2dyYW0oKSB7XG4gICAgICByZXR1cm4gbmV3IE1lc2goZ2wsIHtcbiAgICAgICAgLy8gVHJpYW5nbGUgdGhhdCBpbmNsdWRlcyAtMSB0byAxIHJhbmdlIGZvciAncG9zaXRpb24nLCBhbmQgMCB0byAxIHJhbmdlIGZvciAndXYnLlxuICAgICAgICBnZW9tZXRyeTogbmV3IFRyaWFuZ2xlKGdsKSxcbiAgICAgICAgcHJvZ3JhbTogbmV3IFByb2dyYW0oZ2wsIHtcbiAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIHRNYXA6IF90aGlzLnVuaWZvcm0sXG4gICAgICAgICAgICB1RmFsbG9mZjoge1xuICAgICAgICAgICAgICB2YWx1ZTogZmFsbG9mZiAqIDAuNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVBbHBoYToge1xuICAgICAgICAgICAgICB2YWx1ZTogYWxwaGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RGlzc2lwYXRpb246IHtcbiAgICAgICAgICAgICAgdmFsdWU6IGRpc3NpcGF0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVXNlciBuZWVkcyB0byB1cGRhdGUgdGhlc2VcbiAgICAgICAgICAgIHVBc3BlY3Q6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1TW91c2U6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLm1vdXNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdVZlbG9jaXR5OiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy52ZWxvY2l0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVwdGhUZXN0OiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMubWVzaC5wcm9ncmFtLnVuaWZvcm1zLnVBc3BlY3QudmFsdWUgPSB0aGlzLmFzcGVjdDtcbiAgICB0aGlzLmdsLnJlbmRlcmVyLnJlbmRlcih7XG4gICAgICBzY2VuZTogdGhpcy5tZXNoLFxuICAgICAgdGFyZ2V0OiB0aGlzLm1hc2sud3JpdGUsXG4gICAgICBjbGVhcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLm1hc2suc3dhcCgpO1xuICB9XG5cbn1cbmNvbnN0IHZlcnRleCA9XG4vKiBnbHNsICovXG5gXG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XG4gICAgYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2VXYgPSB1djtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcbiAgICB9XG5gO1xuY29uc3QgZnJhZ21lbnQgPVxuLyogZ2xzbCAqL1xuYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRNYXA7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHVGYWxsb2ZmO1xuICAgIHVuaWZvcm0gZmxvYXQgdUFscGhhO1xuICAgIHVuaWZvcm0gZmxvYXQgdURpc3NpcGF0aW9uO1xuICAgIFxuICAgIHVuaWZvcm0gZmxvYXQgdUFzcGVjdDtcbiAgICB1bmlmb3JtIHZlYzIgdU1vdXNlO1xuICAgIHVuaWZvcm0gdmVjMiB1VmVsb2NpdHk7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHRNYXAsIHZVdikgKiB1RGlzc2lwYXRpb247XG5cbiAgICAgICAgdmVjMiBjdXJzb3IgPSB2VXYgLSB1TW91c2U7XG4gICAgICAgIGN1cnNvci54ICo9IHVBc3BlY3Q7XG5cbiAgICAgICAgdmVjMyBzdGFtcCA9IHZlYzModVZlbG9jaXR5ICogdmVjMigxLCAtMSksIDEuMCAtIHBvdygxLjAgLSBtaW4oMS4wLCBsZW5ndGgodVZlbG9jaXR5KSksIDMuMCkpO1xuICAgICAgICBmbG9hdCBmYWxsb2ZmID0gc21vb3Roc3RlcCh1RmFsbG9mZiwgMC4wLCBsZW5ndGgoY3Vyc29yKSkgKiB1QWxwaGE7XG5cbiAgICAgICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgc3RhbXAsIHZlYzMoZmFsbG9mZikpO1xuXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgIH1cbmA7IiwiaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gJy4uL2NvcmUvUHJvZ3JhbS5qcyc7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vY29yZS9NZXNoLmpzJztcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi9jb3JlL1RleHR1cmUuanMnO1xuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xuaW1wb3J0IHsgVHJpYW5nbGUgfSBmcm9tICcuL1RyaWFuZ2xlLmpzJztcbmV4cG9ydCBjbGFzcyBHUEdQVSB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgLy8gQWx3YXlzIHBhc3MgaW4gYXJyYXkgb2YgdmVjNHMgKFJHQkEgdmFsdWVzIHdpdGhpbiB0ZXh0dXJlKVxuICAgIGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDE2KSxcbiAgICBnZW9tZXRyeSA9IG5ldyBUcmlhbmdsZShnbCksXG4gICAgdHlwZSAvLyBQYXNzIGluIGdsLkZMT0FUIHRvIGZvcmNlIGl0LCBkZWZhdWx0cyB0byBnbC5IQUxGX0ZMT0FUXG5cbiAgfSkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICBjb25zdCBpbml0aWFsRGF0YSA9IGRhdGE7XG4gICAgdGhpcy5wYXNzZXMgPSBbXTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gaW5pdGlhbERhdGEubGVuZ3RoIC8gNDsgLy8gV2luZG93cyBhbmQgaU9TIG9ubHkgbGlrZSBwb3dlciBvZiAyIHRleHR1cmVzXG4gICAgLy8gRmluZCBzbWFsbGVzdCBQTzIgdGhhdCBmaXRzIGRhdGFcblxuICAgIHRoaXMuc2l6ZSA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZyhNYXRoLmNlaWwoTWF0aC5zcXJ0KHRoaXMuZGF0YUxlbmd0aCkpKSAvIE1hdGguTE4yKSk7IC8vIENyZWF0ZSBjb29yZHMgZm9yIG91dHB1dCB0ZXh0dXJlXG5cbiAgICB0aGlzLmNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5kYXRhTGVuZ3RoICogMik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAlIHRoaXMuc2l6ZSAvIHRoaXMuc2l6ZTsgLy8gdG8gYWRkIDAuNSB0byBiZSBjZW50ZXIgcGl4ZWwgP1xuXG4gICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihpIC8gdGhpcy5zaXplKSAvIHRoaXMuc2l6ZTtcbiAgICAgIHRoaXMuY29vcmRzLnNldChbeCwgeV0sIGkgKiAyKTtcbiAgICB9IC8vIFVzZSBvcmlnaW5hbCBkYXRhIGlmIGFscmVhZHkgY29ycmVjdCBsZW5ndGggb2YgUE8yIHRleHR1cmUsIGVsc2UgY29weSB0byBuZXcgYXJyYXkgb2YgY29ycmVjdCBsZW5ndGhcblxuXG4gICAgY29uc3QgZmxvYXRBcnJheSA9ICgoKSA9PiB7XG4gICAgICBpZiAoaW5pdGlhbERhdGEubGVuZ3RoID09PSB0aGlzLnNpemUgKiB0aGlzLnNpemUgKiA0KSB7XG4gICAgICAgIHJldHVybiBpbml0aWFsRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZSAqIDQpO1xuICAgICAgICBhLnNldChpbml0aWFsRGF0YSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0pKCk7IC8vIENyZWF0ZSBvdXRwdXQgdGV4dHVyZSB1bmlmb3JtIHVzaW5nIGlucHV0IGZsb2F0IHRleHR1cmUgd2l0aCBpbml0aWFsIGRhdGFcblxuXG4gICAgdGhpcy51bmlmb3JtID0ge1xuICAgICAgdmFsdWU6IG5ldyBUZXh0dXJlKGdsLCB7XG4gICAgICAgIGltYWdlOiBmbG9hdEFycmF5LFxuICAgICAgICB0YXJnZXQ6IGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIHR5cGU6IGdsLkZMT0FULFxuICAgICAgICBmb3JtYXQ6IGdsLlJHQkEsXG4gICAgICAgIGludGVybmFsRm9ybWF0OiBnbC5yZW5kZXJlci5pc1dlYmdsMiA/IGdsLlJHQkEzMkYgOiBnbC5SR0JBLFxuICAgICAgICB3cmFwUzogZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgd3JhcFQ6IGdsLkNMQU1QX1RPX0VER0UsXG4gICAgICAgIGdlbmVyYXRlTWlwbWFwczogZmFsc2UsXG4gICAgICAgIG1pbkZpbHRlcjogZ2wuTkVBUkVTVCxcbiAgICAgICAgbWFnRmlsdGVyOiBnbC5ORUFSRVNULFxuICAgICAgICB3aWR0aDogdGhpcy5zaXplLFxuICAgICAgICBmbGlwWTogZmFsc2VcbiAgICAgIH0pXG4gICAgfTsgLy8gQ3JlYXRlIEZCT3NcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICB3aWR0aDogdGhpcy5zaXplLFxuICAgICAgaGVpZ2h0OiB0aGlzLnNpemUsXG4gICAgICB0eXBlOiB0eXBlIHx8IGdsLkhBTEZfRkxPQVQgfHwgZ2wucmVuZGVyZXIuZXh0ZW5zaW9uc1snT0VTX3RleHR1cmVfaGFsZl9mbG9hdCddLkhBTEZfRkxPQVRfT0VTLFxuICAgICAgZm9ybWF0OiBnbC5SR0JBLFxuICAgICAgaW50ZXJuYWxGb3JtYXQ6IGdsLnJlbmRlcmVyLmlzV2ViZ2wyID8gdHlwZSA9PT0gZ2wuRkxPQVQgPyBnbC5SR0JBMzJGIDogZ2wuUkdCQTE2RiA6IGdsLlJHQkEsXG4gICAgICBtaW5GaWx0ZXI6IGdsLk5FQVJFU1QsXG4gICAgICBkZXB0aDogZmFsc2UsXG4gICAgICB1bnBhY2tBbGlnbm1lbnQ6IDFcbiAgICB9O1xuICAgIHRoaXMuZmJvID0ge1xuICAgICAgcmVhZDogbmV3IFJlbmRlclRhcmdldChnbCwgb3B0aW9ucyksXG4gICAgICB3cml0ZTogbmV3IFJlbmRlclRhcmdldChnbCwgb3B0aW9ucyksXG4gICAgICBzd2FwOiAoKSA9PiB7XG4gICAgICAgIGxldCB0ZW1wID0gdGhpcy5mYm8ucmVhZDtcbiAgICAgICAgdGhpcy5mYm8ucmVhZCA9IHRoaXMuZmJvLndyaXRlO1xuICAgICAgICB0aGlzLmZiby53cml0ZSA9IHRlbXA7XG4gICAgICAgIHRoaXMudW5pZm9ybS52YWx1ZSA9IHRoaXMuZmJvLnJlYWQudGV4dHVyZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgYWRkUGFzcyh7XG4gICAgdmVydGV4ID0gZGVmYXVsdFZlcnRleCxcbiAgICBmcmFnbWVudCA9IGRlZmF1bHRGcmFnbWVudCxcbiAgICB1bmlmb3JtcyA9IHt9LFxuICAgIHRleHR1cmVVbmlmb3JtID0gJ3RNYXAnLFxuICAgIGVuYWJsZWQgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIHVuaWZvcm1zW3RleHR1cmVVbmlmb3JtXSA9IHRoaXMudW5pZm9ybTtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0odGhpcy5nbCwge1xuICAgICAgdmVydGV4LFxuICAgICAgZnJhZ21lbnQsXG4gICAgICB1bmlmb3Jtc1xuICAgIH0pO1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaCh0aGlzLmdsLCB7XG4gICAgICBnZW9tZXRyeTogdGhpcy5nZW9tZXRyeSxcbiAgICAgIHByb2dyYW1cbiAgICB9KTtcbiAgICBjb25zdCBwYXNzID0ge1xuICAgICAgbWVzaCxcbiAgICAgIHByb2dyYW0sXG4gICAgICB1bmlmb3JtcyxcbiAgICAgIGVuYWJsZWQsXG4gICAgICB0ZXh0dXJlVW5pZm9ybVxuICAgIH07XG4gICAgdGhpcy5wYXNzZXMucHVzaChwYXNzKTtcbiAgICByZXR1cm4gcGFzcztcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBlbmFibGVkUGFzc2VzID0gdGhpcy5wYXNzZXMuZmlsdGVyKHBhc3MgPT4gcGFzcy5lbmFibGVkKTtcbiAgICBlbmFibGVkUGFzc2VzLmZvckVhY2goKHBhc3MsIGkpID0+IHtcbiAgICAgIHRoaXMuZ2wucmVuZGVyZXIucmVuZGVyKHtcbiAgICAgICAgc2NlbmU6IHBhc3MubWVzaCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmZiby53cml0ZSxcbiAgICAgICAgY2xlYXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmJvLnN3YXAoKTtcbiAgICB9KTtcbiAgfVxuXG59XG5jb25zdCBkZWZhdWx0VmVydGV4ID1cbi8qIGdsc2wgKi9cbmBcbiAgICBhdHRyaWJ1dGUgdmVjMiB1djtcbiAgICBhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcblxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZVdiA9IHV2O1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpO1xuICAgIH1cbmA7XG5jb25zdCBkZWZhdWx0RnJhZ21lbnQgPVxuLyogZ2xzbCAqL1xuYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRNYXA7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRNYXAsIHZVdik7XG4gICAgfVxuYDsiLCJpbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gJy4uL2NvcmUvUHJvZ3JhbS5qcyc7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vY29yZS9NZXNoLmpzJztcbmltcG9ydCB7IFZlYzIgfSBmcm9tICcuLi9tYXRoL1ZlYzIuanMnO1xuaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4uL21hdGgvVmVjMy5qcyc7XG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xuY29uc3QgdG1wID0gbmV3IFZlYzMoKTtcbmV4cG9ydCBjbGFzcyBQb2x5bGluZSB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgcG9pbnRzLFxuICAgIC8vIEFycmF5IG9mIFZlYzNzXG4gICAgdmVydGV4ID0gZGVmYXVsdFZlcnRleCxcbiAgICBmcmFnbWVudCA9IGRlZmF1bHRGcmFnbWVudCxcbiAgICB1bmlmb3JtcyA9IHt9LFxuICAgIGF0dHJpYnV0ZXMgPSB7fSAvLyBGb3IgcGFzc2luZyBpbiBjdXN0b20gYXR0cmlic1xuXG4gIH0pIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy5jb3VudCA9IHBvaW50cy5sZW5ndGg7IC8vIENyZWF0ZSBidWZmZXJzXG5cbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNvdW50ICogMyAqIDIpO1xuICAgIHRoaXMucHJldiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jb3VudCAqIDMgKiAyKTtcbiAgICB0aGlzLm5leHQgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY291bnQgKiAzICogMik7XG4gICAgY29uc3Qgc2lkZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jb3VudCAqIDEgKiAyKTtcbiAgICBjb25zdCB1diA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jb3VudCAqIDIgKiAyKTtcbiAgICBjb25zdCBpbmRleCA9IG5ldyBVaW50MTZBcnJheSgodGhpcy5jb3VudCAtIDEpICogMyAqIDIpOyAvLyBTZXQgc3RhdGljIGJ1ZmZlcnNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSsrKSB7XG4gICAgICBzaWRlLnNldChbLTEsIDFdLCBpICogMik7XG4gICAgICBjb25zdCB2ID0gaSAvICh0aGlzLmNvdW50IC0gMSk7XG4gICAgICB1di5zZXQoWzAsIHYsIDEsIHZdLCBpICogNCk7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5jb3VudCAtIDEpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgaW5kID0gaSAqIDI7XG4gICAgICBpbmRleC5zZXQoW2luZCArIDAsIGluZCArIDEsIGluZCArIDJdLCAoaW5kICsgMCkgKiAzKTtcbiAgICAgIGluZGV4LnNldChbaW5kICsgMiwgaW5kICsgMSwgaW5kICsgM10sIChpbmQgKyAxKSAqIDMpO1xuICAgIH1cblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeSA9IG5ldyBHZW9tZXRyeShnbCwgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBkYXRhOiB0aGlzLnBvc2l0aW9uXG4gICAgICB9LFxuICAgICAgcHJldjoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBkYXRhOiB0aGlzLnByZXZcbiAgICAgIH0sXG4gICAgICBuZXh0OiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIGRhdGE6IHRoaXMubmV4dFxuICAgICAgfSxcbiAgICAgIHNpZGU6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgZGF0YTogc2lkZVxuICAgICAgfSxcbiAgICAgIHV2OiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIGRhdGE6IHV2XG4gICAgICB9LFxuICAgICAgaW5kZXg6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgZGF0YTogaW5kZXhcbiAgICAgIH1cbiAgICB9KSk7IC8vIFBvcHVsYXRlIGR5bmFtaWMgYnVmZmVyc1xuXG4gICAgdGhpcy51cGRhdGVHZW9tZXRyeSgpO1xuICAgIGlmICghdW5pZm9ybXMudVJlc29sdXRpb24pIHRoaXMucmVzb2x1dGlvbiA9IHVuaWZvcm1zLnVSZXNvbHV0aW9uID0ge1xuICAgICAgdmFsdWU6IG5ldyBWZWMyKClcbiAgICB9O1xuICAgIGlmICghdW5pZm9ybXMudURQUikgdGhpcy5kcHIgPSB1bmlmb3Jtcy51RFBSID0ge1xuICAgICAgdmFsdWU6IDFcbiAgICB9O1xuICAgIGlmICghdW5pZm9ybXMudVRoaWNrbmVzcykgdGhpcy50aGlja25lc3MgPSB1bmlmb3Jtcy51VGhpY2tuZXNzID0ge1xuICAgICAgdmFsdWU6IDFcbiAgICB9O1xuICAgIGlmICghdW5pZm9ybXMudUNvbG9yKSB0aGlzLmNvbG9yID0gdW5pZm9ybXMudUNvbG9yID0ge1xuICAgICAgdmFsdWU6IG5ldyBDb2xvcignIzAwMCcpXG4gICAgfTtcbiAgICBpZiAoIXVuaWZvcm1zLnVNaXRlcikgdGhpcy5taXRlciA9IHVuaWZvcm1zLnVNaXRlciA9IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfTsgLy8gU2V0IHNpemUgdW5pZm9ybXMnIHZhbHVlc1xuXG4gICAgdGhpcy5yZXNpemUoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtID0gbmV3IFByb2dyYW0oZ2wsIHtcbiAgICAgIHZlcnRleCxcbiAgICAgIGZyYWdtZW50LFxuICAgICAgdW5pZm9ybXNcbiAgICB9KTtcbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaChnbCwge1xuICAgICAgZ2VvbWV0cnksXG4gICAgICBwcm9ncmFtXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVHZW9tZXRyeSgpIHtcbiAgICB0aGlzLnBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICBwLnRvQXJyYXkodGhpcy5wb3NpdGlvbiwgaSAqIDMgKiAyKTtcbiAgICAgIHAudG9BcnJheSh0aGlzLnBvc2l0aW9uLCBpICogMyAqIDIgKyAzKTtcblxuICAgICAgaWYgKCFpKSB7XG4gICAgICAgIC8vIElmIGZpcnN0IHBvaW50LCBjYWxjdWxhdGUgcHJldiB1c2luZyB0aGUgZGlzdGFuY2UgdG8gMm5kIHBvaW50XG4gICAgICAgIHRtcC5jb3B5KHApLnN1Yih0aGlzLnBvaW50c1tpICsgMV0pLmFkZChwKTtcbiAgICAgICAgdG1wLnRvQXJyYXkodGhpcy5wcmV2LCBpICogMyAqIDIpO1xuICAgICAgICB0bXAudG9BcnJheSh0aGlzLnByZXYsIGkgKiAzICogMiArIDMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC50b0FycmF5KHRoaXMubmV4dCwgKGkgLSAxKSAqIDMgKiAyKTtcbiAgICAgICAgcC50b0FycmF5KHRoaXMubmV4dCwgKGkgLSAxKSAqIDMgKiAyICsgMyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSB0aGlzLnBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIElmIGxhc3QgcG9pbnQsIGNhbGN1bGF0ZSBuZXh0IHVzaW5nIGRpc3RhbmNlIHRvIDJuZCBsYXN0IHBvaW50XG4gICAgICAgIHRtcC5jb3B5KHApLnN1Yih0aGlzLnBvaW50c1tpIC0gMV0pLmFkZChwKTtcbiAgICAgICAgdG1wLnRvQXJyYXkodGhpcy5uZXh0LCBpICogMyAqIDIpO1xuICAgICAgICB0bXAudG9BcnJheSh0aGlzLm5leHQsIGkgKiAzICogMiArIDMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC50b0FycmF5KHRoaXMucHJldiwgKGkgKyAxKSAqIDMgKiAyKTtcbiAgICAgICAgcC50b0FycmF5KHRoaXMucHJldiwgKGkgKyAxKSAqIDMgKiAyICsgMyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucHJldi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLm5leHQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9IC8vIE9ubHkgbmVlZCB0byBjYWxsIGlmIG5vdCBoYW5kbGluZyByZXNvbHV0aW9uIHVuaWZvcm1zIG1hbnVhbGx5XG5cblxuICByZXNpemUoKSB7XG4gICAgLy8gVXBkYXRlIGF1dG9tYXRpYyB1bmlmb3JtcyBpZiBub3Qgb3ZlcnJpZGRlblxuICAgIGlmICh0aGlzLnJlc29sdXRpb24pIHRoaXMucmVzb2x1dGlvbi52YWx1ZS5zZXQodGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgaWYgKHRoaXMuZHByKSB0aGlzLmRwci52YWx1ZSA9IHRoaXMuZ2wucmVuZGVyZXIuZHByO1xuICB9XG5cbn1cbmNvbnN0IGRlZmF1bHRWZXJ0ZXggPVxuLyogZ2xzbCAqL1xuYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIGF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMzIG5leHQ7XG4gICAgYXR0cmlidXRlIHZlYzMgcHJldjtcbiAgICBhdHRyaWJ1dGUgdmVjMiB1djtcbiAgICBhdHRyaWJ1dGUgZmxvYXQgc2lkZTtcblxuICAgIHVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XG4gICAgdW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XG4gICAgdW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xuICAgIHVuaWZvcm0gZmxvYXQgdURQUjtcbiAgICB1bmlmb3JtIGZsb2F0IHVUaGlja25lc3M7XG4gICAgdW5pZm9ybSBmbG9hdCB1TWl0ZXI7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdmVjNCBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgbWF0NCBtdnAgPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4O1xuICAgICAgICB2ZWM0IGN1cnJlbnQgPSBtdnAgKiB2ZWM0KHBvc2l0aW9uLCAxKTtcbiAgICAgICAgdmVjNCBuZXh0UG9zID0gbXZwICogdmVjNChuZXh0LCAxKTtcbiAgICAgICAgdmVjNCBwcmV2UG9zID0gbXZwICogdmVjNChwcmV2LCAxKTtcblxuICAgICAgICB2ZWMyIGFzcGVjdCA9IHZlYzIodVJlc29sdXRpb24ueCAvIHVSZXNvbHV0aW9uLnksIDEpOyAgICBcbiAgICAgICAgdmVjMiBjdXJyZW50U2NyZWVuID0gY3VycmVudC54eSAvIGN1cnJlbnQudyAqIGFzcGVjdDtcbiAgICAgICAgdmVjMiBuZXh0U2NyZWVuID0gbmV4dFBvcy54eSAvIG5leHRQb3MudyAqIGFzcGVjdDtcbiAgICAgICAgdmVjMiBwcmV2U2NyZWVuID0gcHJldlBvcy54eSAvIHByZXZQb3MudyAqIGFzcGVjdDtcbiAgICBcbiAgICAgICAgdmVjMiBkaXIxID0gbm9ybWFsaXplKGN1cnJlbnRTY3JlZW4gLSBwcmV2U2NyZWVuKTtcbiAgICAgICAgdmVjMiBkaXIyID0gbm9ybWFsaXplKG5leHRTY3JlZW4gLSBjdXJyZW50U2NyZWVuKTtcbiAgICAgICAgdmVjMiBkaXIgPSBub3JtYWxpemUoZGlyMSArIGRpcjIpO1xuICAgIFxuICAgICAgICB2ZWMyIG5vcm1hbCA9IHZlYzIoLWRpci55LCBkaXIueCk7XG4gICAgICAgIG5vcm1hbCAvPSBtaXgoMS4wLCBtYXgoMC4zLCBkb3Qobm9ybWFsLCB2ZWMyKC1kaXIxLnksIGRpcjEueCkpKSwgdU1pdGVyKTtcbiAgICAgICAgbm9ybWFsIC89IGFzcGVjdDtcblxuICAgICAgICBmbG9hdCBwaXhlbFdpZHRoUmF0aW8gPSAxLjAgLyAodVJlc29sdXRpb24ueSAvIHVEUFIpO1xuICAgICAgICBmbG9hdCBwaXhlbFdpZHRoID0gY3VycmVudC53ICogcGl4ZWxXaWR0aFJhdGlvO1xuICAgICAgICBub3JtYWwgKj0gcGl4ZWxXaWR0aCAqIHVUaGlja25lc3M7XG4gICAgICAgIGN1cnJlbnQueHkgLT0gbm9ybWFsICogc2lkZTtcbiAgICBcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2VXYgPSB1djtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBnZXRQb3NpdGlvbigpO1xuICAgIH1cbmA7XG5jb25zdCBkZWZhdWx0RnJhZ21lbnQgPVxuLyogZ2xzbCAqL1xuYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAgIHVuaWZvcm0gdmVjMyB1Q29sb3I7XG4gICAgXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IHVDb2xvcjtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSAxLjA7XG4gICAgfVxuYDsiLCJpbXBvcnQgeyBDYW1lcmEgfSBmcm9tICcuLi9jb3JlL0NhbWVyYS5qcyc7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnLi4vY29yZS9Qcm9ncmFtLmpzJztcbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4uL2NvcmUvUmVuZGVyVGFyZ2V0LmpzJztcbmV4cG9ydCBjbGFzcyBTaGFkb3cge1xuICBjb25zdHJ1Y3RvcihnbCwge1xuICAgIGxpZ2h0ID0gbmV3IENhbWVyYShnbCksXG4gICAgd2lkdGggPSAxMDI0LFxuICAgIGhlaWdodCA9IHdpZHRoXG4gIH0pIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIHRoaXMudGFyZ2V0ID0gbmV3IFJlbmRlclRhcmdldChnbCwge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9KTtcbiAgICB0aGlzLmRlcHRoUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB7XG4gICAgICB2ZXJ0ZXg6IGRlZmF1bHRWZXJ0ZXgsXG4gICAgICBmcmFnbWVudDogZGVmYXVsdEZyYWdtZW50LFxuICAgICAgY3VsbEZhY2U6IG51bGxcbiAgICB9KTtcbiAgICB0aGlzLmNhc3RNZXNoZXMgPSBbXTtcbiAgfVxuXG4gIGFkZCh7XG4gICAgbWVzaCxcbiAgICByZWNlaXZlID0gdHJ1ZSxcbiAgICBjYXN0ID0gdHJ1ZSxcbiAgICB2ZXJ0ZXggPSBkZWZhdWx0VmVydGV4LFxuICAgIGZyYWdtZW50ID0gZGVmYXVsdEZyYWdtZW50LFxuICAgIHVuaWZvcm1Qcm9qZWN0aW9uID0gJ3NoYWRvd1Byb2plY3Rpb25NYXRyaXgnLFxuICAgIHVuaWZvcm1WaWV3ID0gJ3NoYWRvd1ZpZXdNYXRyaXgnLFxuICAgIHVuaWZvcm1UZXh0dXJlID0gJ3RTaGFkb3cnXG4gIH0pIHtcbiAgICAvLyBBZGQgdW5pZm9ybXMgdG8gZXhpc3RpbmcgcHJvZ3JhbVxuICAgIGlmIChyZWNlaXZlICYmICFtZXNoLnByb2dyYW0udW5pZm9ybXNbdW5pZm9ybVByb2plY3Rpb25dKSB7XG4gICAgICBtZXNoLnByb2dyYW0udW5pZm9ybXNbdW5pZm9ybVByb2plY3Rpb25dID0ge1xuICAgICAgICB2YWx1ZTogdGhpcy5saWdodC5wcm9qZWN0aW9uTWF0cml4XG4gICAgICB9O1xuICAgICAgbWVzaC5wcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1WaWV3XSA9IHtcbiAgICAgICAgdmFsdWU6IHRoaXMubGlnaHQudmlld01hdHJpeFxuICAgICAgfTtcbiAgICAgIG1lc2gucHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtVGV4dHVyZV0gPSB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnRhcmdldC50ZXh0dXJlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghY2FzdCkgcmV0dXJuO1xuICAgIHRoaXMuY2FzdE1lc2hlcy5wdXNoKG1lc2gpOyAvLyBTdG9yZSBwcm9ncmFtIGZvciB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIGRlcHRoIG92ZXJyaWRlXG5cbiAgICBtZXNoLmNvbG9yUHJvZ3JhbSA9IG1lc2gucHJvZ3JhbTsgLy8gQ2hlY2sgaWYgZGVwdGggcHJvZ3JhbSBhbHJlYWR5IGF0dGFjaGVkXG5cbiAgICBpZiAobWVzaC5kZXB0aFByb2dyYW0pIHJldHVybjsgLy8gVXNlIGdsb2JhbCBkZXB0aCBvdmVycmlkZSBpZiBub3RoaW5nIGN1c3RvbSBwYXNzZWQgaW5cblxuICAgIGlmICh2ZXJ0ZXggPT09IGRlZmF1bHRWZXJ0ZXggJiYgZnJhZ21lbnQgPT09IGRlZmF1bHRGcmFnbWVudCkge1xuICAgICAgbWVzaC5kZXB0aFByb2dyYW0gPSB0aGlzLmRlcHRoUHJvZ3JhbTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENyZWF0ZSBjdXN0b20gb3ZlcnJpZGUgcHJvZ3JhbVxuXG5cbiAgICBtZXNoLmRlcHRoUHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB7XG4gICAgICB2ZXJ0ZXgsXG4gICAgICBmcmFnbWVudCxcbiAgICAgIGN1bGxGYWNlOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICByZW5kZXIoe1xuICAgIHNjZW5lXG4gIH0pIHtcbiAgICAvLyBGb3IgZGVwdGggcmVuZGVyLCByZXBsYWNlIHByb2dyYW0gd2l0aCBkZXB0aCBvdmVycmlkZS5cbiAgICAvLyBIaWRlIG1lc2hlcyBub3QgY2FzdGluZyBzaGFkb3dzLlxuICAgIHNjZW5lLnRyYXZlcnNlKG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmRyYXcpIHJldHVybjtcblxuICAgICAgaWYgKCEhfnRoaXMuY2FzdE1lc2hlcy5pbmRleE9mKG5vZGUpKSB7XG4gICAgICAgIG5vZGUucHJvZ3JhbSA9IG5vZGUuZGVwdGhQcm9ncmFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pc0ZvcmNlVmlzaWJpbGl0eSA9IG5vZGUudmlzaWJsZTtcbiAgICAgICAgbm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7IC8vIFJlbmRlciB0aGUgZGVwdGggc2hhZG93IG1hcCB1c2luZyB0aGUgbGlnaHQgYXMgdGhlIGNhbWVyYVxuXG4gICAgdGhpcy5nbC5yZW5kZXJlci5yZW5kZXIoe1xuICAgICAgc2NlbmUsXG4gICAgICBjYW1lcmE6IHRoaXMubGlnaHQsXG4gICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0XG4gICAgfSk7IC8vIFRoZW4gc3dpdGNoIHRoZSBwcm9ncmFtIGJhY2sgdG8gdGhlIG5vcm1hbCBvbmVcblxuICAgIHNjZW5lLnRyYXZlcnNlKG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmRyYXcpIHJldHVybjtcblxuICAgICAgaWYgKCEhfnRoaXMuY2FzdE1lc2hlcy5pbmRleE9mKG5vZGUpKSB7XG4gICAgICAgIG5vZGUucHJvZ3JhbSA9IG5vZGUuY29sb3JQcm9ncmFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS52aXNpYmxlID0gbm9kZS5pc0ZvcmNlVmlzaWJpbGl0eTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5jb25zdCBkZWZhdWx0VmVydGV4ID1cbi8qIGdsc2wgKi9cbmBcbiAgICBhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiB1djtcblxuICAgIHVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XG4gICAgdW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgfVxuYDtcbmNvbnN0IGRlZmF1bHRGcmFnbWVudCA9XG4vKiBnbHNsICovXG5gXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICAgdmVjNCBwYWNrUkdCQSAoZmxvYXQgdikge1xuICAgICAgICB2ZWM0IHBhY2sgPSBmcmFjdCh2ZWM0KDEuMCwgMjU1LjAsIDY1MDI1LjAsIDE2NTgxMzc1LjApICogdik7XG4gICAgICAgIHBhY2sgLT0gcGFjay55end3ICogdmVjMigxLjAgLyAyNTUuMCwgMC4wKS54eHh5O1xuICAgICAgICByZXR1cm4gcGFjaztcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHBhY2tSR0JBKGdsX0ZyYWdDb29yZC56KTtcbiAgICB9XG5gOyIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi9jb3JlL1RleHR1cmUuanMnOyAvLyBUT0RPOiBTdXBwb3J0IGN1YmVtYXBzXG4vLyBHZW5lcmF0ZSB0ZXh0dXJlcyB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vVGltdmFuU2NoZXJwZW56ZWVsL3RleHR1cmUtY29tcHJlc3NvclxuXG5leHBvcnQgY2xhc3MgS1RYVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuICBjb25zdHJ1Y3RvcihnbCwge1xuICAgIGJ1ZmZlcixcbiAgICB3cmFwUyA9IGdsLkNMQU1QX1RPX0VER0UsXG4gICAgd3JhcFQgPSBnbC5DTEFNUF9UT19FREdFLFxuICAgIGFuaXNvdHJvcHkgPSAwXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKGdsLCB7XG4gICAgICBnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICAgICAgd3JhcFMsXG4gICAgICB3cmFwVCxcbiAgICAgIGFuaXNvdHJvcHlcbiAgICB9KTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gdGhpcy5wYXJzZUJ1ZmZlcihidWZmZXIpO1xuICB9XG5cbiAgcGFyc2VCdWZmZXIoYnVmZmVyKSB7XG4gICAgY29uc3Qga3R4ID0gbmV3IEtocm9ub3NUZXh0dXJlQ29udGFpbmVyKGJ1ZmZlcik7XG4gICAga3R4Lm1pcG1hcHMuaXNDb21wcmVzc2VkVGV4dHVyZSA9IHRydWU7IC8vIFVwZGF0ZSB0ZXh0dXJlXG5cbiAgICB0aGlzLmltYWdlID0ga3R4Lm1pcG1hcHM7XG4gICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGt0eC5nbEludGVybmFsRm9ybWF0O1xuICAgIHRoaXMubWluRmlsdGVyID0ga3R4Lm51bWJlck9mTWlwbWFwTGV2ZWxzID4gMSA/IHRoaXMuZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSIDogdGhpcy5nbC5MSU5FQVI7IC8vIFRPRE86IHN1cHBvcnQgY3ViZSBtYXBzXG4gICAgLy8ga3R4Lm51bWJlck9mRmFjZXNcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIEtocm9ub3NUZXh0dXJlQ29udGFpbmVyKGJ1ZmZlcikge1xuICBjb25zdCBpZENoZWNrID0gWzB4YWIsIDB4NGIsIDB4NTQsIDB4NTgsIDB4MjAsIDB4MzEsIDB4MzEsIDB4YmIsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdO1xuICBjb25zdCBpZCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgMTIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIGlmIChpZFtpXSAhPT0gaWRDaGVja1tpXSkgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0ZpbGUgbWlzc2luZyBLVFggaWRlbnRpZmllcicpOyAvLyBUT0RPOiBJcyB0aGlzIGFsd2F5cyA0PyBUZXN0ZWQ6IFthbmRyb2lkLCBtYWNvc11cblxuXG4gIGNvbnN0IHNpemUgPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgY29uc3QgaGVhZCA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDEyLCAxMyAqIHNpemUpO1xuICBjb25zdCBsaXR0bGVFbmRpYW4gPSBoZWFkLmdldFVpbnQzMigwLCB0cnVlKSA9PT0gMHgwNDAzMDIwMTtcbiAgY29uc3QgZ2xUeXBlID0gaGVhZC5nZXRVaW50MzIoMSAqIHNpemUsIGxpdHRsZUVuZGlhbik7XG4gIGlmIChnbFR5cGUgIT09IDApIHJldHVybiBjb25zb2xlLndhcm4oJ29ubHkgY29tcHJlc3NlZCBmb3JtYXRzIGN1cnJlbnRseSBzdXBwb3J0ZWQnKTtcbiAgdGhpcy5nbEludGVybmFsRm9ybWF0ID0gaGVhZC5nZXRVaW50MzIoNCAqIHNpemUsIGxpdHRsZUVuZGlhbik7XG4gIGxldCB3aWR0aCA9IGhlYWQuZ2V0VWludDMyKDYgKiBzaXplLCBsaXR0bGVFbmRpYW4pO1xuICBsZXQgaGVpZ2h0ID0gaGVhZC5nZXRVaW50MzIoNyAqIHNpemUsIGxpdHRsZUVuZGlhbik7XG4gIHRoaXMubnVtYmVyT2ZGYWNlcyA9IGhlYWQuZ2V0VWludDMyKDEwICogc2l6ZSwgbGl0dGxlRW5kaWFuKTtcbiAgdGhpcy5udW1iZXJPZk1pcG1hcExldmVscyA9IE1hdGgubWF4KDEsIGhlYWQuZ2V0VWludDMyKDExICogc2l6ZSwgbGl0dGxlRW5kaWFuKSk7XG4gIGNvbnN0IGJ5dGVzT2ZLZXlWYWx1ZURhdGEgPSBoZWFkLmdldFVpbnQzMigxMiAqIHNpemUsIGxpdHRsZUVuZGlhbik7XG4gIHRoaXMubWlwbWFwcyA9IFtdO1xuICBsZXQgb2Zmc2V0ID0gMTIgKyAxMyAqIDQgKyBieXRlc09mS2V5VmFsdWVEYXRhO1xuXG4gIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCB0aGlzLm51bWJlck9mTWlwbWFwTGV2ZWxzOyBsZXZlbCsrKSB7XG4gICAgY29uc3QgbGV2ZWxTaXplID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIDEpWzBdOyAvLyBzaXplIHBlciBmYWNlLCBzaW5jZSBub3Qgc3VwcG9ydGluZyBhcnJheSBjdWJlbWFwc1xuXG4gICAgb2Zmc2V0ICs9IDQ7IC8vIGxldmVsU2l6ZSBmaWVsZFxuXG4gICAgZm9yIChsZXQgZmFjZSA9IDA7IGZhY2UgPCB0aGlzLm51bWJlck9mRmFjZXM7IGZhY2UrKykge1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBsZXZlbFNpemUpO1xuICAgICAgdGhpcy5taXBtYXBzLnB1c2goe1xuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIG9mZnNldCArPSBsZXZlbFNpemU7XG4gICAgICBvZmZzZXQgKz0gMyAtIChsZXZlbFNpemUgKyAzKSAlIDQ7IC8vIGFkZCBwYWRkaW5nIGZvciBvZGQgc2l6ZWQgaW1hZ2VcbiAgICB9XG5cbiAgICB3aWR0aCA9IHdpZHRoID4+IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ID4+IDE7XG4gIH1cbn0iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vY29yZS9UZXh0dXJlLmpzJztcbmltcG9ydCB7IEtUWFRleHR1cmUgfSBmcm9tICcuL0tUWFRleHR1cmUuanMnOyAvLyBGb3IgY29tcHJlc3NlZCB0ZXh0dXJlcywgZ2VuZXJhdGUgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL1RpbXZhblNjaGVycGVuemVlbC90ZXh0dXJlLWNvbXByZXNzb3JcblxubGV0IGNhY2hlID0ge307XG5jb25zdCBzdXBwb3J0ZWRFeHRlbnNpb25zID0gW107XG5leHBvcnQgY2xhc3MgVGV4dHVyZUxvYWRlciB7XG4gIHN0YXRpYyBsb2FkKGdsLCB7XG4gICAgc3JjLFxuICAgIC8vIHN0cmluZyBvciBvYmplY3Qgb2YgZXh0ZW5zaW9uOnNyYyBrZXktdmFsdWVzXG4gICAgLy8ge1xuICAgIC8vICAgICBwdnJ0YzogJy4uLmt0eCcsXG4gICAgLy8gICAgIHMzdGM6ICcuLi5rdHgnLFxuICAgIC8vICAgICBldGM6ICcuLi5rdHgnLFxuICAgIC8vICAgICBldGMxOiAnLi4ua3R4JyxcbiAgICAvLyAgICAgYXN0YzogJy4uLmt0eCcsXG4gICAgLy8gICAgIHdlYnA6ICcuLi53ZWJwJyxcbiAgICAvLyAgICAganBnOiAnLi4uanBnJyxcbiAgICAvLyAgICAgcG5nOiAnLi4ucG5nJyxcbiAgICAvLyB9XG4gICAgLy8gT25seSBwcm9wcyByZWxldmFudCB0byBLVFhUZXh0dXJlXG4gICAgd3JhcFMgPSBnbC5DTEFNUF9UT19FREdFLFxuICAgIHdyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICBhbmlzb3Ryb3B5ID0gMCxcbiAgICAvLyBGb3IgcmVndWxhciBpbWFnZXNcbiAgICBmb3JtYXQgPSBnbC5SR0JBLFxuICAgIGludGVybmFsRm9ybWF0ID0gZm9ybWF0LFxuICAgIGdlbmVyYXRlTWlwbWFwcyA9IHRydWUsXG4gICAgbWluRmlsdGVyID0gZ2VuZXJhdGVNaXBtYXBzID8gZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSIDogZ2wuTElORUFSLFxuICAgIG1hZ0ZpbHRlciA9IGdsLkxJTkVBUixcbiAgICBwcmVtdWx0aXBseUFscGhhID0gZmFsc2UsXG4gICAgdW5wYWNrQWxpZ25tZW50ID0gNCxcbiAgICBmbGlwWSA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qgc3VwcG9ydCA9IHRoaXMuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucyhnbCk7XG4gICAgbGV0IGV4dCA9ICdub25lJzsgLy8gSWYgc3JjIGlzIHN0cmluZywgZGV0ZXJtaW5lIHdoaWNoIGZvcm1hdCBmcm9tIHRoZSBleHRlbnNpb25cblxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgZXh0ID0gc3JjLnNwbGl0KCcuJykucG9wKCkuc3BsaXQoJz8nKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gLy8gSWYgc3JjIGlzIG9iamVjdCwgdXNlIHN1cHBvcnRlZCBleHRlbnNpb25zIGFuZCBwcm92aWRlZCBsaXN0IHRvIGNob29zZSBiZXN0IG9wdGlvblxuICAgIC8vIEdldCBmaXJzdCBzdXBwb3J0ZWQgbWF0Y2gsIHNvIHB1dCBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG5cblxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIHNyYykge1xuICAgICAgICBpZiAoc3VwcG9ydC5pbmNsdWRlcyhwcm9wLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgZXh0ID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHNyYyA9IHNyY1twcm9wXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gU3RyaW5naWZ5IHByb3BzXG5cblxuICAgIGNvbnN0IGNhY2hlSUQgPSBzcmMgKyB3cmFwUyArIHdyYXBUICsgYW5pc290cm9weSArIGZvcm1hdCArIGludGVybmFsRm9ybWF0ICsgZ2VuZXJhdGVNaXBtYXBzICsgbWluRmlsdGVyICsgbWFnRmlsdGVyICsgcHJlbXVsdGlwbHlBbHBoYSArIHVucGFja0FsaWdubWVudCArIGZsaXBZICsgZ2wucmVuZGVyZXIuaWQ7IC8vIENoZWNrIGNhY2hlIGZvciBleGlzdGluZyB0ZXh0dXJlXG5cbiAgICBpZiAoY2FjaGVbY2FjaGVJRF0pIHJldHVybiBjYWNoZVtjYWNoZUlEXTtcbiAgICBsZXQgdGV4dHVyZTtcblxuICAgIHN3aXRjaCAoZXh0KSB7XG4gICAgICBjYXNlICdrdHgnOlxuICAgICAgY2FzZSAncHZydGMnOlxuICAgICAgY2FzZSAnczN0Yyc6XG4gICAgICBjYXNlICdldGMnOlxuICAgICAgY2FzZSAnZXRjMSc6XG4gICAgICBjYXNlICdhc3RjJzpcbiAgICAgICAgLy8gTG9hZCBjb21wcmVzc2VkIHRleHR1cmUgdXNpbmcgS1RYIGZvcm1hdFxuICAgICAgICB0ZXh0dXJlID0gbmV3IEtUWFRleHR1cmUoZ2wsIHtcbiAgICAgICAgICBzcmMsXG4gICAgICAgICAgd3JhcFMsXG4gICAgICAgICAgd3JhcFQsXG4gICAgICAgICAgYW5pc290cm9weVxuICAgICAgICB9KTtcbiAgICAgICAgdGV4dHVyZS5sb2FkZWQgPSB0aGlzLmxvYWRLVFgoc3JjLCB0ZXh0dXJlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3dlYnAnOlxuICAgICAgY2FzZSAnanBnJzpcbiAgICAgIGNhc2UgJ2pwZWcnOlxuICAgICAgY2FzZSAncG5nJzpcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsLCB7XG4gICAgICAgICAgd3JhcFMsXG4gICAgICAgICAgd3JhcFQsXG4gICAgICAgICAgYW5pc290cm9weSxcbiAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgZ2VuZXJhdGVNaXBtYXBzLFxuICAgICAgICAgIG1pbkZpbHRlcixcbiAgICAgICAgICBtYWdGaWx0ZXIsXG4gICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYSxcbiAgICAgICAgICB1bnBhY2tBbGlnbm1lbnQsXG4gICAgICAgICAgZmxpcFlcbiAgICAgICAgfSk7XG4gICAgICAgIHRleHR1cmUubG9hZGVkID0gdGhpcy5sb2FkSW1hZ2UoZ2wsIHNyYywgdGV4dHVyZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHN1cHBvcnRlZCBmb3JtYXQgc3VwcGxpZWQnKTtcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsKTtcbiAgICB9XG5cbiAgICB0ZXh0dXJlLmV4dCA9IGV4dDtcbiAgICBjYWNoZVtjYWNoZUlEXSA9IHRleHR1cmU7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICBzdGF0aWMgZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucyhnbCkge1xuICAgIGlmIChzdXBwb3J0ZWRFeHRlbnNpb25zLmxlbmd0aCkgcmV0dXJuIHN1cHBvcnRlZEV4dGVuc2lvbnM7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHtcbiAgICAgIHB2cnRjOiBnbC5yZW5kZXJlci5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycpIHx8IGdsLnJlbmRlcmVyLmdldEV4dGVuc2lvbignV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycpLFxuICAgICAgczN0YzogZ2wucmVuZGVyZXIuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpIHx8IGdsLnJlbmRlcmVyLmdldEV4dGVuc2lvbignTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJykgfHwgZ2wucmVuZGVyZXIuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKSxcbiAgICAgIGV0YzogZ2wucmVuZGVyZXIuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjJyksXG4gICAgICBldGMxOiBnbC5yZW5kZXJlci5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyksXG4gICAgICBhc3RjOiBnbC5yZW5kZXJlci5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjJylcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBleHQgaW4gZXh0ZW5zaW9ucykgaWYgKGV4dGVuc2lvbnNbZXh0XSkgc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKGV4dCk7IC8vIENoZWNrIGZvciBXZWJQIHN1cHBvcnRcblxuXG4gICAgaWYgKGRldGVjdFdlYlApIHN1cHBvcnRlZEV4dGVuc2lvbnMucHVzaCgnd2VicCcpOyAvLyBGb3JtYXRzIHN1cHBvcnRlZCBieSBhbGxcblxuICAgIHN1cHBvcnRlZEV4dGVuc2lvbnMucHVzaCgncG5nJywgJ2pwZycpO1xuICAgIHJldHVybiBzdXBwb3J0ZWRFeHRlbnNpb25zO1xuICB9XG5cbiAgc3RhdGljIGxvYWRLVFgoc3JjLCB0ZXh0dXJlKSB7XG4gICAgcmV0dXJuIGZldGNoKHNyYykudGhlbihyZXMgPT4gcmVzLmFycmF5QnVmZmVyKCkpLnRoZW4oYnVmZmVyID0+IHRleHR1cmUucGFyc2VCdWZmZXIoYnVmZmVyKSk7XG4gIH1cblxuICBzdGF0aWMgbG9hZEltYWdlKGdsLCBzcmMsIHRleHR1cmUpIHtcbiAgICByZXR1cm4gZGVjb2RlSW1hZ2Uoc3JjKS50aGVuKGltZ0JtcCA9PiB7XG4gICAgICAvLyBDYXRjaCBub24gUE9UIHRleHR1cmVzIGFuZCB1cGRhdGUgcGFyYW1zIHRvIGF2b2lkIGVycm9yc1xuICAgICAgaWYgKCFwb3dlck9mVHdvKGltZ0JtcC53aWR0aCkgfHwgIXBvd2VyT2ZUd28oaW1nQm1wLmhlaWdodCkpIHtcbiAgICAgICAgaWYgKHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzKSB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgICBpZiAodGV4dHVyZS5taW5GaWx0ZXIgPT09IGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUikgdGV4dHVyZS5taW5GaWx0ZXIgPSBnbC5MSU5FQVI7XG4gICAgICAgIGlmICh0ZXh0dXJlLndyYXBTID09PSBnbC5SRVBFQVQpIHRleHR1cmUud3JhcFMgPSB0ZXh0dXJlLndyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRTtcbiAgICAgIH1cblxuICAgICAgdGV4dHVyZS5pbWFnZSA9IGltZ0JtcDsgLy8gRm9yIGNyZWF0ZUltYWdlQml0bWFwLCBjbG9zZSBvbmNlIHVwbG9hZGVkXG5cbiAgICAgIHRleHR1cmUub25VcGRhdGUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChpbWdCbXAuY2xvc2UpIGltZ0JtcC5jbG9zZSgpO1xuICAgICAgICB0ZXh0dXJlLm9uVXBkYXRlID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgY2xlYXJDYWNoZSgpIHtcbiAgICBjYWNoZSA9IHt9O1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZGV0ZWN0V2ViUCgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLnRvRGF0YVVSTCgnaW1hZ2Uvd2VicCcpLmluZGV4T2YoJ2RhdGE6aW1hZ2Uvd2VicCcpID09IDA7XG59XG5cbmZ1bmN0aW9uIHBvd2VyT2ZUd28odmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubG9nMih2YWx1ZSkgJSAxID09PSAwO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVJbWFnZShzcmMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5zcmMgPSBzcmM7IC8vIE9ubHkgY2hyb21lJ3MgaW1wbGVtZW50YXRpb24gb2YgY3JlYXRlSW1hZ2VCaXRtYXAgaXMgZnVsbHkgc3VwcG9ydGVkXG5cbiAgICBjb25zdCBpc0Nocm9tZSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY2hyb21lJyk7XG5cbiAgICBpZiAoISF3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXAgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGltZywge1xuICAgICAgICAgIGltYWdlT3JpZW50YXRpb246ICdmbGlwWScsXG4gICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnXG4gICAgICAgIH0pLnRoZW4oaW1nQm1wID0+IHtcbiAgICAgICAgICByZXNvbHZlKGltZ0JtcCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICB9XG4gIH0pO1xufSIsImltcG9ydCB7IFZlYzMgfSBmcm9tICcuLi9tYXRoL1ZlYzMuanMnO1xuaW1wb3J0IHsgUXVhdCB9IGZyb20gJy4uL21hdGgvUXVhdC5qcyc7XG5jb25zdCB0bXBWZWMzQSA9IG5ldyBWZWMzKCk7XG5jb25zdCB0bXBWZWMzQiA9IG5ldyBWZWMzKCk7XG5jb25zdCB0bXBWZWMzQyA9IG5ldyBWZWMzKCk7XG5jb25zdCB0bXBWZWMzRCA9IG5ldyBWZWMzKCk7XG5jb25zdCB0bXBRdWF0QSA9IG5ldyBRdWF0KCk7XG5jb25zdCB0bXBRdWF0QiA9IG5ldyBRdWF0KCk7XG5jb25zdCB0bXBRdWF0QyA9IG5ldyBRdWF0KCk7XG5jb25zdCB0bXBRdWF0RCA9IG5ldyBRdWF0KCk7XG5leHBvcnQgY2xhc3MgR0xURkFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHdlaWdodCA9IDEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxhcHNlZCA9IDA7XG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7IC8vIFNldCB0byBmYWxzZSB0byBub3QgYXBwbHkgbW9kdWxvIHRvIGVsYXBzZWQgYWdhaW5zdCBkdXJhdGlvblxuXG4gICAgdGhpcy5sb29wID0gdHJ1ZTsgLy8gR2V0IGR1cmF0aW9uIGZyb20gbGFyZ2VzdCBmaW5hbCB0aW1lIGluIGFsbCBjaGFubmVsc1xuXG4gICAgdGhpcy5kdXJhdGlvbiA9IGRhdGEucmVkdWNlKChhLCB7XG4gICAgICB0aW1lc1xuICAgIH0pID0+IE1hdGgubWF4KGEsIHRpbWVzW3RpbWVzLmxlbmd0aCAtIDFdKSwgMCk7XG4gIH1cblxuICB1cGRhdGUodG90YWxXZWlnaHQgPSAxLCBpc1NldCkge1xuICAgIGNvbnN0IHdlaWdodCA9IGlzU2V0ID8gMSA6IHRoaXMud2VpZ2h0IC8gdG90YWxXZWlnaHQ7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMubG9vcCA/IHRoaXMuZWxhcHNlZCAlIHRoaXMuZHVyYXRpb24gOiBNYXRoLm1pbih0aGlzLmVsYXBzZWQsIHRoaXMuZHVyYXRpb24pO1xuICAgIHRoaXMuZGF0YS5mb3JFYWNoKCh7XG4gICAgICBub2RlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgaW50ZXJwb2xhdGlvbixcbiAgICAgIHRpbWVzLFxuICAgICAgdmFsdWVzXG4gICAgfSkgPT4ge1xuICAgICAgLy8gR2V0IGluZGV4IG9mIHR3byB0aW1lIHZhbHVlcyBlbGFwc2VkIGlzIGJldHdlZW5cbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IE1hdGgubWF4KDEsIHRpbWVzLmZpbmRJbmRleCh0ID0+IHQgPiBlbGFwc2VkKSkgLSAxO1xuICAgICAgY29uc3QgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTsgLy8gR2V0IGxpbmVhciBibGVuZC9hbHBoYSBiZXR3ZWVuIHRoZSB0d29cblxuICAgICAgbGV0IGFscGhhID0gKGVsYXBzZWQgLSB0aW1lc1twcmV2SW5kZXhdKSAvICh0aW1lc1tuZXh0SW5kZXhdIC0gdGltZXNbcHJldkluZGV4XSk7XG4gICAgICBpZiAoaW50ZXJwb2xhdGlvbiA9PT0gJ1NURVAnKSBhbHBoYSA9IDA7XG4gICAgICBsZXQgcHJldlZhbCA9IHRtcFZlYzNBO1xuICAgICAgbGV0IHByZXZUYW4gPSB0bXBWZWMzQjtcbiAgICAgIGxldCBuZXh0VGFuID0gdG1wVmVjM0M7XG4gICAgICBsZXQgbmV4dFZhbCA9IHRtcFZlYzNEO1xuICAgICAgbGV0IHNpemUgPSAzO1xuXG4gICAgICBpZiAodHJhbnNmb3JtID09PSAncXVhdGVybmlvbicpIHtcbiAgICAgICAgcHJldlZhbCA9IHRtcFF1YXRBO1xuICAgICAgICBwcmV2VGFuID0gdG1wUXVhdEI7XG4gICAgICAgIG5leHRUYW4gPSB0bXBRdWF0QztcbiAgICAgICAgbmV4dFZhbCA9IHRtcFF1YXREO1xuICAgICAgICBzaXplID0gNDtcbiAgICAgIH1cblxuICAgICAgaWYgKGludGVycG9sYXRpb24gPT09ICdDVUJJQ1NQTElORScpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBwcmV2IGFuZCBuZXh0IHZhbHVlcyBmcm9tIHRoZSBpbmRpY2VzXG4gICAgICAgIHByZXZWYWwuZnJvbUFycmF5KHZhbHVlcywgcHJldkluZGV4ICogc2l6ZSAqIDMgKyBzaXplICogMSk7XG4gICAgICAgIHByZXZUYW4uZnJvbUFycmF5KHZhbHVlcywgcHJldkluZGV4ICogc2l6ZSAqIDMgKyBzaXplICogMik7XG4gICAgICAgIG5leHRUYW4uZnJvbUFycmF5KHZhbHVlcywgbmV4dEluZGV4ICogc2l6ZSAqIDMgKyBzaXplICogMCk7XG4gICAgICAgIG5leHRWYWwuZnJvbUFycmF5KHZhbHVlcywgbmV4dEluZGV4ICogc2l6ZSAqIDMgKyBzaXplICogMSk7IC8vIGludGVycG9sYXRlIGZvciBmaW5hbCB2YWx1ZVxuXG4gICAgICAgIHByZXZWYWwgPSB0aGlzLmN1YmljU3BsaW5lSW50ZXJwb2xhdGUoYWxwaGEsIHByZXZWYWwsIHByZXZUYW4sIG5leHRUYW4sIG5leHRWYWwpO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gNCkgcHJldlZhbC5ub3JtYWxpemUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgcHJldiBhbmQgbmV4dCB2YWx1ZXMgZnJvbSB0aGUgaW5kaWNlc1xuICAgICAgICBwcmV2VmFsLmZyb21BcnJheSh2YWx1ZXMsIHByZXZJbmRleCAqIHNpemUpO1xuICAgICAgICBuZXh0VmFsLmZyb21BcnJheSh2YWx1ZXMsIG5leHRJbmRleCAqIHNpemUpOyAvLyBpbnRlcnBvbGF0ZSBmb3IgZmluYWwgdmFsdWVcblxuICAgICAgICBpZiAoc2l6ZSA9PT0gNCkgcHJldlZhbC5zbGVycChuZXh0VmFsLCBhbHBoYSk7ZWxzZSBwcmV2VmFsLmxlcnAobmV4dFZhbCwgYWxwaGEpO1xuICAgICAgfSAvLyBpbnRlcnBvbGF0ZSBiZXR3ZWVuIG11bHRpcGxlIHBvc3NpYmxlIGFuaW1hdGlvbnNcblxuXG4gICAgICBpZiAoc2l6ZSA9PT0gNCkgbm9kZVt0cmFuc2Zvcm1dLnNsZXJwKHByZXZWYWwsIHdlaWdodCk7ZWxzZSBub2RlW3RyYW5zZm9ybV0ubGVycChwcmV2VmFsLCB3ZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgY3ViaWNTcGxpbmVJbnRlcnBvbGF0ZSh0LCBwcmV2VmFsLCBwcmV2VGFuLCBuZXh0VGFuLCBuZXh0VmFsKSB7XG4gICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICBjb25zdCB0MyA9IHQyICogdDtcbiAgICBjb25zdCBzMiA9IDMgKiB0MiAtIDIgKiB0MztcbiAgICBjb25zdCBzMyA9IHQzIC0gdDI7XG4gICAgY29uc3QgczAgPSAxIC0gczI7XG4gICAgY29uc3QgczEgPSBzMyAtIHQyICsgdDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgcHJldlZhbFtpXSA9IHMwICogcHJldlZhbFtpXSArIHMxICogKDEgLSB0KSAqIHByZXZUYW5baV0gKyBzMiAqIG5leHRWYWxbaV0gKyBzMyAqIHQgKiBuZXh0VGFuW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2VmFsO1xuICB9XG5cbn0iLCJpbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vY29yZS9NZXNoLmpzJztcbmltcG9ydCB7IE1hdDQgfSBmcm9tICcuLi9tYXRoL01hdDQuanMnO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL2NvcmUvVGV4dHVyZS5qcyc7XG5jb25zdCB0ZW1wTWF0NCA9IG5ldyBNYXQ0KCk7XG5leHBvcnQgY2xhc3MgR0xURlNraW4gZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IoZ2wsIHtcbiAgICBza2VsZXRvbixcbiAgICBnZW9tZXRyeSxcbiAgICBwcm9ncmFtLFxuICAgIG1vZGUgPSBnbC5UUklBTkdMRVNcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoZ2wsIHtcbiAgICAgIGdlb21ldHJ5LFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgICB0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB0aGlzLmNyZWF0ZUJvbmVUZXh0dXJlKCk7XG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gIH1cblxuICBjcmVhdGVCb25lVGV4dHVyZSgpIHtcbiAgICBpZiAoIXRoaXMuc2tlbGV0b24uam9pbnRzLmxlbmd0aCkgcmV0dXJuO1xuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCg0LCBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2coTWF0aC5zcXJ0KHRoaXMuc2tlbGV0b24uam9pbnRzLmxlbmd0aCAqIDQpKSAvIE1hdGguTE4yKSkpO1xuICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogc2l6ZSAqIDQpO1xuICAgIHRoaXMuYm9uZVRleHR1cmVTaXplID0gc2l6ZTtcbiAgICB0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwge1xuICAgICAgaW1hZ2U6IHRoaXMuYm9uZU1hdHJpY2VzLFxuICAgICAgZ2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcbiAgICAgIHR5cGU6IHRoaXMuZ2wuRkxPQVQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nbC5yZW5kZXJlci5pc1dlYmdsMiA/IHRoaXMuZ2wuUkdCQTE2RiA6IHRoaXMuZ2wuUkdCQSxcbiAgICAgIGZsaXBZOiBmYWxzZSxcbiAgICAgIHdpZHRoOiBzaXplXG4gICAgfSk7XG4gIH0gLy8gYWRkQW5pbWF0aW9uKGRhdGEpIHtcbiAgLy8gICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oeyBvYmplY3RzOiB0aGlzLmJvbmVzLCBkYXRhIH0pO1xuICAvLyAgICAgdGhpcy5hbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgLy8gICAgIHJldHVybiBhbmltYXRpb247XG4gIC8vIH1cbiAgLy8gdXBkYXRlQW5pbWF0aW9ucygpIHtcbiAgLy8gICAgIC8vIENhbGN1bGF0ZSBjb21iaW5lZCBhbmltYXRpb24gd2VpZ2h0XG4gIC8vICAgICBsZXQgdG90YWwgPSAwO1xuICAvLyAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4gKHRvdGFsICs9IGFuaW1hdGlvbi53ZWlnaHQpKTtcbiAgLy8gICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKChhbmltYXRpb24sIGkpID0+IHtcbiAgLy8gICAgICAgICAvLyBmb3JjZSBmaXJzdCBhbmltYXRpb24gdG8gc2V0IGluIG9yZGVyIHRvIHJlc2V0IGZyYW1lXG4gIC8vICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZSh0b3RhbCwgaSA9PT0gMCk7XG4gIC8vICAgICB9KTtcbiAgLy8gfVxuXG5cbiAgdXBkYXRlVW5pZm9ybXMoKSB7XG4gICAgLy8gVXBkYXRlIGJvbmUgdGV4dHVyZVxuICAgIHRoaXMuc2tlbGV0b24uam9pbnRzLmZvckVhY2goKGJvbmUsIGkpID0+IHtcbiAgICAgIC8vIEZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIGJpbmQgcG9zZVxuICAgICAgdGVtcE1hdDQubXVsdGlwbHkoYm9uZS53b3JsZE1hdHJpeCwgYm9uZS5iaW5kSW52ZXJzZSk7XG4gICAgICB0aGlzLmJvbmVNYXRyaWNlcy5zZXQodGVtcE1hdDQsIGkgKiAxNik7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuYm9uZVRleHR1cmUpIHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgZHJhdyh7XG4gICAgY2FtZXJhXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5wcm9ncmFtLnVuaWZvcm1zLmJvbmVUZXh0dXJlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMucHJvZ3JhbS51bmlmb3Jtcywge1xuICAgICAgICBib25lVGV4dHVyZToge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLmJvbmVUZXh0dXJlXG4gICAgICAgIH0sXG4gICAgICAgIGJvbmVUZXh0dXJlU2l6ZToge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLmJvbmVUZXh0dXJlU2l6ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVVuaWZvcm1zKCk7IC8vIFN3aXRjaCB0aGlzIHdvcmxkIG1hdHJpeCB3aXRoIHJvb3Qgbm9kZSdzIHRvIHBvcHVsYXRlIHVuaWZvcm1zXG5cbiAgICBjb25zdCBfd29ybGRNYXRyaXggPSB0aGlzLndvcmxkTWF0cml4O1xuICAgIHRoaXMud29ybGRNYXRyaXggPSB0aGlzLnNrZWxldG9uLnNrZWxldG9uLndvcmxkTWF0cml4O1xuICAgIHN1cGVyLmRyYXcoe1xuICAgICAgY2FtZXJhXG4gICAgfSk7XG4gICAgdGhpcy53b3JsZE1hdHJpeCA9IF93b3JsZE1hdHJpeDtcbiAgfVxuXG59IiwiaW1wb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0dlb21ldHJ5LmpzJztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJy4uL2NvcmUvVHJhbnNmb3JtLmpzJztcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9jb3JlL01lc2guanMnO1xuaW1wb3J0IHsgR0xURkFuaW1hdGlvbiB9IGZyb20gJy4vR0xURkFuaW1hdGlvbi5qcyc7XG5pbXBvcnQgeyBHTFRGU2tpbiB9IGZyb20gJy4vR0xURlNraW4uanMnO1xuaW1wb3J0IHsgTWF0NCB9IGZyb20gJy4uL21hdGgvTWF0NC5qcyc7XG5pbXBvcnQgeyBOb3JtYWxQcm9ncmFtIH0gZnJvbSAnLi9Ob3JtYWxQcm9ncmFtLmpzJzsgLy8gU3VwcG9ydHNcbi8vIFt4XSBHZW9tZXRyeVxuLy8gWyBdIFNwYXJzZSBzdXBwb3J0XG4vLyBbeF0gTm9kZXMgYW5kIEhpZXJhcmNoeVxuLy8gWyBdIE1vcnBoIFRhcmdldHNcbi8vIFt4XSBTa2luc1xuLy8gWyBdIE1hdGVyaWFsc1xuLy8gWyBdIFRleHR1cmVzXG4vLyBbeF0gQW5pbWF0aW9uXG4vLyBbIF0gQ2FtZXJhc1xuLy8gWyBdIEV4dGVuc2lvbnNcbi8vIFRPRE86IFNwYXJzZSBhY2Nlc3NvciBwYWNraW5nPyBGb3IgbW9ycGggdGFyZ2V0cyBiYXNpY2FsbHlcbi8vIFRPRE86IGluaXQgYWNjZXNzb3IgbWlzc2luZyBidWZmZXJWaWV3IHdpdGggMHNcbi8vIFRPRE86IG1vcnBoIHRhcmdldCBhbmltYXRpb25zXG5cbmNvbnN0IFRZUEVfQVJSQVkgPSB7XG4gIDUxMjE6IFVpbnQ4QXJyYXksXG4gIDUxMjI6IEludDE2QXJyYXksXG4gIDUxMjM6IFVpbnQxNkFycmF5LFxuICA1MTI1OiBVaW50MzJBcnJheSxcbiAgNTEyNjogRmxvYXQzMkFycmF5XG59O1xuY29uc3QgVFlQRV9TSVpFID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuY29uc3QgQVRUUklCVVRFUyA9IHtcbiAgUE9TSVRJT046ICdwb3NpdGlvbicsXG4gIE5PUk1BTDogJ25vcm1hbCcsXG4gIFRBTkdFTlQ6ICd0YW5nZW50JyxcbiAgVEVYQ09PUkRfMDogJ3V2JyxcbiAgVEVYQ09PUkRfMTogJ3V2MicsXG4gIENPTE9SXzA6ICdjb2xvcicsXG4gIFdFSUdIVFNfMDogJ3NraW5XZWlnaHQnLFxuICBKT0lOVFNfMDogJ3NraW5JbmRleCdcbn07XG5jb25zdCBUUkFOU0ZPUk1TID0ge1xuICB0cmFuc2xhdGlvbjogJ3Bvc2l0aW9uJyxcbiAgcm90YXRpb246ICdxdWF0ZXJuaW9uJyxcbiAgc2NhbGU6ICdzY2FsZSdcbn07XG5leHBvcnQgY2xhc3MgR0xURkxvYWRlciB7XG4gIHN0YXRpYyBhc3luYyBsb2FkKGdsLCBzcmMpIHtcbiAgICBjb25zdCBkaXIgPSBzcmMuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuam9pbignLycpICsgJy8nOyAvLyBsb2FkIG1haW4gZGVzY3JpcHRpb24ganNvblxuXG4gICAgY29uc3QgZGVzYyA9IGF3YWl0IGZldGNoKHNyYykudGhlbihyZXMgPT4gcmVzLmpzb24oKSk7XG4gICAgaWYgKGRlc2MuYXNzZXQgPT09IHVuZGVmaW5lZCB8fCBkZXNjLmFzc2V0LnZlcnNpb25bMF0gPCAyKSBjb25zb2xlLndhcm4oJ09ubHkgR0xURiA+PTIuMCBzdXBwb3J0ZWQuIEF0dGVtcHRpbmcgdG8gcGFyc2UuJyk7IC8vIExvYWQgYnVmZmVycyBhc3luY1xuXG4gICAgY29uc3QgYnVmZmVycyA9IGF3YWl0IHRoaXMubG9hZEJ1ZmZlcnMoZGVzYywgZGlyKTsgLy8gQ3JlYXRlIGdsIGJ1ZmZlcnMgZnJvbSBidWZmZXJWaWV3c1xuXG4gICAgY29uc3QgYnVmZmVyVmlld3MgPSB0aGlzLnBhcnNlQnVmZmVyVmlld3MoZ2wsIGRlc2MsIGJ1ZmZlcnMpOyAvLyBDcmVhdGUgZ2VvbWV0cmllcyBmb3IgZWFjaCBtZXNoIHByaW1pdGl2ZVxuXG4gICAgY29uc3QgbWVzaGVzID0gdGhpcy5wYXJzZU1lc2hlcyhnbCwgZGVzYywgYnVmZmVyVmlld3MpOyAvLyBGZXRjaCB0aGUgaW52ZXJzZSBiaW5kIG1hdHJpY2VzIGZvciBza2VsZXRvbiBqb2ludHNcblxuICAgIGNvbnN0IHNraW5zID0gdGhpcy5wYXJzZVNraW5zKGdsLCBkZXNjLCBidWZmZXJWaWV3cyk7IC8vIENyZWF0ZSB0cmFuc2Zvcm1zLCBtZXNoZXMgYW5kIGhpZXJhcmNoeVxuXG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLnBhcnNlTm9kZXMoZ2wsIGRlc2MsIG1lc2hlcywgc2tpbnMpOyAvLyBQbGFjZSBub2RlcyBpbiBza2VsZXRvbnNcblxuICAgIHRoaXMucG9wdWxhdGVTa2lucyhza2lucywgbm9kZXMpOyAvLyBDcmVhdGUgYW5pbWF0aW9uIGhhbmRsZXJzXG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoZ2wsIGRlc2MsIG5vZGVzLCBidWZmZXJWaWV3cyk7IC8vIEdldCB0b3AgbGV2ZWwgbm9kZXMgZm9yIGVhY2ggc2NlbmVcblxuICAgIGNvbnN0IHNjZW5lcyA9IHRoaXMucGFyc2VTY2VuZXMoZGVzYywgbm9kZXMpO1xuICAgIGNvbnN0IHNjZW5lID0gc2NlbmVzW2Rlc2Muc2NlbmVdO1xuICAgIHJldHVybiB7XG4gICAgICBqc29uOiBkZXNjLFxuICAgICAgYnVmZmVycyxcbiAgICAgIGJ1ZmZlclZpZXdzLFxuICAgICAgbWVzaGVzLFxuICAgICAgbm9kZXMsXG4gICAgICBhbmltYXRpb25zLFxuICAgICAgc2NlbmVzLFxuICAgICAgc2NlbmVcbiAgICB9O1xuICB9IC8vIFRocmVlanMgR0xURiBMb2FkZXIgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL21hc3Rlci9leGFtcGxlcy9qcy9sb2FkZXJzL0dMVEZMb2FkZXIuanMjTDEwODVcblxuXG4gIHN0YXRpYyByZXNvbHZlVVJJKHVyaSwgZGlyKSB7XG4gICAgLy8gSW52YWxpZCBVUklcbiAgICBpZiAodHlwZW9mIHVyaSAhPT0gJ3N0cmluZycgfHwgdXJpID09PSAnJykgcmV0dXJuICcnOyAvLyBIb3N0IFJlbGF0aXZlIFVSSVxuXG4gICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QoZGlyKSAmJiAvXlxcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkaXIgPSBkaXIucmVwbGFjZSgvKF5odHRwcz86XFwvXFwvW15cXC9dKykuKi9pLCAnJDEnKTtcbiAgICB9IC8vIEFic29sdXRlIFVSSSBodHRwOi8vLCBodHRwczovLywgLy9cblxuXG4gICAgaWYgKC9eKGh0dHBzPzopP1xcL1xcLy9pLnRlc3QodXJpKSkgcmV0dXJuIHVyaTsgLy8gRGF0YSBVUklcblxuICAgIGlmICgvXmRhdGE6LiosLiokL2kudGVzdCh1cmkpKSByZXR1cm4gdXJpOyAvLyBCbG9iIFVSSVxuXG4gICAgaWYgKC9eYmxvYjouKiQvaS50ZXN0KHVyaSkpIHJldHVybiB1cmk7IC8vIFJlbGF0aXZlIFVSSVxuXG4gICAgcmV0dXJuIGRpciArIHVyaTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBsb2FkQnVmZmVycyhkZXNjLCBkaXIpIHtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoZGVzYy5idWZmZXJzLm1hcChidWZmZXIgPT4ge1xuICAgICAgY29uc3QgdXJpID0gdGhpcy5yZXNvbHZlVVJJKGJ1ZmZlci51cmksIGRpcik7XG4gICAgICByZXR1cm4gZmV0Y2godXJpKS50aGVuKHJlcyA9PiByZXMuYXJyYXlCdWZmZXIoKSk7XG4gICAgfSkpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlQnVmZmVyVmlld3MoZ2wsIGRlc2MsIGJ1ZmZlcnMpIHtcbiAgICAvLyBDbG9uZSB0byBsZWF2ZSBkZXNjcmlwdGlvbiBwdXJlXG4gICAgY29uc3QgYnVmZmVyVmlld3MgPSBkZXNjLmJ1ZmZlclZpZXdzLm1hcChvID0+IE9iamVjdC5hc3NpZ24oe30sIG8pKTtcbiAgICBkZXNjLm1lc2hlcy5mb3JFYWNoKCh7XG4gICAgICBwcmltaXRpdmVzXG4gICAgfSkgPT4ge1xuICAgICAgcHJpbWl0aXZlcy5mb3JFYWNoKCh7XG4gICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgIGluZGljZXNcbiAgICAgIH0pID0+IHtcbiAgICAgICAgLy8gRmxhZyBidWZmZXJWaWV3IGFzIGFuIGF0dHJpYnV0ZSwgc28gaXQga25vd3MgdG8gY3JlYXRlIGEgZ2wgYnVmZmVyXG4gICAgICAgIGZvciAobGV0IGF0dHIgaW4gYXR0cmlidXRlcykgYnVmZmVyVmlld3NbZGVzYy5hY2Nlc3NvcnNbYXR0cmlidXRlc1thdHRyXV0uYnVmZmVyVmlld10uaXNBdHRyaWJ1dGUgPSB0cnVlO1xuXG4gICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgYnVmZmVyVmlld3NbZGVzYy5hY2Nlc3NvcnNbaW5kaWNlc10uYnVmZmVyVmlld10uaXNBdHRyaWJ1dGUgPSB0cnVlOyAvLyBNYWtlIHN1cmUgaW5kaWNlcyBidWZmZXJWaWV3IGhhdmUgYSB0YXJnZXQgcHJvcGVydHkgZm9yIGdsIGJ1ZmZlciBiaW5kaW5nXG5cbiAgICAgICAgYnVmZmVyVmlld3NbZGVzYy5hY2Nlc3NvcnNbaW5kaWNlc10uYnVmZmVyVmlld10udGFyZ2V0ID0gZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgICB9KTtcbiAgICB9KTsgLy8gR2V0IGNvbXBvbmVudFR5cGUgb2YgZWFjaCBidWZmZXJWaWV3IGZyb20gdGhlIGFjY2Vzc29yc1xuXG4gICAgZGVzYy5hY2Nlc3NvcnMuZm9yRWFjaCgoe1xuICAgICAgYnVmZmVyVmlldzogaSxcbiAgICAgIGNvbXBvbmVudFR5cGVcbiAgICB9KSA9PiB7XG4gICAgICBidWZmZXJWaWV3c1tpXS5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICB9KTsgLy8gUHVzaCBlYWNoIGJ1ZmZlclZpZXcgdG8gdGhlIEdQVSBhcyBhIHNlcGFyYXRlIGJ1ZmZlclxuXG4gICAgYnVmZmVyVmlld3MuZm9yRWFjaCgoe1xuICAgICAgYnVmZmVyOiBidWZmZXJJbmRleCxcbiAgICAgIC8vIHJlcXVpcmVkXG4gICAgICBieXRlT2Zmc2V0ID0gMCxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBieXRlTGVuZ3RoLFxuICAgICAgLy8gcmVxdWlyZWRcbiAgICAgIGJ5dGVTdHJpZGUsXG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgdGFyZ2V0ID0gZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgLy8gb3B0aW9uYWwsIGFkZGVkIGFib3ZlIGZvciBlbGVtZW50c1xuICAgICAgbmFtZSxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGV4dHJhcyxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBjb21wb25lbnRUeXBlLFxuICAgICAgLy8gcmVxdWlyZWQsIGFkZGVkIGZyb20gYWNjZXNzb3IgYWJvdmVcbiAgICAgIGlzQXR0cmlidXRlXG4gICAgfSwgaSkgPT4ge1xuICAgICAgY29uc3QgVHlwZUFycmF5ID0gVFlQRV9BUlJBWVtjb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRCeXRlcyA9IFR5cGVBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVHlwZUFycmF5KGJ1ZmZlcnNbYnVmZmVySW5kZXhdLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgIGJ1ZmZlclZpZXdzW2ldLmRhdGEgPSBkYXRhOyAvLyBDcmVhdGUgZ2wgYnVmZmVycyBmb3IgdGhlIGJ1ZmZlclZpZXcsIHB1c2hpbmcgaXQgdG8gdGhlIEdQVVxuXG4gICAgICBpZiAoIWlzQXR0cmlidXRlKSByZXR1cm47XG4gICAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIpO1xuICAgICAgZ2wucmVuZGVyZXIuc3RhdGUuYm91bmRCdWZmZXIgPSBidWZmZXI7XG4gICAgICBnbC5idWZmZXJEYXRhKHRhcmdldCwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgYnVmZmVyVmlld3NbaV0uYnVmZmVyID0gYnVmZmVyO1xuICAgIH0pO1xuICAgIHJldHVybiBidWZmZXJWaWV3cztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1lc2hlcyhnbCwgZGVzYywgYnVmZmVyVmlld3MpIHtcbiAgICByZXR1cm4gZGVzYy5tZXNoZXMubWFwKCh7XG4gICAgICBwcmltaXRpdmVzLFxuICAgICAgLy8gcmVxdWlyZWRcbiAgICAgIHdlaWdodHMsXG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgbmFtZSxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGV4dHJhcyAvLyBvcHRpb25hbFxuXG4gICAgfSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJpbWl0aXZlczogdGhpcy5wYXJzZVByaW1pdGl2ZXMoZ2wsIHByaW1pdGl2ZXMsIGRlc2MsIGJ1ZmZlclZpZXdzKSxcbiAgICAgICAgd2VpZ2h0cyxcbiAgICAgICAgbmFtZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVNraW5zKGdsLCBkZXNjLCBidWZmZXJWaWV3cykge1xuICAgIGlmICghZGVzYy5za2lucykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGRlc2Muc2tpbnMubWFwKCh7XG4gICAgICBpbnZlcnNlQmluZE1hdHJpY2VzLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHNrZWxldG9uLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGpvaW50cyAvLyByZXF1aXJlZFxuICAgICAgLy8gbmFtZSxcbiAgICAgIC8vIGV4dGVuc2lvbnMsXG4gICAgICAvLyBleHRyYXMsXG5cbiAgICB9KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnZlcnNlQmluZE1hdHJpY2VzOiB0aGlzLnBhcnNlQWNjZXNzb3IoaW52ZXJzZUJpbmRNYXRyaWNlcywgZGVzYywgYnVmZmVyVmlld3MpLFxuICAgICAgICBza2VsZXRvbixcbiAgICAgICAgam9pbnRzXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIHBvcHVsYXRlU2tpbnMoc2tpbnMsIG5vZGVzKSB7XG4gICAgaWYgKCFza2lucykgcmV0dXJuO1xuICAgIHNraW5zLmZvckVhY2goc2tpbiA9PiB7XG4gICAgICBza2luLmpvaW50cyA9IHNraW4uam9pbnRzLm1hcCgoaSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qgam9pbnQgPSBub2Rlc1tpXTtcbiAgICAgICAgam9pbnQuYmluZEludmVyc2UgPSBuZXcgTWF0NCguLi5za2luLmludmVyc2VCaW5kTWF0cmljZXMuZGF0YS5zbGljZShpbmRleCAqIDE2LCAoaW5kZXggKyAxKSAqIDE2KSk7XG4gICAgICAgIHJldHVybiBqb2ludDtcbiAgICAgIH0pO1xuICAgICAgc2tpbi5za2VsZXRvbiA9IG5vZGVzW3NraW4uc2tlbGV0b25dO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlUHJpbWl0aXZlcyhnbCwgcHJpbWl0aXZlcywgZGVzYywgYnVmZmVyVmlld3MpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlcy5tYXAoKHtcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAvLyByZXF1aXJlZFxuICAgICAgaW5kaWNlcyxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBtYXRlcmlhbCxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBtb2RlID0gNCxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICB0YXJnZXRzLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgZXh0cmFzIC8vIG9wdGlvbmFsXG5cbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeShnbCk7IC8vIEFkZCBlYWNoIGF0dHJpYnV0ZSBmb3VuZCBpbiBwcmltaXRpdmVcblxuICAgICAgZm9yIChsZXQgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShBVFRSSUJVVEVTW2F0dHJdLCB0aGlzLnBhcnNlQWNjZXNzb3IoYXR0cmlidXRlc1thdHRyXSwgZGVzYywgYnVmZmVyVmlld3MpKTtcbiAgICAgIH0gLy8gQWRkIGluZGV4IGF0dHJpYnV0ZSBpZiBmb3VuZFxuXG5cbiAgICAgIGlmIChpbmRpY2VzICE9PSB1bmRlZmluZWQpIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnaW5kZXgnLCB0aGlzLnBhcnNlQWNjZXNzb3IoaW5kaWNlcywgZGVzYywgYnVmZmVyVmlld3MpKTsgLy8gVE9ETzogbWF0ZXJpYWxzXG5cbiAgICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgTm9ybWFsUHJvZ3JhbShnbCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgbW9kZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUFjY2Vzc29yKGluZGV4LCBkZXNjLCBidWZmZXJWaWV3cykge1xuICAgIC8vIFRPRE86IGluaXQgbWlzc2luZyBidWZmZXJWaWV3IHdpdGggMHNcbiAgICAvLyBUT0RPOiBzdXBwb3J0IHNwYXJzZVxuICAgIGNvbnN0IHtcbiAgICAgIGJ1ZmZlclZpZXc6IGJ1ZmZlclZpZXdJbmRleCxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBieXRlT2Zmc2V0ID0gMCxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBjb21wb25lbnRUeXBlLFxuICAgICAgLy8gcmVxdWlyZWRcbiAgICAgIG5vcm1hbGl6ZWQgPSBmYWxzZSxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBjb3VudCxcbiAgICAgIC8vIHJlcXVpcmVkXG4gICAgICB0eXBlLFxuICAgICAgLy8gcmVxdWlyZWRcbiAgICAgIG1pbixcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBtYXgsXG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgc3BhcnNlIC8vIG9wdGlvbmFsXG4gICAgICAvLyBuYW1lLCAvLyBvcHRpb25hbFxuICAgICAgLy8gZXh0ZW5zaW9ucywgLy8gb3B0aW9uYWxcbiAgICAgIC8vIGV4dHJhcywgLy8gb3B0aW9uYWxcblxuICAgIH0gPSBkZXNjLmFjY2Vzc29yc1tpbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIC8vIGF0dGFjaGVkIGluIHBhcnNlQnVmZmVyVmlld3NcbiAgICAgIGJ1ZmZlcixcbiAgICAgIC8vIHJlcGxhY2VkIHRvIGJlIHRoZSBhY3R1YWwgR0wgYnVmZmVyXG4gICAgICAvLyBieXRlT2Zmc2V0ID0gMCwgLy8gYXBwbGllZCBpbiBwYXJzZUJ1ZmZlclZpZXdzXG4gICAgICAvLyBieXRlTGVuZ3RoLCAvLyBhcHBsaWVkIGluIHBhcnNlQnVmZmVyVmlld3NcbiAgICAgIGJ5dGVTdHJpZGUgPSAwLFxuICAgICAgdGFyZ2V0IC8vIG5hbWUsXG4gICAgICAvLyBleHRlbnNpb25zLFxuICAgICAgLy8gZXh0cmFzLFxuXG4gICAgfSA9IGJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJbmRleF07XG4gICAgY29uc3Qgc2l6ZSA9IFRZUEVfU0laRVt0eXBlXTsgLy8gUmV0dXJuIGF0dHJpYnV0ZSBkYXRhXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIC8vIE9wdGlvbmFsLiBVc2VkIGZvciBjb21wdXRpbmcgYm91bmRzIGlmIG5vIG1pbi9tYXhcbiAgICAgIHNpemUsXG4gICAgICB0eXBlOiBjb21wb25lbnRUeXBlLFxuICAgICAgbm9ybWFsaXplZCxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHN0cmlkZTogYnl0ZVN0cmlkZSxcbiAgICAgIG9mZnNldDogYnl0ZU9mZnNldCxcbiAgICAgIGNvdW50LFxuICAgICAgbWluLFxuICAgICAgbWF4XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU5vZGVzKGdsLCBkZXNjLCBtZXNoZXMsIHNraW5zKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBkZXNjLm5vZGVzLm1hcCgoe1xuICAgICAgY2FtZXJhLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHNraW46IHNraW5JbmRleCxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBtYXRyaXgsXG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgbWVzaDogbWVzaEluZGV4LFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHNjYWxlLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHRyYW5zbGF0aW9uLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIHdlaWdodHMsXG4gICAgICAvLyBvcHRpb25hbFxuICAgICAgbmFtZSxcbiAgICAgIC8vIG9wdGlvbmFsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGV4dHJhcyAvLyBvcHRpb25hbFxuXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICAgIGlmIChuYW1lKSBub2RlLm5hbWUgPSBuYW1lOyAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbnNcblxuICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICBub2RlLm1hdHJpeC5jb3B5KG1hdHJpeCk7XG4gICAgICAgIG5vZGUuZGVjb21wb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocm90YXRpb24pIG5vZGUucXVhdGVybmlvbi5jb3B5KHJvdGF0aW9uKTtcbiAgICAgICAgaWYgKHNjYWxlKSBub2RlLnNjYWxlLmNvcHkoc2NhbGUpO1xuICAgICAgICBpZiAodHJhbnNsYXRpb24pIG5vZGUucG9zaXRpb24uY29weSh0cmFuc2xhdGlvbik7XG4gICAgICB9IC8vIGFkZCBtZXNoIGlmIGluY2x1ZGVkXG5cblxuICAgICAgaWYgKG1lc2hJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lc2hlc1ttZXNoSW5kZXhdLnByaW1pdGl2ZXMuZm9yRWFjaCgoe1xuICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgIHByb2dyYW0sXG4gICAgICAgICAgbW9kZVxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBza2luSW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBza2luID0gbmV3IEdMVEZTa2luKGdsLCB7XG4gICAgICAgICAgICAgIHNrZWxldG9uOiBza2luc1tza2luSW5kZXhdLFxuICAgICAgICAgICAgICBnZW9tZXRyeSxcbiAgICAgICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICAgICAgbW9kZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBza2luLnNldFBhcmVudChub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdsLCB7XG4gICAgICAgICAgICAgIGdlb21ldHJ5LFxuICAgICAgICAgICAgICBwcm9ncmFtLFxuICAgICAgICAgICAgICBtb2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lc2guc2V0UGFyZW50KG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIGRlc2Mubm9kZXMuZm9yRWFjaCgoe1xuICAgICAgY2hpbGRyZW4gPSBbXVxuICAgIH0sIGkpID0+IHtcbiAgICAgIC8vIFNldCBoaWVyYXJjaHkgbm93IGFsbCBub2RlcyBjcmVhdGVkXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkSW5kZXggPT4ge1xuICAgICAgICBub2Rlc1tjaGlsZEluZGV4XS5zZXRQYXJlbnQobm9kZXNbaV0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlQW5pbWF0aW9ucyhnbCwgZGVzYywgbm9kZXMsIGJ1ZmZlclZpZXdzKSB7XG4gICAgaWYgKCFkZXNjLmFuaW1hdGlvbnMpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBkZXNjLmFuaW1hdGlvbnMubWFwKCh7XG4gICAgICBjaGFubmVscyxcbiAgICAgIC8vIHJlcXVpcmVkXG4gICAgICBzYW1wbGVycyxcbiAgICAgIC8vIHJlcXVpcmVkXG4gICAgICBuYW1lIC8vIG9wdGlvbmFsXG4gICAgICAvLyBleHRlbnNpb25zLCAvLyBvcHRpb25hbFxuICAgICAgLy8gZXh0cmFzLCAgLy8gb3B0aW9uYWxcblxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBjaGFubmVscy5tYXAoKHtcbiAgICAgICAgc2FtcGxlcjogc2FtcGxlckluZGV4LFxuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0YXJnZXQgLy8gcmVxdWlyZWRcbiAgICAgICAgLy8gZXh0ZW5zaW9ucywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gZXh0cmFzLCAvLyBvcHRpb25hbFxuXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbnB1dDogaW5wdXRJbmRleCxcbiAgICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICAgIGludGVycG9sYXRpb24gPSAnTElORUFSJyxcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dEluZGV4IC8vIHJlcXVpcmVkXG4gICAgICAgICAgLy8gZXh0ZW5zaW9ucywgLy8gb3B0aW9uYWxcbiAgICAgICAgICAvLyBleHRyYXMsIC8vIG9wdGlvbmFsXG5cbiAgICAgICAgfSA9IHNhbXBsZXJzW3NhbXBsZXJJbmRleF07XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBub2RlOiBub2RlSW5kZXgsXG4gICAgICAgICAgLy8gb3B0aW9uYWwgLSBUT0RPOiB3aGVuIGlzIGl0IG5vdCBpbmNsdWRlZD9cbiAgICAgICAgICBwYXRoIC8vIHJlcXVpcmVkXG4gICAgICAgICAgLy8gZXh0ZW5zaW9ucywgLy8gb3B0aW9uYWxcbiAgICAgICAgICAvLyBleHRyYXMsIC8vIG9wdGlvbmFsXG5cbiAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW25vZGVJbmRleF07XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IFRSQU5TRk9STVNbcGF0aF07XG4gICAgICAgIGNvbnN0IHRpbWVzQWNjID0gdGhpcy5wYXJzZUFjY2Vzc29yKGlucHV0SW5kZXgsIGRlc2MsIGJ1ZmZlclZpZXdzKTtcbiAgICAgICAgY29uc3QgdGltZXMgPSB0aW1lc0FjYy5kYXRhLnNsaWNlKHRpbWVzQWNjLm9mZnNldCAvIDQsIHRpbWVzQWNjLm9mZnNldCAvIDQgKyB0aW1lc0FjYy5jb3VudCAqIHRpbWVzQWNjLnNpemUpO1xuICAgICAgICBjb25zdCB2YWx1ZXNBY2MgPSB0aGlzLnBhcnNlQWNjZXNzb3Iob3V0cHV0SW5kZXgsIGRlc2MsIGJ1ZmZlclZpZXdzKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWVzQWNjLmRhdGEuc2xpY2UodmFsdWVzQWNjLm9mZnNldCAvIDQsIHZhbHVlc0FjYy5vZmZzZXQgLyA0ICsgdmFsdWVzQWNjLmNvdW50ICogdmFsdWVzQWNjLnNpemUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgIGludGVycG9sYXRpb24sXG4gICAgICAgICAgdGltZXMsXG4gICAgICAgICAgdmFsdWVzXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGFuaW1hdGlvbjogbmV3IEdMVEZBbmltYXRpb24oZGF0YSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VTY2VuZXMoZGVzYywgbm9kZXMpIHtcbiAgICByZXR1cm4gZGVzYy5zY2VuZXMubWFwKCh7XG4gICAgICBub2Rlczogbm9kZXNJbmRpY2VzID0gW10sXG4gICAgICBuYW1lLFxuICAgICAgLy8gb3B0aW9uYWxcbiAgICAgIGV4dGVuc2lvbnMsXG4gICAgICBleHRyYXNcbiAgICB9KSA9PiB7XG4gICAgICByZXR1cm4gbm9kZXNJbmRpY2VzLm1hcChpID0+IG5vZGVzW2ldKTtcbiAgICB9KTtcbiAgfVxuXG59IiwiLy8gQ29yZVxuZXhwb3J0IHsgR2VvbWV0cnkgfSBmcm9tICcuL2NvcmUvR2VvbWV0cnkuanMnO1xuZXhwb3J0IHsgUHJvZ3JhbSB9IGZyb20gJy4vY29yZS9Qcm9ncmFtLmpzJztcbmV4cG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnLi9jb3JlL1JlbmRlcmVyLmpzJztcbmV4cG9ydCB7IENhbWVyYSB9IGZyb20gJy4vY29yZS9DYW1lcmEuanMnO1xuZXhwb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnLi9jb3JlL1RyYW5zZm9ybS5qcyc7XG5leHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9jb3JlL01lc2guanMnO1xuZXhwb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vY29yZS9UZXh0dXJlLmpzJztcbmV4cG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xuXG4vLyBNYXRoc1xuZXhwb3J0IHsgQ29sb3IgfSBmcm9tICcuL21hdGgvQ29sb3IuanMnO1xuZXhwb3J0IHsgRXVsZXIgfSBmcm9tICcuL21hdGgvRXVsZXIuanMnO1xuZXhwb3J0IHsgTWF0MyB9IGZyb20gJy4vbWF0aC9NYXQzLmpzJztcbmV4cG9ydCB7IE1hdDQgfSBmcm9tICcuL21hdGgvTWF0NC5qcyc7XG5leHBvcnQgeyBRdWF0IH0gZnJvbSAnLi9tYXRoL1F1YXQuanMnO1xuZXhwb3J0IHsgVmVjMiB9IGZyb20gJy4vbWF0aC9WZWMyLmpzJztcbmV4cG9ydCB7IFZlYzMgfSBmcm9tICcuL21hdGgvVmVjMy5qcyc7XG5leHBvcnQgeyBWZWM0IH0gZnJvbSAnLi9tYXRoL1ZlYzQuanMnO1xuXG4vLyBFeHRyYXNcbmV4cG9ydCB7IFBsYW5lIH0gZnJvbSAnLi9leHRyYXMvUGxhbmUuanMnO1xuZXhwb3J0IHsgQm94IH0gZnJvbSAnLi9leHRyYXMvQm94LmpzJztcbmV4cG9ydCB7IFNwaGVyZSB9IGZyb20gJy4vZXh0cmFzL1NwaGVyZS5qcyc7XG5leHBvcnQgeyBDeWxpbmRlciB9IGZyb20gJy4vZXh0cmFzL0N5bGluZGVyLmpzJztcbmV4cG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi9leHRyYXMvVHJpYW5nbGUuanMnO1xuZXhwb3J0IHsgVG9ydXMgfSBmcm9tICcuL2V4dHJhcy9Ub3J1cy5qcyc7XG5leHBvcnQgeyBPcmJpdCB9IGZyb20gJy4vZXh0cmFzL09yYml0LmpzJztcbmV4cG9ydCB7IFJheWNhc3QgfSBmcm9tICcuL2V4dHJhcy9SYXljYXN0LmpzJztcbmV4cG9ydCB7IEN1cnZlIH0gZnJvbSAnLi9leHRyYXMvQ3VydmUuanMnO1xuZXhwb3J0IHsgUG9zdCB9IGZyb20gJy4vZXh0cmFzL1Bvc3QuanMnO1xuZXhwb3J0IHsgU2tpbiB9IGZyb20gJy4vZXh0cmFzL1NraW4uanMnO1xuZXhwb3J0IHsgQW5pbWF0aW9uIH0gZnJvbSAnLi9leHRyYXMvQW5pbWF0aW9uLmpzJztcbmV4cG9ydCB7IFRleHQgfSBmcm9tICcuL2V4dHJhcy9UZXh0LmpzJztcbmV4cG9ydCB7IE5vcm1hbFByb2dyYW0gfSBmcm9tICcuL2V4dHJhcy9Ob3JtYWxQcm9ncmFtLmpzJztcbmV4cG9ydCB7IEZsb3dtYXAgfSBmcm9tICcuL2V4dHJhcy9GbG93bWFwLmpzJztcbmV4cG9ydCB7IEdQR1BVIH0gZnJvbSAnLi9leHRyYXMvR1BHUFUuanMnO1xuZXhwb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL2V4dHJhcy9Qb2x5bGluZS5qcyc7XG5leHBvcnQgeyBTaGFkb3cgfSBmcm9tICcuL2V4dHJhcy9TaGFkb3cuanMnO1xuZXhwb3J0IHsgS1RYVGV4dHVyZSB9IGZyb20gJy4vZXh0cmFzL0tUWFRleHR1cmUuanMnO1xuZXhwb3J0IHsgVGV4dHVyZUxvYWRlciB9IGZyb20gJy4vZXh0cmFzL1RleHR1cmVMb2FkZXIuanMnO1xuZXhwb3J0IHsgR0xURkxvYWRlciB9IGZyb20gJy4vZXh0cmFzL0dMVEZMb2FkZXIuanMnO1xuIiwiZXhwb3J0IGNvbnN0IHZlcnRleCA9IGBcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gIGF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xuICBhdHRyaWJ1dGUgdmVjMyBub3JtYWw7XG4gIHVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XG4gIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xuICB1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcbiAgdW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcbiAgdW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1xuXG4gIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xuICB2YXJ5aW5nIHZlYzMgdlBvcztcbiAgdmFyeWluZyB2ZWMzIHZDYW1lcmFQb3M7XG5cbiAgdm9pZCBtYWluKCkge1xuICAgIHZlYzQgcG9zID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbiAgICB2UG9zID0gcG9zLnh5ejtcbiAgICB2Q2FtZXJhUG9zID0gKHZpZXdNYXRyaXggKiB2ZWM0KGNhbWVyYVBvc2l0aW9uLCAxLjApKS54eXo7XG4gICAgdk5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBub3JtYWwpO1xuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHBvcztcbiAgfVxuYDtcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IGBcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gICNkZWZpbmUgTUFYX0xJR0hUX0NPVU5UIDE2XG4gIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xuXG4gIHVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHQ7XG4gIHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW01BWF9MSUdIVF9DT1VOVF07XG4gIHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbTUFYX0xJR0hUX0NPVU5UXTtcbiAgdW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvcltNQVhfTElHSFRfQ09VTlRdO1xuICB1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uW01BWF9MSUdIVF9DT1VOVF07XG4gIHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0RGVjYXlbTUFYX0xJR0hUX0NPVU5UXTtcbiAgdW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yW01BWF9MSUdIVF9DT1VOVF07XG4gIHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bTUFYX0xJR0hUX0NPVU5UXTtcbiAgdW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uW01BWF9MSUdIVF9DT1VOVF07XG4gIHVuaWZvcm0gdmVjMyBzcG90TGlnaHREZWNheVtNQVhfTElHSFRfQ09VTlRdO1xuICB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlW01BWF9MSUdIVF9DT1VOVF07XG5cbiAgdW5pZm9ybSB2ZWMzIG1hdGVyaWFsUmVmbGVjdGlvbjtcbiAgdW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XG4gIHVuaWZvcm0gZmxvYXQgc3BlY3VsYXJGYWN0b3I7XG5cbiAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XG4gIHZhcnlpbmcgdmVjMyB2UG9zO1xuICB2YXJ5aW5nIHZlYzMgdkNhbWVyYVBvcztcblxuICBmbG9hdCBnZXRTcGVjdWxhcih2ZWMzIGRpciwgdmVjMyBub3JtYWwsIHZlYzMgZXllKSB7XG4gICAgdmVjMyByZWZsZWN0aW9uTGlnaHQgPSByZWZsZWN0KC1kaXIsIG5vcm1hbCk7XG4gICAgZmxvYXQgZXllQ29zID0gbWF4KGRvdChleWUsIHJlZmxlY3Rpb25MaWdodCksIDAuMCk7XG4gICAgcmV0dXJuIHNwZWN1bGFyRmFjdG9yICogIHBvdyhleWVDb3MsIHNoaW5pbmVzcyk7XG4gIH1cblxuICB2ZWM0IHBob25nUmVmbGVjdGlvbih2ZWMzIHBvcywgdmVjMyBub3JtYWwsIHZlYzMgZXllKSB7XG4gICAgZmxvYXQgc3BlY3VsYXIgPSAwLjA7XG4gICAgdmVjMyBkaWZmdXNlID0gdmVjMygwKTtcbiAgICBcbiAgICAvLyDlpITnkIblubPooYzlhYlcbiAgICBmb3IoaW50IGkgPSAwOyBpIDwgTUFYX0xJR0hUX0NPVU5UOyBpKyspIHtcbiAgICAgIHZlYzMgZGlyID0gZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbltpXTtcbiAgICAgIGlmKGRpci54ID09IDAuMCAmJiBkaXIueSA9PSAwLjAgJiYgZGlyLnogPT0gMC4wKSBjb250aW51ZTtcbiAgICAgIHZlYzQgZCA9IHZpZXdNYXRyaXggKiB2ZWM0KGRpciwgMC4wKTtcbiAgICAgIGRpciA9IG5vcm1hbGl6ZSgtZC54eXopO1xuICAgICAgZmxvYXQgY29zID0gbWF4KGRvdChkaXIsIG5vcm1hbCksIDAuMCk7XG4gICAgICBkaWZmdXNlICs9IGNvcyAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvcltpXTtcbiAgICAgIHNwZWN1bGFyICs9IGdldFNwZWN1bGFyKGRpciwgbm9ybWFsLCBleWUpO1xuICAgIH1cblxuICAgIC8vIOWkhOeQhueCueWFiea6kFxuICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfTElHSFRfQ09VTlQ7IGkrKykge1xuICAgICAgdmVjMyBkZWNheSA9IHBvaW50TGlnaHREZWNheVtpXTtcbiAgICAgIGlmKGRlY2F5LnggPT0gMC4wICYmIGRlY2F5LnkgPT0gMC4wICYmIGRlY2F5LnogPT0gMC4wKSBjb250aW51ZTtcbiAgICAgIHZlYzMgZGlyID0gKHZpZXdNYXRyaXggKiB2ZWM0KHBvaW50TGlnaHRQb3NpdGlvbltpXSwgMS4wKSkueHl6IC0gcG9zO1xuICAgICAgZmxvYXQgZGlzID0gbGVuZ3RoKGRpcik7XG4gICAgICBkaXIgPSBub3JtYWxpemUoZGlyKTtcbiAgICAgIGZsb2F0IGNvcyA9IG1heChkb3QoZGlyLCBub3JtYWwpLCAwLjApO1xuICAgICAgZmxvYXQgZCA9IG1pbigxLjAsIDEuMCAvIChkZWNheS54ICogcG93KGRpcywgMi4wKSArIGRlY2F5LnkgKiBkaXMgKyBkZWNheS56KSk7XG4gICAgICBkaWZmdXNlICs9IGQgKiBjb3MgKiBwb2ludExpZ2h0Q29sb3JbaV07XG4gICAgICBzcGVjdWxhciArPSBnZXRTcGVjdWxhcihkaXIsIG5vcm1hbCwgZXllKTtcbiAgICB9XG5cbiAgICAvLyDlpITnkIbogZrlhYnnga9cbiAgICBmb3IoaW50IGkgPSAwOyBpIDwgTUFYX0xJR0hUX0NPVU5UOyBpKyspIHtcbiAgICAgIHZlYzMgZGVjYXkgPSBzcG90TGlnaHREZWNheVtpXTtcbiAgICAgIGlmKGRlY2F5LnggPT0gMC4wICYmIGRlY2F5LnkgPT0gMC4wICYmIGRlY2F5LnogPT0gMC4wKSBjb250aW51ZTtcblxuICAgICAgdmVjMyBkaXIgPSAodmlld01hdHJpeCAqIHZlYzQoc3BvdExpZ2h0UG9zaXRpb25baV0sIDEuMCkpLnh5eiAtIHBvcztcbiAgICAgIGZsb2F0IGRpcyA9IGxlbmd0aChkaXIpO1xuICAgICAgZGlyID0gbm9ybWFsaXplKGRpcik7XG5cbiAgICAgIC8vIOiBmuWFieeBr+eahOacneWQkVxuICAgICAgdmVjMyBzcG90RGlyID0gKHZpZXdNYXRyaXggKiB2ZWM0KHNwb3RMaWdodERpcmVjdGlvbltpXSwgMC4wKSkueHl6O1xuICAgICAgLy8g6YCa6L+H5L2Z5bym5YC85Yik5pat5aS56KeS6IyD5Zu0XG4gICAgICBmbG9hdCBhbmcgPSBjb3Moc3BvdExpZ2h0QW5nbGVbaV0pO1xuICAgICAgZmxvYXQgciA9IHN0ZXAoYW5nLCBkb3QoZGlyLCBub3JtYWxpemUoLXNwb3REaXIpKSk7XG5cbiAgICAgIGZsb2F0IGNvcyA9IG1heChkb3QoZGlyLCBub3JtYWwpLCAwLjApO1xuICAgICAgZmxvYXQgZCA9IG1pbigxLjAsIDEuMCAvIChkZWNheS54ICogcG93KGRpcywgMi4wKSArIGRlY2F5LnkgKiBkaXMgKyBkZWNheS56KSk7XG4gICAgICBkaWZmdXNlICs9IHIgKiBkICogY29zICogc3BvdExpZ2h0Q29sb3JbaV07XG4gICAgICBzcGVjdWxhciArPSByICogZ2V0U3BlY3VsYXIoZGlyLCBub3JtYWwsIGV5ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlYzQoZGlmZnVzZSwgc3BlY3VsYXIpO1xuICB9XG5cbiAgdm9pZCBtYWluKCkge1xuICAgIHZlYzMgZXllRGlyZWN0aW9uID0gbm9ybWFsaXplKHZDYW1lcmFQb3MgLSB2UG9zKTtcbiAgICB2ZWM0IHBob25nID0gcGhvbmdSZWZsZWN0aW9uKHZQb3MsIHZOb3JtYWwsIGV5ZURpcmVjdGlvbik7XG5cbiAgICAvLyDlkIjmiJDpopzoibJcbiAgICBnbF9GcmFnQ29sb3IucmdiID0gcGhvbmcudyArIChwaG9uZy54eXogKyBhbWJpZW50TGlnaHQpICogbWF0ZXJpYWxSZWZsZWN0aW9uO1xuICAgIGdsX0ZyYWdDb2xvci5hID0gMS4wO1xuICB9XG5gO1xuZXhwb3J0IGNsYXNzIFBob25nIHtcbiAgY29uc3RydWN0b3IoYW1iaWVudExpZ2h0ID0gWzAuNSwgMC41LCAwLjVdKSB7XG4gICAgdGhpcy5hbWJpZW50TGlnaHQgPSBhbWJpZW50TGlnaHQ7XG4gICAgdGhpcy5kaXJlY3Rpb25hbExpZ2h0cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnBvaW50TGlnaHRzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3BvdExpZ2h0cyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIGFkZExpZ2h0KGxpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBjb2xvcixcbiAgICAgIGRlY2F5LFxuICAgICAgYW5nbGVcbiAgICB9ID0gbGlnaHQ7XG4gICAgaWYgKCFwb3NpdGlvbiAmJiAhZGlyZWN0aW9uKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGxpZ2h0Jyk7XG4gICAgbGlnaHQuY29sb3IgPSBjb2xvciB8fCBbMSwgMSwgMV07XG4gICAgaWYgKCFwb3NpdGlvbikgdGhpcy5kaXJlY3Rpb25hbExpZ2h0cy5hZGQobGlnaHQpO2Vsc2Uge1xuICAgICAgbGlnaHQuZGVjYXkgPSBkZWNheSB8fCBbMCwgMCwgMV07XG5cbiAgICAgIGlmICghYW5nbGUpIHtcbiAgICAgICAgdGhpcy5wb2ludExpZ2h0cy5hZGQobGlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zcG90TGlnaHRzLmFkZChsaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlTGlnaHQobGlnaHQpIHtcbiAgICBpZiAodGhpcy5kaXJlY3Rpb25hbExpZ2h0cy5oYXMobGlnaHQpKSB0aGlzLmRpcmVjdGlvbmFsTGlnaHRzLmRlbGV0ZShsaWdodCk7ZWxzZSBpZiAodGhpcy5wb2ludExpZ2h0cy5oYXMobGlnaHQpKSB0aGlzLnBvaW50TGlnaHRzLmRlbGV0ZShsaWdodCk7ZWxzZSBpZiAodGhpcy5zcG90TGlnaHRzLmhhcyhsaWdodCkpIHRoaXMuc3BvdExpZ2h0cy5kZWxldGUobGlnaHQpO1xuICB9XG5cbiAgZ2V0IHVuaWZvcm1zKCkge1xuICAgIGNvbnN0IE1BWF9MSUdIVF9DT1VOVCA9IDE2OyAvLyDmnIDlpJrmr4/np43lhYnmupDorr7nva4xNuS4qlxuXG4gICAgdGhpcy5fbGlnaHREYXRhID0gdGhpcy5fbGlnaHREYXRhIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0RGF0YSA9IHRoaXMuX2xpZ2h0RGF0YTtcbiAgICBsaWdodERhdGEuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbiA9IGxpZ2h0RGF0YS5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uIHx8IHtcbiAgICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KE1BWF9MSUdIVF9DT1VOVCAqIDMpXG4gICAgfTtcbiAgICBsaWdodERhdGEuZGlyZWN0aW9uYWxMaWdodENvbG9yID0gbGlnaHREYXRhLmRpcmVjdGlvbmFsTGlnaHRDb2xvciB8fCB7XG4gICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShNQVhfTElHSFRfQ09VTlQgKiAzKVxuICAgIH07XG4gICAgbGlnaHREYXRhLnBvaW50TGlnaHRQb3NpdGlvbiA9IGxpZ2h0RGF0YS5wb2ludExpZ2h0UG9zaXRpb24gfHwge1xuICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoTUFYX0xJR0hUX0NPVU5UICogMylcbiAgICB9O1xuICAgIGxpZ2h0RGF0YS5wb2ludExpZ2h0Q29sb3IgPSBsaWdodERhdGEucG9pbnRMaWdodENvbG9yIHx8IHtcbiAgICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KE1BWF9MSUdIVF9DT1VOVCAqIDMpXG4gICAgfTtcbiAgICBsaWdodERhdGEucG9pbnRMaWdodERlY2F5ID0gbGlnaHREYXRhLnBvaW50TGlnaHREZWNheSB8fCB7XG4gICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShNQVhfTElHSFRfQ09VTlQgKiAzKVxuICAgIH07XG4gICAgbGlnaHREYXRhLnNwb3RMaWdodERpcmVjdGlvbiA9IGxpZ2h0RGF0YS5zcG90TGlnaHREaXJlY3Rpb24gfHwge1xuICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoTUFYX0xJR0hUX0NPVU5UICogMylcbiAgICB9O1xuICAgIGxpZ2h0RGF0YS5zcG90TGlnaHRQb3NpdGlvbiA9IGxpZ2h0RGF0YS5zcG90TGlnaHRQb3NpdGlvbiB8fCB7XG4gICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShNQVhfTElHSFRfQ09VTlQgKiAzKVxuICAgIH07XG4gICAgbGlnaHREYXRhLnNwb3RMaWdodENvbG9yID0gbGlnaHREYXRhLnNwb3RMaWdodENvbG9yIHx8IHtcbiAgICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KE1BWF9MSUdIVF9DT1VOVCAqIDMpXG4gICAgfTtcbiAgICBsaWdodERhdGEuc3BvdExpZ2h0RGVjYXkgPSBsaWdodERhdGEuc3BvdExpZ2h0RGVjYXkgfHwge1xuICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoTUFYX0xJR0hUX0NPVU5UICogMylcbiAgICB9O1xuICAgIGxpZ2h0RGF0YS5zcG90TGlnaHRBbmdsZSA9IGxpZ2h0RGF0YS5zcG90TGlnaHRBbmdsZSB8fCB7XG4gICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShNQVhfTElHSFRfQ09VTlQpXG4gICAgfTtcbiAgICBbLi4udGhpcy5kaXJlY3Rpb25hbExpZ2h0c10uZm9yRWFjaCgobGlnaHQsIGlkeCkgPT4ge1xuICAgICAgbGlnaHREYXRhLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24udmFsdWUuc2V0KGxpZ2h0LmRpcmVjdGlvbiwgaWR4ICogMyk7XG4gICAgICBsaWdodERhdGEuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlLnNldChsaWdodC5jb2xvciwgaWR4ICogMyk7XG4gICAgfSk7XG4gICAgWy4uLnRoaXMucG9pbnRMaWdodHNdLmZvckVhY2goKGxpZ2h0LCBpZHgpID0+IHtcbiAgICAgIGxpZ2h0RGF0YS5wb2ludExpZ2h0UG9zaXRpb24udmFsdWUuc2V0KGxpZ2h0LnBvc2l0aW9uLCBpZHggKiAzKTtcbiAgICAgIGxpZ2h0RGF0YS5wb2ludExpZ2h0Q29sb3IudmFsdWUuc2V0KGxpZ2h0LmNvbG9yLCBpZHggKiAzKTtcbiAgICAgIGxpZ2h0RGF0YS5wb2ludExpZ2h0RGVjYXkudmFsdWUuc2V0KGxpZ2h0LmRlY2F5LCBpZHggKiAzKTtcbiAgICB9KTtcbiAgICBbLi4udGhpcy5zcG90TGlnaHRzXS5mb3JFYWNoKChsaWdodCwgaWR4KSA9PiB7XG4gICAgICBsaWdodERhdGEuc3BvdExpZ2h0UG9zaXRpb24udmFsdWUuc2V0KGxpZ2h0LnBvc2l0aW9uLCBpZHggKiAzKTtcbiAgICAgIGxpZ2h0RGF0YS5zcG90TGlnaHRDb2xvci52YWx1ZS5zZXQobGlnaHQuY29sb3IsIGlkeCAqIDMpO1xuICAgICAgbGlnaHREYXRhLnNwb3RMaWdodERlY2F5LnZhbHVlLnNldChsaWdodC5kZWNheSwgaWR4ICogMyk7XG4gICAgICBsaWdodERhdGEuc3BvdExpZ2h0RGlyZWN0aW9uLnZhbHVlLnNldChsaWdodC5kaXJlY3Rpb24sIGlkeCAqIDMpO1xuICAgICAgbGlnaHREYXRhLnNwb3RMaWdodEFuZ2xlLnZhbHVlW2lkeF0gPSBsaWdodC5hbmdsZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYW1iaWVudExpZ2h0OiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmFtYmllbnRMaWdodFxuICAgICAgfSxcbiAgICAgIC4uLmxpZ2h0RGF0YVxuICAgIH07XG4gIH1cblxufVxuZXhwb3J0IGNsYXNzIE1hdGVyaWFsIHtcbiAgY29uc3RydWN0b3IocmVmbGVjdGlvbiwgc3BlY3VsYXJGYWN0b3IgPSAwLCBzaGluaW5lc3MgPSA1MCkge1xuICAgIHRoaXMucmVmbGVjdGlvbiA9IHJlZmxlY3Rpb247XG4gICAgdGhpcy5zcGVjdWxhckZhY3RvciA9IHNwZWN1bGFyRmFjdG9yO1xuICAgIHRoaXMuc2hpbmluZXNzID0gc2hpbmluZXNzO1xuICB9XG5cbiAgZ2V0IHVuaWZvcm1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRlcmlhbFJlZmxlY3Rpb246IHtcbiAgICAgICAgdmFsdWU6IHRoaXMucmVmbGVjdGlvblxuICAgICAgfSxcbiAgICAgIHNwZWN1bGFyRmFjdG9yOiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnNwZWN1bGFyRmFjdG9yXG4gICAgICB9LFxuICAgICAgc2hpbmluZXNzOiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnNoaW5pbmVzc1xuICAgICAgfVxuICAgIH07XG4gIH1cblxufSIsImltcG9ydCB7IFJlbmRlcmVyLCBDYW1lcmEsIFRyYW5zZm9ybSwgUHJvZ3JhbSwgQm94LCBNZXNoLCBPcmJpdCwgQ29sb3IsIFRleHR1cmUsIFZlYzMsIFZlYzIgfSBmcm9tICcuLi8uLi9jb21tb24vbGliL29nbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgUGhvbmcsIE1hdGVyaWFsLCB2ZXJ0ZXggYXMgdiwgZnJhZ21lbnQgYXMgZiB9IGZyb20gJy4uLy4uL2NvbW1vbi9saWIvcGhvbmcuanMnO1xuZXhwb3J0IGNvbnN0IHZlcnRleCA9IGAjdmVyc2lvbiAzMDAgZXNcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG4gIGluIHZlYzMgcG9zaXRpb247XG4gIGluIHZlYzMgbm9ybWFsO1xuICBpbiB2ZWMyIHV2O1xuICBpbiB2ZWMzIHRhbmc7XG4gIGluIHZlYzMgYml0YW5nO1xuXG4gIHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcbiAgdW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcbiAgdW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XG4gIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xuICB1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4O1xuICB1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XG5cbiAgb3V0IHZlYzMgdk5vcm1hbDtcbiAgb3V0IHZlYzMgdlBvcztcbiAgb3V0IHZlYzIgdlV2O1xuICBvdXQgdmVjMyB2Q2FtZXJhUG9zO1xuICBvdXQgbWF0MyB2VEJOO1xuXG4gIHZvaWQgbWFpbigpIHtcbiAgICB2ZWM0IHBvcyA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgdlBvcyA9IHBvcy54eXo7XG4gICAgdlV2ID0gdXY7XG4gICAgdkNhbWVyYVBvcyA9ICh2aWV3TWF0cml4ICogdmVjNChjYW1lcmFQb3NpdGlvbiwgMS4wKSkueHl6O1xuICAgIHZOb3JtYWwgPSBub3JtYWxpemUobm9ybWFsTWF0cml4ICogbm9ybWFsKTtcblxuICAgIHZlYzMgTiA9IHZOb3JtYWw7XG4gICAgdmVjMyBUID0gbm9ybWFsaXplKG5vcm1hbE1hdHJpeCAqIHRhbmcpO1xuICAgIHZlYzMgQiA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBiaXRhbmcpO1xuXG4gICAgdlRCTiA9IG1hdDMoVCwgQiwgTik7XG4gICAgXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogcG9zO1xuICB9XG5gO1xuY29uc3QgZnJhZ21lbnQgPSBgI3ZlcnNpb24gMzAwIGVzXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblxuICAjZGVmaW5lIE1BWF9MSUdIVF9DT1VOVCAxNlxuICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcblxuICB1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0O1xuICB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbltNQVhfTElHSFRfQ09VTlRdO1xuICB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yW01BWF9MSUdIVF9DT1VOVF07XG4gIHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbTUFYX0xJR0hUX0NPVU5UXTtcbiAgdW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvbltNQVhfTElHSFRfQ09VTlRdO1xuICB1bmlmb3JtIHZlYzMgcG9pbnRMaWdodERlY2F5W01BWF9MSUdIVF9DT1VOVF07XG4gIHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvcltNQVhfTElHSFRfQ09VTlRdO1xuICB1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uW01BWF9MSUdIVF9DT1VOVF07XG4gIHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvbltNQVhfTElHSFRfQ09VTlRdO1xuICB1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGVjYXlbTUFYX0xJR0hUX0NPVU5UXTtcbiAgdW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZVtNQVhfTElHSFRfQ09VTlRdO1xuXG4gIHVuaWZvcm0gdmVjMyBtYXRlcmlhbFJlZmxlY3Rpb247XG4gIHVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xuICB1bmlmb3JtIGZsb2F0IHNwZWN1bGFyRmFjdG9yO1xuXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHROb3JtYWw7XG5cbiAgaW4gdmVjMyB2Tm9ybWFsO1xuICBpbiB2ZWMzIHZQb3M7XG4gIGluIHZlYzIgdlV2O1xuICBpbiB2ZWMzIHZDYW1lcmFQb3M7XG4gIGluIG1hdDMgdlRCTjtcblxuICBvdXQgdmVjNCBGcmFnQ29sb3I7XG5cbiAgZmxvYXQgZ2V0U3BlY3VsYXIodmVjMyBkaXIsIHZlYzMgbm9ybWFsLCB2ZWMzIGV5ZSkge1xuICAgIHZlYzMgcmVmbGVjdGlvbkxpZ2h0ID0gcmVmbGVjdCgtZGlyLCBub3JtYWwpO1xuICAgIGZsb2F0IGV5ZUNvcyA9IG1heChkb3QoZXllLCByZWZsZWN0aW9uTGlnaHQpLCAwLjApO1xuICAgIHJldHVybiBzcGVjdWxhckZhY3RvciAqICBwb3coZXllQ29zLCBzaGluaW5lc3MpO1xuICB9XG5cbiAgdmVjNCBwaG9uZ1JlZmxlY3Rpb24odmVjMyBwb3MsIHZlYzMgbm9ybWFsLCB2ZWMzIGV5ZSkge1xuICAgIGZsb2F0IHNwZWN1bGFyID0gMC4wO1xuICAgIHZlYzMgZGlmZnVzZSA9IHZlYzMoMCk7XG4gICAgXG4gICAgLy8g5aSE55CG5bmz6KGM5YWJXG4gICAgZm9yKGludCBpID0gMDsgaSA8IE1BWF9MSUdIVF9DT1VOVDsgaSsrKSB7XG4gICAgICB2ZWMzIGRpciA9IGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25baV07XG4gICAgICBpZihkaXIueCA9PSAwLjAgJiYgZGlyLnkgPT0gMC4wICYmIGRpci56ID09IDAuMCkgY29udGludWU7XG4gICAgICB2ZWM0IGQgPSB2aWV3TWF0cml4ICogdmVjNChkaXIsIDAuMCk7XG4gICAgICBkaXIgPSBub3JtYWxpemUoLWQueHl6KTtcbiAgICAgIGZsb2F0IGNvcyA9IG1heChkb3QoZGlyLCBub3JtYWwpLCAwLjApO1xuICAgICAgZGlmZnVzZSArPSBjb3MgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbaV07XG4gICAgICBzcGVjdWxhciArPSBnZXRTcGVjdWxhcihkaXIsIG5vcm1hbCwgZXllKTtcbiAgICB9XG5cbiAgICAvLyDlpITnkIbngrnlhYnmupBcbiAgICBmb3IoaW50IGkgPSAwOyBpIDwgTUFYX0xJR0hUX0NPVU5UOyBpKyspIHtcbiAgICAgIHZlYzMgZGVjYXkgPSBwb2ludExpZ2h0RGVjYXlbaV07XG4gICAgICBpZihkZWNheS54ID09IDAuMCAmJiBkZWNheS55ID09IDAuMCAmJiBkZWNheS56ID09IDAuMCkgY29udGludWU7XG4gICAgICB2ZWMzIGRpciA9ICh2aWV3TWF0cml4ICogdmVjNChwb2ludExpZ2h0UG9zaXRpb25baV0sIDEuMCkpLnh5eiAtIHBvcztcbiAgICAgIGZsb2F0IGRpcyA9IGxlbmd0aChkaXIpO1xuICAgICAgZGlyID0gbm9ybWFsaXplKGRpcik7XG4gICAgICBmbG9hdCBjb3MgPSBtYXgoZG90KGRpciwgbm9ybWFsKSwgMC4wKTtcbiAgICAgIGZsb2F0IGQgPSBtaW4oMS4wLCAxLjAgLyAoZGVjYXkueCAqIHBvdyhkaXMsIDIuMCkgKyBkZWNheS55ICogZGlzICsgZGVjYXkueikpO1xuICAgICAgZGlmZnVzZSArPSBkICogY29zICogcG9pbnRMaWdodENvbG9yW2ldO1xuICAgICAgc3BlY3VsYXIgKz0gZ2V0U3BlY3VsYXIoZGlyLCBub3JtYWwsIGV5ZSk7XG4gICAgfVxuXG4gICAgLy8g5aSE55CG6IGa5YWJ54GvXG4gICAgZm9yKGludCBpID0gMDsgaSA8IE1BWF9MSUdIVF9DT1VOVDsgaSsrKSB7XG4gICAgICB2ZWMzIGRlY2F5ID0gc3BvdExpZ2h0RGVjYXlbaV07XG4gICAgICBpZihkZWNheS54ID09IDAuMCAmJiBkZWNheS55ID09IDAuMCAmJiBkZWNheS56ID09IDAuMCkgY29udGludWU7XG5cbiAgICAgIHZlYzMgZGlyID0gKHZpZXdNYXRyaXggKiB2ZWM0KHNwb3RMaWdodFBvc2l0aW9uW2ldLCAxLjApKS54eXogLSBwb3M7XG4gICAgICBmbG9hdCBkaXMgPSBsZW5ndGgoZGlyKTtcbiAgICAgIGRpciA9IG5vcm1hbGl6ZShkaXIpO1xuXG4gICAgICAvLyDogZrlhYnnga/nmoTmnJ3lkJFcbiAgICAgIHZlYzMgc3BvdERpciA9ICh2aWV3TWF0cml4ICogdmVjNChzcG90TGlnaHREaXJlY3Rpb25baV0sIDAuMCkpLnh5ejtcbiAgICAgIC8vIOmAmui/h+S9meW8puWAvOWIpOaWreWkueinkuiMg+WbtFxuICAgICAgZmxvYXQgYW5nID0gY29zKHNwb3RMaWdodEFuZ2xlW2ldKTtcbiAgICAgIGZsb2F0IHIgPSBzdGVwKGFuZywgZG90KGRpciwgbm9ybWFsaXplKC1zcG90RGlyKSkpO1xuXG4gICAgICBmbG9hdCBjb3MgPSBtYXgoZG90KGRpciwgbm9ybWFsKSwgMC4wKTtcbiAgICAgIGZsb2F0IGQgPSBtaW4oMS4wLCAxLjAgLyAoZGVjYXkueCAqIHBvdyhkaXMsIDIuMCkgKyBkZWNheS55ICogZGlzICsgZGVjYXkueikpO1xuICAgICAgZGlmZnVzZSArPSByICogZCAqIGNvcyAqIHNwb3RMaWdodENvbG9yW2ldO1xuICAgICAgc3BlY3VsYXIgKz0gciAqIGdldFNwZWN1bGFyKGRpciwgbm9ybWFsLCBleWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2ZWM0KGRpZmZ1c2UsIHNwZWN1bGFyKTtcbiAgfVxuXG4gIC8vIHZlYzMgZ2V0Tm9ybWFsKCkge1xuICAvLyAgIHZlYzMgbiA9IHRleHR1cmUodE5vcm1hbCwgdlV2KS5yZ2IgKiAyLjAgLSAxLjA7XG4gIC8vICAgcmV0dXJuIG5vcm1hbGl6ZSh2VEJOICogbik7XG4gIC8vIH1cblxuICB2ZWMzIGdldE5vcm1hbCgpIHtcbiAgICB2ZWMzIHBvc19keCA9IGRGZHgodlBvcy54eXopO1xuICAgIHZlYzMgcG9zX2R5ID0gZEZkeSh2UG9zLnh5eik7XG4gICAgdmVjMiB0ZXhfZHggPSBkRmR4KHZVdik7XG4gICAgdmVjMiB0ZXhfZHkgPSBkRmR5KHZVdik7XG5cbiAgICB2ZWMzIHQgPSBub3JtYWxpemUocG9zX2R4ICogdGV4X2R5LnQgLSBwb3NfZHkgKiB0ZXhfZHgudCk7XG4gICAgdmVjMyBiID0gbm9ybWFsaXplKC1wb3NfZHggKiB0ZXhfZHkucyArIHBvc19keSAqIHRleF9keC5zKTtcbiAgICBtYXQzIHRibiA9IG1hdDModCwgYiwgbm9ybWFsaXplKHZOb3JtYWwpKTtcblxuICAgIHZlYzMgbiA9IHRleHR1cmUodE5vcm1hbCwgdlV2KS5yZ2IgKiAyLjAgLSAxLjA7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZSh0Ym4gKiBuKTtcbiAgfVxuXG4gIHZvaWQgbWFpbigpIHtcbiAgICB2ZWMzIGV5ZURpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2Q2FtZXJhUG9zIC0gdlBvcyk7XG4gICAgdmVjMyBub3JtYWwgPSBnZXROb3JtYWwoKTtcbiAgICB2ZWM0IHBob25nID0gcGhvbmdSZWZsZWN0aW9uKHZQb3MsIG5vcm1hbCwgZXllRGlyZWN0aW9uKTtcblxuICAgIC8vIOWQiOaIkOminOiJslxuICAgIEZyYWdDb2xvci5yZ2IgPSBwaG9uZy53ICsgKHBob25nLnh5eiArIGFtYmllbnRMaWdodCkgKiBtYXRlcmlhbFJlZmxlY3Rpb247XG4gICAgRnJhZ0NvbG9yLmEgPSAxLjA7XG4gIH1cbmA7XG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbmNvbnN0IHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHtcbiAgY2FudmFzLFxuICB3aWR0aDogNTEyLFxuICBoZWlnaHQ6IDUxMixcbiAgYW50aWFsaWFzOiB0cnVlLFxuICBhbHBoYTogdHJ1ZVxufSk7XG5jb25zdCBnbCA9IHJlbmRlcmVyLmdsO1xuZ2wuY2xlYXJDb2xvcigxLCAxLCAxLCAxKTtcbmNvbnN0IGNhbWVyYSA9IG5ldyBDYW1lcmEoZ2wsIHtcbiAgZm92OiAzNVxufSk7XG5jYW1lcmEucG9zaXRpb24uc2V0KDIsIDIsIDIpO1xuY2FtZXJhLmxvb2tBdChbMCwgMCwgMF0pO1xuY29uc3Qgc2NlbmUgPSBuZXcgVHJhbnNmb3JtKCk7XG5jb25zdCBwaG9uZyA9IG5ldyBQaG9uZygpO1xucGhvbmcuYWRkTGlnaHQoe1xuICAvLyBjb2xvcjogWzEsIDAuNSwgMC41XSxcbiAgZGlyZWN0aW9uOiBbMCwgLTMsIC0zXVxufSk7XG5waG9uZy5hZGRMaWdodCh7XG4gIC8vIGNvbG9yOiBbMSwgMC41LCAxXSxcbiAgZGlyZWN0aW9uOiBbMCwgMywgM11cbn0pO1xuY29uc3QgbWF0cmlhbCA9IG5ldyBNYXRlcmlhbChuZXcgQ29sb3IoJyM4MDgwODAnKSk7XG5cbmZ1bmN0aW9uIGxvYWRUZXh0dXJlKHNyYykge1xuICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoZ2wpO1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgdGV4dHVyZS5pbWFnZSA9IGltZztcbiAgICAgIHJlc29sdmUodGV4dHVyZSk7XG4gICAgfTtcblxuICAgIGltZy5zcmMgPSBzcmM7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUQihnZW9tZXRyeSkge1xuICBjb25zdCB7XG4gICAgcG9zaXRpb24sXG4gICAgaW5kZXgsXG4gICAgdXZcbiAgfSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gIGlmICghdXYpIHRocm93IG5ldyBFcnJvcignTk8gdXYuJyk7XG5cbiAgZnVuY3Rpb24gZ2V0VEJOVHJpYW5nbGUocDEsIHAyLCBwMywgdXYxLCB1djIsIHV2Mykge1xuICAgIGNvbnN0IGVkZ2UxID0gbmV3IFZlYzMoKS5zdWIocDIsIHAxKTtcbiAgICBjb25zdCBlZGdlMiA9IG5ldyBWZWMzKCkuc3ViKHAzLCBwMSk7XG4gICAgY29uc3QgZGVsdGFVVjEgPSBuZXcgVmVjMigpLnN1Yih1djIsIHV2MSk7XG4gICAgY29uc3QgZGVsdGFVVjIgPSBuZXcgVmVjMigpLnN1Yih1djMsIHV2MSk7XG4gICAgY29uc3QgdGFuZyA9IG5ldyBWZWMzKCk7XG4gICAgY29uc3QgYml0YW5nID0gbmV3IFZlYzMoKTtcbiAgICBjb25zdCBmID0gMS4wIC8gKGRlbHRhVVYxLnggKiBkZWx0YVVWMi55IC0gZGVsdGFVVjIueCAqIGRlbHRhVVYxLnkpO1xuICAgIHRhbmcueCA9IGYgKiAoZGVsdGFVVjIueSAqIGVkZ2UxLnggLSBkZWx0YVVWMS55ICogZWRnZTIueCk7XG4gICAgdGFuZy55ID0gZiAqIChkZWx0YVVWMi55ICogZWRnZTEueSAtIGRlbHRhVVYxLnkgKiBlZGdlMi55KTtcbiAgICB0YW5nLnogPSBmICogKGRlbHRhVVYyLnkgKiBlZGdlMS56IC0gZGVsdGFVVjEueSAqIGVkZ2UyLnopO1xuICAgIHRhbmcubm9ybWFsaXplKCk7XG4gICAgYml0YW5nLnggPSBmICogKC1kZWx0YVVWMi54ICogZWRnZTEueCArIGRlbHRhVVYxLnggKiBlZGdlMi54KTtcbiAgICBiaXRhbmcueSA9IGYgKiAoLWRlbHRhVVYyLnggKiBlZGdlMS55ICsgZGVsdGFVVjEueCAqIGVkZ2UyLnkpO1xuICAgIGJpdGFuZy56ID0gZiAqICgtZGVsdGFVVjIueCAqIGVkZ2UxLnogKyBkZWx0YVVWMS54ICogZWRnZTIueik7XG4gICAgYml0YW5nLm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiB7XG4gICAgICB0YW5nLFxuICAgICAgYml0YW5nXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHNpemUgPSBwb3NpdGlvbi5zaXplO1xuICBpZiAoc2l6ZSA8IDMpIHRocm93IG5ldyBFcnJvcignRXJyb3IgZGltZW5zaW9uLicpO1xuICBjb25zdCBsZW4gPSBwb3NpdGlvbi5kYXRhLmxlbmd0aCAvIHNpemU7XG4gIGNvbnN0IHRhbmcgPSBuZXcgRmxvYXQzMkFycmF5KGxlbiAqIDMpO1xuICBjb25zdCBiaXRhbmcgPSBuZXcgRmxvYXQzMkFycmF5KGxlbiAqIDMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXguZGF0YS5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNvbnN0IGkxID0gaW5kZXguZGF0YVtpXTtcbiAgICBjb25zdCBpMiA9IGluZGV4LmRhdGFbaSArIDFdO1xuICAgIGNvbnN0IGkzID0gaW5kZXguZGF0YVtpICsgMl07XG4gICAgY29uc3QgcDEgPSBbcG9zaXRpb24uZGF0YVtpMSAqIHNpemVdLCBwb3NpdGlvbi5kYXRhW2kxICogc2l6ZSArIDFdLCBwb3NpdGlvbi5kYXRhW2kxICogc2l6ZSArIDJdXTtcbiAgICBjb25zdCBwMiA9IFtwb3NpdGlvbi5kYXRhW2kyICogc2l6ZV0sIHBvc2l0aW9uLmRhdGFbaTIgKiBzaXplICsgMV0sIHBvc2l0aW9uLmRhdGFbaTIgKiBzaXplICsgMl1dO1xuICAgIGNvbnN0IHAzID0gW3Bvc2l0aW9uLmRhdGFbaTMgKiBzaXplXSwgcG9zaXRpb24uZGF0YVtpMyAqIHNpemUgKyAxXSwgcG9zaXRpb24uZGF0YVtpMyAqIHNpemUgKyAyXV07XG4gICAgY29uc3QgdTEgPSBbdXYuZGF0YVtpMSAqIDJdLCB1di5kYXRhW2kxICogMiArIDFdXTtcbiAgICBjb25zdCB1MiA9IFt1di5kYXRhW2kyICogMl0sIHV2LmRhdGFbaTIgKiAyICsgMV1dO1xuICAgIGNvbnN0IHUzID0gW3V2LmRhdGFbaTMgKiAyXSwgdXYuZGF0YVtpMyAqIDIgKyAxXV07XG4gICAgY29uc3Qge1xuICAgICAgdGFuZzogdCxcbiAgICAgIGJpdGFuZzogYlxuICAgIH0gPSBnZXRUQk5UcmlhbmdsZShwMSwgcDIsIHAzLCB1MSwgdTIsIHUzKTtcbiAgICB0YW5nLnNldCh0LCBpMSAqIDMpO1xuICAgIHRhbmcuc2V0KHQsIGkyICogMyk7XG4gICAgdGFuZy5zZXQodCwgaTMgKiAzKTtcbiAgICBiaXRhbmcuc2V0KGIsIGkxICogMyk7XG4gICAgYml0YW5nLnNldChiLCBpMiAqIDMpO1xuICAgIGJpdGFuZy5zZXQoYiwgaTMgKiAzKTtcbiAgfVxuXG4gIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgndGFuZycsIHtcbiAgICBkYXRhOiB0YW5nLFxuICAgIHNpemU6IDNcbiAgfSk7XG4gIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYml0YW5nJywge1xuICAgIGRhdGE6IGJpdGFuZyxcbiAgICBzaXplOiAzXG4gIH0pO1xuICByZXR1cm4gZ2VvbWV0cnk7XG59XG5cbihhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IG5vcm1hbE1hcCA9IGF3YWl0IGxvYWRUZXh0dXJlKCcuLi8uLi9hc3NldHMvbm9ybWFsX21hcC5wbmcnKTtcbiAgY29uc3QgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB7XG4gICAgdmVydGV4LFxuICAgIGZyYWdtZW50LFxuICAgIHVuaWZvcm1zOiB7IC4uLnBob25nLnVuaWZvcm1zLFxuICAgICAgLi4ubWF0cmlhbC51bmlmb3JtcyxcbiAgICAgIHROb3JtYWw6IHtcbiAgICAgICAgdmFsdWU6IG5vcm1hbE1hcFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJveChnbCk7XG4gIGNyZWF0ZVRCKGdlb21ldHJ5KTtcbiAgY29uc3QgY3ViZSA9IG5ldyBNZXNoKGdsLCB7XG4gICAgZ2VvbWV0cnksXG4gICAgcHJvZ3JhbVxuICB9KTtcbiAgY3ViZS5zZXRQYXJlbnQoc2NlbmUpO1xuICBjdWJlLnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7IC8vIHJlbmRlcmVyLnJlbmRlcih7c2NlbmUsIGNhbWVyYX0pO1xuXG4gIGNvbnN0IGNvbnRyb2xzID0gbmV3IE9yYml0KGNhbWVyYSk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcbiAgICBjb250cm9scy51cGRhdGUoKTtcbiAgICByZW5kZXJlci5yZW5kZXIoe1xuICAgICAgc2NlbmUsXG4gICAgICBjYW1lcmFcbiAgICB9KTtcbiAgfVxufSkoKTsiXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./graphics/normal-maps/cube/cube.js\n")}});